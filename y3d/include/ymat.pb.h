// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ymat.proto

#ifndef PROTOBUF_ymat_2eproto__INCLUDED
#define PROTOBUF_ymat_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace y3d {
class YAmbient;
class YAmbientDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YAmbientDefaultTypeInternal _YAmbient_default_instance_;
class YBaseMap;
class YBaseMapDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YBaseMapDefaultTypeInternal _YBaseMap_default_instance_;
class YColor;
class YColorDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YColorDefaultTypeInternal _YColor_default_instance_;
class YDiffuse;
class YDiffuseDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YDiffuseDefaultTypeInternal _YDiffuse_default_instance_;
class YEmissive;
class YEmissiveDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YEmissiveDefaultTypeInternal _YEmissive_default_instance_;
class YImage;
class YImageDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YImageDefaultTypeInternal _YImage_default_instance_;
class YMat;
class YMatDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YMatDefaultTypeInternal _YMat_default_instance_;
class YMatMap;
class YMatMapDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YMatMapDefaultTypeInternal _YMatMap_default_instance_;
class YMatPBR;
class YMatPBRDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YMatPBRDefaultTypeInternal _YMatPBR_default_instance_;
class YMatStandard;
class YMatStandardDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YMatStandardDefaultTypeInternal _YMatStandard_default_instance_;
class YMatVray;
class YMatVrayDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YMatVrayDefaultTypeInternal _YMatVray_default_instance_;
class YMultiMat;
class YMultiMatDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YMultiMatDefaultTypeInternal _YMultiMat_default_instance_;
class YRGBColor;
class YRGBColorDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YRGBColorDefaultTypeInternal _YRGBColor_default_instance_;
class YSpecular;
class YSpecularDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YSpecularDefaultTypeInternal _YSpecular_default_instance_;
}  // namespace y3d

namespace y3d {

namespace protobuf_ymat_2eproto {
// Internal implementation detail -- do not call these.
struct Y3D_EXPORT_MACRO TableStruct {
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void Y3D_EXPORT_MACRO AddDescriptors();
void Y3D_EXPORT_MACRO InitDefaults();
}  // namespace protobuf_ymat_2eproto

enum BRDF_Type {
  PHONG = 0,
  BLINN = 1,
  WARD = 2,
  BRDF_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  BRDF_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
Y3D_EXPORT_MACRO bool BRDF_Type_IsValid(int value);
const BRDF_Type BRDF_Type_MIN = PHONG;
const BRDF_Type BRDF_Type_MAX = WARD;
const int BRDF_Type_ARRAYSIZE = BRDF_Type_MAX + 1;

Y3D_EXPORT_MACRO const ::google::protobuf::EnumDescriptor* BRDF_Type_descriptor();
inline const ::std::string& BRDF_Type_Name(BRDF_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    BRDF_Type_descriptor(), value);
}
inline bool BRDF_Type_Parse(
    const ::std::string& name, BRDF_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BRDF_Type>(
    BRDF_Type_descriptor(), name, value);
}
// ===================================================================

class Y3D_EXPORT_MACRO YRGBColor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YRGBColor) */ {
 public:
  YRGBColor();
  virtual ~YRGBColor();

  YRGBColor(const YRGBColor& from);

  inline YRGBColor& operator=(const YRGBColor& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YRGBColor& default_instance();

  static inline const YRGBColor* internal_default_instance() {
    return reinterpret_cast<const YRGBColor*>(
               &_YRGBColor_default_instance_);
  }

  void Swap(YRGBColor* other);

  // implements Message ----------------------------------------------

  inline YRGBColor* New() const PROTOBUF_FINAL { return New(NULL); }

  YRGBColor* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YRGBColor& from);
  void MergeFrom(const YRGBColor& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YRGBColor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 R = 1;
  void clear_r();
  static const int kRFieldNumber = 1;
  ::google::protobuf::uint32 r() const;
  void set_r(::google::protobuf::uint32 value);

  // uint32 G = 2;
  void clear_g();
  static const int kGFieldNumber = 2;
  ::google::protobuf::uint32 g() const;
  void set_g(::google::protobuf::uint32 value);

  // uint32 B = 3;
  void clear_b();
  static const int kBFieldNumber = 3;
  ::google::protobuf::uint32 b() const;
  void set_b(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:y3d.YRGBColor)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 r_;
  ::google::protobuf::uint32 g_;
  ::google::protobuf::uint32 b_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_ymat_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YColor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YColor) */ {
 public:
  YColor();
  virtual ~YColor();

  YColor(const YColor& from);

  inline YColor& operator=(const YColor& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YColor& default_instance();

  static inline const YColor* internal_default_instance() {
    return reinterpret_cast<const YColor*>(
               &_YColor_default_instance_);
  }

  void Swap(YColor* other);

  // implements Message ----------------------------------------------

  inline YColor* New() const PROTOBUF_FINAL { return New(NULL); }

  YColor* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YColor& from);
  void MergeFrom(const YColor& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YColor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string hex_color = 4;
  void clear_hex_color();
  static const int kHexColorFieldNumber = 4;
  const ::std::string& hex_color() const;
  void set_hex_color(const ::std::string& value);
  #if LANG_CXX11
  void set_hex_color(::std::string&& value);
  #endif
  void set_hex_color(const char* value);
  void set_hex_color(const char* value, size_t size);
  ::std::string* mutable_hex_color();
  ::std::string* release_hex_color();
  void set_allocated_hex_color(::std::string* hex_color);

  // .y3d.YRGBColor rgb = 3;
  bool has_rgb() const;
  void clear_rgb();
  static const int kRgbFieldNumber = 3;
  const ::y3d::YRGBColor& rgb() const;
  ::y3d::YRGBColor* mutable_rgb();
  ::y3d::YRGBColor* release_rgb();
  void set_allocated_rgb(::y3d::YRGBColor* rgb);

  // int32 argb = 2;
  void clear_argb();
  static const int kArgbFieldNumber = 2;
  ::google::protobuf::int32 argb() const;
  void set_argb(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:y3d.YColor)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr hex_color_;
  ::y3d::YRGBColor* rgb_;
  ::google::protobuf::int32 argb_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_ymat_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YImage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YImage) */ {
 public:
  YImage();
  virtual ~YImage();

  YImage(const YImage& from);

  inline YImage& operator=(const YImage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YImage& default_instance();

  static inline const YImage* internal_default_instance() {
    return reinterpret_cast<const YImage*>(
               &_YImage_default_instance_);
  }

  void Swap(YImage* other);

  // implements Message ----------------------------------------------

  inline YImage* New() const PROTOBUF_FINAL { return New(NULL); }

  YImage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YImage& from);
  void MergeFrom(const YImage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YImage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string file = 1;
  void clear_file();
  static const int kFileFieldNumber = 1;
  const ::std::string& file() const;
  void set_file(const ::std::string& value);
  #if LANG_CXX11
  void set_file(::std::string&& value);
  #endif
  void set_file(const char* value);
  void set_file(const char* value, size_t size);
  ::std::string* mutable_file();
  ::std::string* release_file();
  void set_allocated_file(::std::string* file);

  // float scale = 2;
  void clear_scale();
  static const int kScaleFieldNumber = 2;
  float scale() const;
  void set_scale(float value);

  // @@protoc_insertion_point(class_scope:y3d.YImage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr file_;
  float scale_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_ymat_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YDiffuse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YDiffuse) */ {
 public:
  YDiffuse();
  virtual ~YDiffuse();

  YDiffuse(const YDiffuse& from);

  inline YDiffuse& operator=(const YDiffuse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YDiffuse& default_instance();

  static inline const YDiffuse* internal_default_instance() {
    return reinterpret_cast<const YDiffuse*>(
               &_YDiffuse_default_instance_);
  }

  void Swap(YDiffuse* other);

  // implements Message ----------------------------------------------

  inline YDiffuse* New() const PROTOBUF_FINAL { return New(NULL); }

  YDiffuse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YDiffuse& from);
  void MergeFrom(const YDiffuse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YDiffuse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string set_name = 1;
  void clear_set_name();
  static const int kSetNameFieldNumber = 1;
  const ::std::string& set_name() const;
  void set_set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_set_name(::std::string&& value);
  #endif
  void set_set_name(const char* value);
  void set_set_name(const char* value, size_t size);
  ::std::string* mutable_set_name();
  ::std::string* release_set_name();
  void set_allocated_set_name(::std::string* set_name);

  // .y3d.YColor color = 2;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 2;
  const ::y3d::YColor& color() const;
  ::y3d::YColor* mutable_color();
  ::y3d::YColor* release_color();
  void set_allocated_color(::y3d::YColor* color);

  // .y3d.YImage image = 3;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 3;
  const ::y3d::YImage& image() const;
  ::y3d::YImage* mutable_image();
  ::y3d::YImage* release_image();
  void set_allocated_image(::y3d::YImage* image);

  // @@protoc_insertion_point(class_scope:y3d.YDiffuse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr set_name_;
  ::y3d::YColor* color_;
  ::y3d::YImage* image_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_ymat_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YSpecular : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YSpecular) */ {
 public:
  YSpecular();
  virtual ~YSpecular();

  YSpecular(const YSpecular& from);

  inline YSpecular& operator=(const YSpecular& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YSpecular& default_instance();

  static inline const YSpecular* internal_default_instance() {
    return reinterpret_cast<const YSpecular*>(
               &_YSpecular_default_instance_);
  }

  void Swap(YSpecular* other);

  // implements Message ----------------------------------------------

  inline YSpecular* New() const PROTOBUF_FINAL { return New(NULL); }

  YSpecular* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YSpecular& from);
  void MergeFrom(const YSpecular& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YSpecular* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string set_name = 1;
  void clear_set_name();
  static const int kSetNameFieldNumber = 1;
  const ::std::string& set_name() const;
  void set_set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_set_name(::std::string&& value);
  #endif
  void set_set_name(const char* value);
  void set_set_name(const char* value, size_t size);
  ::std::string* mutable_set_name();
  ::std::string* release_set_name();
  void set_allocated_set_name(::std::string* set_name);

  // .y3d.YColor color = 2;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 2;
  const ::y3d::YColor& color() const;
  ::y3d::YColor* mutable_color();
  ::y3d::YColor* release_color();
  void set_allocated_color(::y3d::YColor* color);

  // .y3d.YImage image = 3;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 3;
  const ::y3d::YImage& image() const;
  ::y3d::YImage* mutable_image();
  ::y3d::YImage* release_image();
  void set_allocated_image(::y3d::YImage* image);

  // @@protoc_insertion_point(class_scope:y3d.YSpecular)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr set_name_;
  ::y3d::YColor* color_;
  ::y3d::YImage* image_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_ymat_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YAmbient : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YAmbient) */ {
 public:
  YAmbient();
  virtual ~YAmbient();

  YAmbient(const YAmbient& from);

  inline YAmbient& operator=(const YAmbient& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YAmbient& default_instance();

  static inline const YAmbient* internal_default_instance() {
    return reinterpret_cast<const YAmbient*>(
               &_YAmbient_default_instance_);
  }

  void Swap(YAmbient* other);

  // implements Message ----------------------------------------------

  inline YAmbient* New() const PROTOBUF_FINAL { return New(NULL); }

  YAmbient* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YAmbient& from);
  void MergeFrom(const YAmbient& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YAmbient* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string set_name = 1;
  void clear_set_name();
  static const int kSetNameFieldNumber = 1;
  const ::std::string& set_name() const;
  void set_set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_set_name(::std::string&& value);
  #endif
  void set_set_name(const char* value);
  void set_set_name(const char* value, size_t size);
  ::std::string* mutable_set_name();
  ::std::string* release_set_name();
  void set_allocated_set_name(::std::string* set_name);

  // .y3d.YColor color = 2;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 2;
  const ::y3d::YColor& color() const;
  ::y3d::YColor* mutable_color();
  ::y3d::YColor* release_color();
  void set_allocated_color(::y3d::YColor* color);

  // .y3d.YImage image = 3;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 3;
  const ::y3d::YImage& image() const;
  ::y3d::YImage* mutable_image();
  ::y3d::YImage* release_image();
  void set_allocated_image(::y3d::YImage* image);

  // @@protoc_insertion_point(class_scope:y3d.YAmbient)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr set_name_;
  ::y3d::YColor* color_;
  ::y3d::YImage* image_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_ymat_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YEmissive : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YEmissive) */ {
 public:
  YEmissive();
  virtual ~YEmissive();

  YEmissive(const YEmissive& from);

  inline YEmissive& operator=(const YEmissive& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YEmissive& default_instance();

  static inline const YEmissive* internal_default_instance() {
    return reinterpret_cast<const YEmissive*>(
               &_YEmissive_default_instance_);
  }

  void Swap(YEmissive* other);

  // implements Message ----------------------------------------------

  inline YEmissive* New() const PROTOBUF_FINAL { return New(NULL); }

  YEmissive* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YEmissive& from);
  void MergeFrom(const YEmissive& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YEmissive* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string set_name = 1;
  void clear_set_name();
  static const int kSetNameFieldNumber = 1;
  const ::std::string& set_name() const;
  void set_set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_set_name(::std::string&& value);
  #endif
  void set_set_name(const char* value);
  void set_set_name(const char* value, size_t size);
  ::std::string* mutable_set_name();
  ::std::string* release_set_name();
  void set_allocated_set_name(::std::string* set_name);

  // .y3d.YColor color = 2;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 2;
  const ::y3d::YColor& color() const;
  ::y3d::YColor* mutable_color();
  ::y3d::YColor* release_color();
  void set_allocated_color(::y3d::YColor* color);

  // .y3d.YImage image = 3;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 3;
  const ::y3d::YImage& image() const;
  ::y3d::YImage* mutable_image();
  ::y3d::YImage* release_image();
  void set_allocated_image(::y3d::YImage* image);

  // @@protoc_insertion_point(class_scope:y3d.YEmissive)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr set_name_;
  ::y3d::YColor* color_;
  ::y3d::YImage* image_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_ymat_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YMatPBR : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YMatPBR) */ {
 public:
  YMatPBR();
  virtual ~YMatPBR();

  YMatPBR(const YMatPBR& from);

  inline YMatPBR& operator=(const YMatPBR& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YMatPBR& default_instance();

  static inline const YMatPBR* internal_default_instance() {
    return reinterpret_cast<const YMatPBR*>(
               &_YMatPBR_default_instance_);
  }

  void Swap(YMatPBR* other);

  // implements Message ----------------------------------------------

  inline YMatPBR* New() const PROTOBUF_FINAL { return New(NULL); }

  YMatPBR* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YMatPBR& from);
  void MergeFrom(const YMatPBR& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YMatPBR* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:y3d.YMatPBR)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_ymat_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YMatMap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YMatMap) */ {
 public:
  YMatMap();
  virtual ~YMatMap();

  YMatMap(const YMatMap& from);

  inline YMatMap& operator=(const YMatMap& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YMatMap& default_instance();

  static inline const YMatMap* internal_default_instance() {
    return reinterpret_cast<const YMatMap*>(
               &_YMatMap_default_instance_);
  }

  void Swap(YMatMap* other);

  // implements Message ----------------------------------------------

  inline YMatMap* New() const PROTOBUF_FINAL { return New(NULL); }

  YMatMap* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YMatMap& from);
  void MergeFrom(const YMatMap& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YMatMap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 3;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .y3d.YImage image = 1;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 1;
  const ::y3d::YImage& image() const;
  ::y3d::YImage* mutable_image();
  ::y3d::YImage* release_image();
  void set_allocated_image(::y3d::YImage* image);

  // float scale = 2;
  void clear_scale();
  static const int kScaleFieldNumber = 2;
  float scale() const;
  void set_scale(float value);

  // @@protoc_insertion_point(class_scope:y3d.YMatMap)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::y3d::YImage* image_;
  float scale_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_ymat_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YBaseMap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YBaseMap) */ {
 public:
  YBaseMap();
  virtual ~YBaseMap();

  YBaseMap(const YBaseMap& from);

  inline YBaseMap& operator=(const YBaseMap& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YBaseMap& default_instance();

  static inline const YBaseMap* internal_default_instance() {
    return reinterpret_cast<const YBaseMap*>(
               &_YBaseMap_default_instance_);
  }

  void Swap(YBaseMap* other);

  // implements Message ----------------------------------------------

  inline YBaseMap* New() const PROTOBUF_FINAL { return New(NULL); }

  YBaseMap* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YBaseMap& from);
  void MergeFrom(const YBaseMap& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YBaseMap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .y3d.YMatMap albedo = 1;
  bool has_albedo() const;
  void clear_albedo();
  static const int kAlbedoFieldNumber = 1;
  const ::y3d::YMatMap& albedo() const;
  ::y3d::YMatMap* mutable_albedo();
  ::y3d::YMatMap* release_albedo();
  void set_allocated_albedo(::y3d::YMatMap* albedo);

  // .y3d.YMatMap bump = 2;
  bool has_bump() const;
  void clear_bump();
  static const int kBumpFieldNumber = 2;
  const ::y3d::YMatMap& bump() const;
  ::y3d::YMatMap* mutable_bump();
  ::y3d::YMatMap* release_bump();
  void set_allocated_bump(::y3d::YMatMap* bump);

  // .y3d.YMatMap normal = 3;
  bool has_normal() const;
  void clear_normal();
  static const int kNormalFieldNumber = 3;
  const ::y3d::YMatMap& normal() const;
  ::y3d::YMatMap* mutable_normal();
  ::y3d::YMatMap* release_normal();
  void set_allocated_normal(::y3d::YMatMap* normal);

  // .y3d.YMatMap ao = 4;
  bool has_ao() const;
  void clear_ao();
  static const int kAoFieldNumber = 4;
  const ::y3d::YMatMap& ao() const;
  ::y3d::YMatMap* mutable_ao();
  ::y3d::YMatMap* release_ao();
  void set_allocated_ao(::y3d::YMatMap* ao);

  // .y3d.YMatMap specular = 5;
  bool has_specular() const;
  void clear_specular();
  static const int kSpecularFieldNumber = 5;
  const ::y3d::YMatMap& specular() const;
  ::y3d::YMatMap* mutable_specular();
  ::y3d::YMatMap* release_specular();
  void set_allocated_specular(::y3d::YMatMap* specular);

  // .y3d.YMatMap displacement = 6;
  bool has_displacement() const;
  void clear_displacement();
  static const int kDisplacementFieldNumber = 6;
  const ::y3d::YMatMap& displacement() const;
  ::y3d::YMatMap* mutable_displacement();
  ::y3d::YMatMap* release_displacement();
  void set_allocated_displacement(::y3d::YMatMap* displacement);

  // .y3d.YMatMap transclucency = 79;
  bool has_transclucency() const;
  void clear_transclucency();
  static const int kTransclucencyFieldNumber = 79;
  const ::y3d::YMatMap& transclucency() const;
  ::y3d::YMatMap* mutable_transclucency();
  ::y3d::YMatMap* release_transclucency();
  void set_allocated_transclucency(::y3d::YMatMap* transclucency);

  // .y3d.YMatMap roughness = 8;
  bool has_roughness() const;
  void clear_roughness();
  static const int kRoughnessFieldNumber = 8;
  const ::y3d::YMatMap& roughness() const;
  ::y3d::YMatMap* mutable_roughness();
  ::y3d::YMatMap* release_roughness();
  void set_allocated_roughness(::y3d::YMatMap* roughness);

  // .y3d.YMatMap opactity = 9;
  bool has_opactity() const;
  void clear_opactity();
  static const int kOpactityFieldNumber = 9;
  const ::y3d::YMatMap& opactity() const;
  ::y3d::YMatMap* mutable_opactity();
  ::y3d::YMatMap* release_opactity();
  void set_allocated_opactity(::y3d::YMatMap* opactity);

  // @@protoc_insertion_point(class_scope:y3d.YBaseMap)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::y3d::YMatMap* albedo_;
  ::y3d::YMatMap* bump_;
  ::y3d::YMatMap* normal_;
  ::y3d::YMatMap* ao_;
  ::y3d::YMatMap* specular_;
  ::y3d::YMatMap* displacement_;
  ::y3d::YMatMap* transclucency_;
  ::y3d::YMatMap* roughness_;
  ::y3d::YMatMap* opactity_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_ymat_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YMatStandard : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YMatStandard) */ {
 public:
  YMatStandard();
  virtual ~YMatStandard();

  YMatStandard(const YMatStandard& from);

  inline YMatStandard& operator=(const YMatStandard& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YMatStandard& default_instance();

  static inline const YMatStandard* internal_default_instance() {
    return reinterpret_cast<const YMatStandard*>(
               &_YMatStandard_default_instance_);
  }

  void Swap(YMatStandard* other);

  // implements Message ----------------------------------------------

  inline YMatStandard* New() const PROTOBUF_FINAL { return New(NULL); }

  YMatStandard* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YMatStandard& from);
  void MergeFrom(const YMatStandard& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YMatStandard* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .y3d.YDiffuse diffuse = 3;
  bool has_diffuse() const;
  void clear_diffuse();
  static const int kDiffuseFieldNumber = 3;
  const ::y3d::YDiffuse& diffuse() const;
  ::y3d::YDiffuse* mutable_diffuse();
  ::y3d::YDiffuse* release_diffuse();
  void set_allocated_diffuse(::y3d::YDiffuse* diffuse);

  // .y3d.YSpecular specular = 4;
  bool has_specular() const;
  void clear_specular();
  static const int kSpecularFieldNumber = 4;
  const ::y3d::YSpecular& specular() const;
  ::y3d::YSpecular* mutable_specular();
  ::y3d::YSpecular* release_specular();
  void set_allocated_specular(::y3d::YSpecular* specular);

  // .y3d.YAmbient ambient = 5;
  bool has_ambient() const;
  void clear_ambient();
  static const int kAmbientFieldNumber = 5;
  const ::y3d::YAmbient& ambient() const;
  ::y3d::YAmbient* mutable_ambient();
  ::y3d::YAmbient* release_ambient();
  void set_allocated_ambient(::y3d::YAmbient* ambient);

  // .y3d.YEmissive emissive = 6;
  bool has_emissive() const;
  void clear_emissive();
  static const int kEmissiveFieldNumber = 6;
  const ::y3d::YEmissive& emissive() const;
  ::y3d::YEmissive* mutable_emissive();
  ::y3d::YEmissive* release_emissive();
  void set_allocated_emissive(::y3d::YEmissive* emissive);

  // .y3d.YBaseMap map = 7;
  bool has_map() const;
  void clear_map();
  static const int kMapFieldNumber = 7;
  const ::y3d::YBaseMap& map() const;
  ::y3d::YBaseMap* mutable_map();
  ::y3d::YBaseMap* release_map();
  void set_allocated_map(::y3d::YBaseMap* map);

  // uint32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:y3d.YMatStandard)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::y3d::YDiffuse* diffuse_;
  ::y3d::YSpecular* specular_;
  ::y3d::YAmbient* ambient_;
  ::y3d::YEmissive* emissive_;
  ::y3d::YBaseMap* map_;
  ::google::protobuf::uint32 id_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_ymat_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YMatVray : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YMatVray) */ {
 public:
  YMatVray();
  virtual ~YMatVray();

  YMatVray(const YMatVray& from);

  inline YMatVray& operator=(const YMatVray& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YMatVray& default_instance();

  static inline const YMatVray* internal_default_instance() {
    return reinterpret_cast<const YMatVray*>(
               &_YMatVray_default_instance_);
  }

  void Swap(YMatVray* other);

  // implements Message ----------------------------------------------

  inline YMatVray* New() const PROTOBUF_FINAL { return New(NULL); }

  YMatVray* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YMatVray& from);
  void MergeFrom(const YMatVray& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YMatVray* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .y3d.YDiffuse diffuse = 2;
  bool has_diffuse() const;
  void clear_diffuse();
  static const int kDiffuseFieldNumber = 2;
  const ::y3d::YDiffuse& diffuse() const;
  ::y3d::YDiffuse* mutable_diffuse();
  ::y3d::YDiffuse* release_diffuse();
  void set_allocated_diffuse(::y3d::YDiffuse* diffuse);

  // .y3d.YBaseMap map = 3;
  bool has_map() const;
  void clear_map();
  static const int kMapFieldNumber = 3;
  const ::y3d::YBaseMap& map() const;
  ::y3d::YBaseMap* mutable_map();
  ::y3d::YBaseMap* release_map();
  void set_allocated_map(::y3d::YBaseMap* map);

  // .y3d.BRDF_Type brdf = 1;
  void clear_brdf();
  static const int kBrdfFieldNumber = 1;
  ::y3d::BRDF_Type brdf() const;
  void set_brdf(::y3d::BRDF_Type value);

  // @@protoc_insertion_point(class_scope:y3d.YMatVray)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::y3d::YDiffuse* diffuse_;
  ::y3d::YBaseMap* map_;
  int brdf_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_ymat_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YMat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YMat) */ {
 public:
  YMat();
  virtual ~YMat();

  YMat(const YMat& from);

  inline YMat& operator=(const YMat& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YMat& default_instance();

  static inline const YMat* internal_default_instance() {
    return reinterpret_cast<const YMat*>(
               &_YMat_default_instance_);
  }

  void Swap(YMat* other);

  // implements Message ----------------------------------------------

  inline YMat* New() const PROTOBUF_FINAL { return New(NULL); }

  YMat* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YMat& from);
  void MergeFrom(const YMat& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YMat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .y3d.YMatStandard m_standard = 3;
  bool has_m_standard() const;
  void clear_m_standard();
  static const int kMStandardFieldNumber = 3;
  const ::y3d::YMatStandard& m_standard() const;
  ::y3d::YMatStandard* mutable_m_standard();
  ::y3d::YMatStandard* release_m_standard();
  void set_allocated_m_standard(::y3d::YMatStandard* m_standard);

  // .y3d.YMatVray m_vray = 4;
  bool has_m_vray() const;
  void clear_m_vray();
  static const int kMVrayFieldNumber = 4;
  const ::y3d::YMatVray& m_vray() const;
  ::y3d::YMatVray* mutable_m_vray();
  ::y3d::YMatVray* release_m_vray();
  void set_allocated_m_vray(::y3d::YMatVray* m_vray);

  // .y3d.YMatPBR m_pbr = 5;
  bool has_m_pbr() const;
  void clear_m_pbr();
  static const int kMPbrFieldNumber = 5;
  const ::y3d::YMatPBR& m_pbr() const;
  ::y3d::YMatPBR* mutable_m_pbr();
  ::y3d::YMatPBR* release_m_pbr();
  void set_allocated_m_pbr(::y3d::YMatPBR* m_pbr);

  // .y3d.YMultiMat m_multi = 6;
  bool has_m_multi() const;
  void clear_m_multi();
  static const int kMMultiFieldNumber = 6;
  const ::y3d::YMultiMat& m_multi() const;
  ::y3d::YMultiMat* mutable_m_multi();
  ::y3d::YMultiMat* release_m_multi();
  void set_allocated_m_multi(::y3d::YMultiMat* m_multi);

  // uint32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:y3d.YMat)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::y3d::YMatStandard* m_standard_;
  ::y3d::YMatVray* m_vray_;
  ::y3d::YMatPBR* m_pbr_;
  ::y3d::YMultiMat* m_multi_;
  ::google::protobuf::uint32 id_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_ymat_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YMultiMat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YMultiMat) */ {
 public:
  YMultiMat();
  virtual ~YMultiMat();

  YMultiMat(const YMultiMat& from);

  inline YMultiMat& operator=(const YMultiMat& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YMultiMat& default_instance();

  static inline const YMultiMat* internal_default_instance() {
    return reinterpret_cast<const YMultiMat*>(
               &_YMultiMat_default_instance_);
  }

  void Swap(YMultiMat* other);

  // implements Message ----------------------------------------------

  inline YMultiMat* New() const PROTOBUF_FINAL { return New(NULL); }

  YMultiMat* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YMultiMat& from);
  void MergeFrom(const YMultiMat& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YMultiMat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .y3d.YMat materials = 2;
  int materials_size() const;
  void clear_materials();
  static const int kMaterialsFieldNumber = 2;
  const ::y3d::YMat& materials(int index) const;
  ::y3d::YMat* mutable_materials(int index);
  ::y3d::YMat* add_materials();
  ::google::protobuf::RepeatedPtrField< ::y3d::YMat >*
      mutable_materials();
  const ::google::protobuf::RepeatedPtrField< ::y3d::YMat >&
      materials() const;

  // .y3d.YDiffuse default_diffuse = 1;
  bool has_default_diffuse() const;
  void clear_default_diffuse();
  static const int kDefaultDiffuseFieldNumber = 1;
  const ::y3d::YDiffuse& default_diffuse() const;
  ::y3d::YDiffuse* mutable_default_diffuse();
  ::y3d::YDiffuse* release_default_diffuse();
  void set_allocated_default_diffuse(::y3d::YDiffuse* default_diffuse);

  // @@protoc_insertion_point(class_scope:y3d.YMultiMat)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::y3d::YMat > materials_;
  ::y3d::YDiffuse* default_diffuse_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_ymat_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// YRGBColor

// uint32 R = 1;
inline void YRGBColor::clear_r() {
  r_ = 0u;
}
inline ::google::protobuf::uint32 YRGBColor::r() const {
  // @@protoc_insertion_point(field_get:y3d.YRGBColor.R)
  return r_;
}
inline void YRGBColor::set_r(::google::protobuf::uint32 value) {
  
  r_ = value;
  // @@protoc_insertion_point(field_set:y3d.YRGBColor.R)
}

// uint32 G = 2;
inline void YRGBColor::clear_g() {
  g_ = 0u;
}
inline ::google::protobuf::uint32 YRGBColor::g() const {
  // @@protoc_insertion_point(field_get:y3d.YRGBColor.G)
  return g_;
}
inline void YRGBColor::set_g(::google::protobuf::uint32 value) {
  
  g_ = value;
  // @@protoc_insertion_point(field_set:y3d.YRGBColor.G)
}

// uint32 B = 3;
inline void YRGBColor::clear_b() {
  b_ = 0u;
}
inline ::google::protobuf::uint32 YRGBColor::b() const {
  // @@protoc_insertion_point(field_get:y3d.YRGBColor.B)
  return b_;
}
inline void YRGBColor::set_b(::google::protobuf::uint32 value) {
  
  b_ = value;
  // @@protoc_insertion_point(field_set:y3d.YRGBColor.B)
}

// -------------------------------------------------------------------

// YColor

// string name = 1;
inline void YColor::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YColor::name() const {
  // @@protoc_insertion_point(field_get:y3d.YColor.name)
  return name_.GetNoArena();
}
inline void YColor::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YColor.name)
}
#if LANG_CXX11
inline void YColor::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.YColor.name)
}
#endif
inline void YColor::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YColor.name)
}
inline void YColor::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YColor.name)
}
inline ::std::string* YColor::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YColor.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YColor::release_name() {
  // @@protoc_insertion_point(field_release:y3d.YColor.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YColor::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:y3d.YColor.name)
}

// int32 argb = 2;
inline void YColor::clear_argb() {
  argb_ = 0;
}
inline ::google::protobuf::int32 YColor::argb() const {
  // @@protoc_insertion_point(field_get:y3d.YColor.argb)
  return argb_;
}
inline void YColor::set_argb(::google::protobuf::int32 value) {
  
  argb_ = value;
  // @@protoc_insertion_point(field_set:y3d.YColor.argb)
}

// .y3d.YRGBColor rgb = 3;
inline bool YColor::has_rgb() const {
  return this != internal_default_instance() && rgb_ != NULL;
}
inline void YColor::clear_rgb() {
  if (GetArenaNoVirtual() == NULL && rgb_ != NULL) delete rgb_;
  rgb_ = NULL;
}
inline const ::y3d::YRGBColor& YColor::rgb() const {
  // @@protoc_insertion_point(field_get:y3d.YColor.rgb)
  return rgb_ != NULL ? *rgb_
                         : *::y3d::YRGBColor::internal_default_instance();
}
inline ::y3d::YRGBColor* YColor::mutable_rgb() {
  
  if (rgb_ == NULL) {
    rgb_ = new ::y3d::YRGBColor;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YColor.rgb)
  return rgb_;
}
inline ::y3d::YRGBColor* YColor::release_rgb() {
  // @@protoc_insertion_point(field_release:y3d.YColor.rgb)
  
  ::y3d::YRGBColor* temp = rgb_;
  rgb_ = NULL;
  return temp;
}
inline void YColor::set_allocated_rgb(::y3d::YRGBColor* rgb) {
  delete rgb_;
  rgb_ = rgb;
  if (rgb) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YColor.rgb)
}

// string hex_color = 4;
inline void YColor::clear_hex_color() {
  hex_color_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YColor::hex_color() const {
  // @@protoc_insertion_point(field_get:y3d.YColor.hex_color)
  return hex_color_.GetNoArena();
}
inline void YColor::set_hex_color(const ::std::string& value) {
  
  hex_color_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YColor.hex_color)
}
#if LANG_CXX11
inline void YColor::set_hex_color(::std::string&& value) {
  
  hex_color_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.YColor.hex_color)
}
#endif
inline void YColor::set_hex_color(const char* value) {
  
  hex_color_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YColor.hex_color)
}
inline void YColor::set_hex_color(const char* value, size_t size) {
  
  hex_color_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YColor.hex_color)
}
inline ::std::string* YColor::mutable_hex_color() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YColor.hex_color)
  return hex_color_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YColor::release_hex_color() {
  // @@protoc_insertion_point(field_release:y3d.YColor.hex_color)
  
  return hex_color_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YColor::set_allocated_hex_color(::std::string* hex_color) {
  if (hex_color != NULL) {
    
  } else {
    
  }
  hex_color_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hex_color);
  // @@protoc_insertion_point(field_set_allocated:y3d.YColor.hex_color)
}

// -------------------------------------------------------------------

// YImage

// string file = 1;
inline void YImage::clear_file() {
  file_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YImage::file() const {
  // @@protoc_insertion_point(field_get:y3d.YImage.file)
  return file_.GetNoArena();
}
inline void YImage::set_file(const ::std::string& value) {
  
  file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YImage.file)
}
#if LANG_CXX11
inline void YImage::set_file(::std::string&& value) {
  
  file_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.YImage.file)
}
#endif
inline void YImage::set_file(const char* value) {
  
  file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YImage.file)
}
inline void YImage::set_file(const char* value, size_t size) {
  
  file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YImage.file)
}
inline ::std::string* YImage::mutable_file() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YImage.file)
  return file_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YImage::release_file() {
  // @@protoc_insertion_point(field_release:y3d.YImage.file)
  
  return file_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YImage::set_allocated_file(::std::string* file) {
  if (file != NULL) {
    
  } else {
    
  }
  file_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file);
  // @@protoc_insertion_point(field_set_allocated:y3d.YImage.file)
}

// float scale = 2;
inline void YImage::clear_scale() {
  scale_ = 0;
}
inline float YImage::scale() const {
  // @@protoc_insertion_point(field_get:y3d.YImage.scale)
  return scale_;
}
inline void YImage::set_scale(float value) {
  
  scale_ = value;
  // @@protoc_insertion_point(field_set:y3d.YImage.scale)
}

// -------------------------------------------------------------------

// YDiffuse

// string set_name = 1;
inline void YDiffuse::clear_set_name() {
  set_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YDiffuse::set_name() const {
  // @@protoc_insertion_point(field_get:y3d.YDiffuse.set_name)
  return set_name_.GetNoArena();
}
inline void YDiffuse::set_set_name(const ::std::string& value) {
  
  set_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YDiffuse.set_name)
}
#if LANG_CXX11
inline void YDiffuse::set_set_name(::std::string&& value) {
  
  set_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.YDiffuse.set_name)
}
#endif
inline void YDiffuse::set_set_name(const char* value) {
  
  set_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YDiffuse.set_name)
}
inline void YDiffuse::set_set_name(const char* value, size_t size) {
  
  set_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YDiffuse.set_name)
}
inline ::std::string* YDiffuse::mutable_set_name() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YDiffuse.set_name)
  return set_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YDiffuse::release_set_name() {
  // @@protoc_insertion_point(field_release:y3d.YDiffuse.set_name)
  
  return set_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YDiffuse::set_allocated_set_name(::std::string* set_name) {
  if (set_name != NULL) {
    
  } else {
    
  }
  set_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), set_name);
  // @@protoc_insertion_point(field_set_allocated:y3d.YDiffuse.set_name)
}

// .y3d.YColor color = 2;
inline bool YDiffuse::has_color() const {
  return this != internal_default_instance() && color_ != NULL;
}
inline void YDiffuse::clear_color() {
  if (GetArenaNoVirtual() == NULL && color_ != NULL) delete color_;
  color_ = NULL;
}
inline const ::y3d::YColor& YDiffuse::color() const {
  // @@protoc_insertion_point(field_get:y3d.YDiffuse.color)
  return color_ != NULL ? *color_
                         : *::y3d::YColor::internal_default_instance();
}
inline ::y3d::YColor* YDiffuse::mutable_color() {
  
  if (color_ == NULL) {
    color_ = new ::y3d::YColor;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YDiffuse.color)
  return color_;
}
inline ::y3d::YColor* YDiffuse::release_color() {
  // @@protoc_insertion_point(field_release:y3d.YDiffuse.color)
  
  ::y3d::YColor* temp = color_;
  color_ = NULL;
  return temp;
}
inline void YDiffuse::set_allocated_color(::y3d::YColor* color) {
  delete color_;
  color_ = color;
  if (color) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YDiffuse.color)
}

// .y3d.YImage image = 3;
inline bool YDiffuse::has_image() const {
  return this != internal_default_instance() && image_ != NULL;
}
inline void YDiffuse::clear_image() {
  if (GetArenaNoVirtual() == NULL && image_ != NULL) delete image_;
  image_ = NULL;
}
inline const ::y3d::YImage& YDiffuse::image() const {
  // @@protoc_insertion_point(field_get:y3d.YDiffuse.image)
  return image_ != NULL ? *image_
                         : *::y3d::YImage::internal_default_instance();
}
inline ::y3d::YImage* YDiffuse::mutable_image() {
  
  if (image_ == NULL) {
    image_ = new ::y3d::YImage;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YDiffuse.image)
  return image_;
}
inline ::y3d::YImage* YDiffuse::release_image() {
  // @@protoc_insertion_point(field_release:y3d.YDiffuse.image)
  
  ::y3d::YImage* temp = image_;
  image_ = NULL;
  return temp;
}
inline void YDiffuse::set_allocated_image(::y3d::YImage* image) {
  delete image_;
  image_ = image;
  if (image) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YDiffuse.image)
}

// -------------------------------------------------------------------

// YSpecular

// string set_name = 1;
inline void YSpecular::clear_set_name() {
  set_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YSpecular::set_name() const {
  // @@protoc_insertion_point(field_get:y3d.YSpecular.set_name)
  return set_name_.GetNoArena();
}
inline void YSpecular::set_set_name(const ::std::string& value) {
  
  set_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YSpecular.set_name)
}
#if LANG_CXX11
inline void YSpecular::set_set_name(::std::string&& value) {
  
  set_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.YSpecular.set_name)
}
#endif
inline void YSpecular::set_set_name(const char* value) {
  
  set_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YSpecular.set_name)
}
inline void YSpecular::set_set_name(const char* value, size_t size) {
  
  set_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YSpecular.set_name)
}
inline ::std::string* YSpecular::mutable_set_name() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YSpecular.set_name)
  return set_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YSpecular::release_set_name() {
  // @@protoc_insertion_point(field_release:y3d.YSpecular.set_name)
  
  return set_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YSpecular::set_allocated_set_name(::std::string* set_name) {
  if (set_name != NULL) {
    
  } else {
    
  }
  set_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), set_name);
  // @@protoc_insertion_point(field_set_allocated:y3d.YSpecular.set_name)
}

// .y3d.YColor color = 2;
inline bool YSpecular::has_color() const {
  return this != internal_default_instance() && color_ != NULL;
}
inline void YSpecular::clear_color() {
  if (GetArenaNoVirtual() == NULL && color_ != NULL) delete color_;
  color_ = NULL;
}
inline const ::y3d::YColor& YSpecular::color() const {
  // @@protoc_insertion_point(field_get:y3d.YSpecular.color)
  return color_ != NULL ? *color_
                         : *::y3d::YColor::internal_default_instance();
}
inline ::y3d::YColor* YSpecular::mutable_color() {
  
  if (color_ == NULL) {
    color_ = new ::y3d::YColor;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YSpecular.color)
  return color_;
}
inline ::y3d::YColor* YSpecular::release_color() {
  // @@protoc_insertion_point(field_release:y3d.YSpecular.color)
  
  ::y3d::YColor* temp = color_;
  color_ = NULL;
  return temp;
}
inline void YSpecular::set_allocated_color(::y3d::YColor* color) {
  delete color_;
  color_ = color;
  if (color) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YSpecular.color)
}

// .y3d.YImage image = 3;
inline bool YSpecular::has_image() const {
  return this != internal_default_instance() && image_ != NULL;
}
inline void YSpecular::clear_image() {
  if (GetArenaNoVirtual() == NULL && image_ != NULL) delete image_;
  image_ = NULL;
}
inline const ::y3d::YImage& YSpecular::image() const {
  // @@protoc_insertion_point(field_get:y3d.YSpecular.image)
  return image_ != NULL ? *image_
                         : *::y3d::YImage::internal_default_instance();
}
inline ::y3d::YImage* YSpecular::mutable_image() {
  
  if (image_ == NULL) {
    image_ = new ::y3d::YImage;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YSpecular.image)
  return image_;
}
inline ::y3d::YImage* YSpecular::release_image() {
  // @@protoc_insertion_point(field_release:y3d.YSpecular.image)
  
  ::y3d::YImage* temp = image_;
  image_ = NULL;
  return temp;
}
inline void YSpecular::set_allocated_image(::y3d::YImage* image) {
  delete image_;
  image_ = image;
  if (image) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YSpecular.image)
}

// -------------------------------------------------------------------

// YAmbient

// string set_name = 1;
inline void YAmbient::clear_set_name() {
  set_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YAmbient::set_name() const {
  // @@protoc_insertion_point(field_get:y3d.YAmbient.set_name)
  return set_name_.GetNoArena();
}
inline void YAmbient::set_set_name(const ::std::string& value) {
  
  set_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YAmbient.set_name)
}
#if LANG_CXX11
inline void YAmbient::set_set_name(::std::string&& value) {
  
  set_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.YAmbient.set_name)
}
#endif
inline void YAmbient::set_set_name(const char* value) {
  
  set_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YAmbient.set_name)
}
inline void YAmbient::set_set_name(const char* value, size_t size) {
  
  set_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YAmbient.set_name)
}
inline ::std::string* YAmbient::mutable_set_name() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YAmbient.set_name)
  return set_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YAmbient::release_set_name() {
  // @@protoc_insertion_point(field_release:y3d.YAmbient.set_name)
  
  return set_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YAmbient::set_allocated_set_name(::std::string* set_name) {
  if (set_name != NULL) {
    
  } else {
    
  }
  set_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), set_name);
  // @@protoc_insertion_point(field_set_allocated:y3d.YAmbient.set_name)
}

// .y3d.YColor color = 2;
inline bool YAmbient::has_color() const {
  return this != internal_default_instance() && color_ != NULL;
}
inline void YAmbient::clear_color() {
  if (GetArenaNoVirtual() == NULL && color_ != NULL) delete color_;
  color_ = NULL;
}
inline const ::y3d::YColor& YAmbient::color() const {
  // @@protoc_insertion_point(field_get:y3d.YAmbient.color)
  return color_ != NULL ? *color_
                         : *::y3d::YColor::internal_default_instance();
}
inline ::y3d::YColor* YAmbient::mutable_color() {
  
  if (color_ == NULL) {
    color_ = new ::y3d::YColor;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YAmbient.color)
  return color_;
}
inline ::y3d::YColor* YAmbient::release_color() {
  // @@protoc_insertion_point(field_release:y3d.YAmbient.color)
  
  ::y3d::YColor* temp = color_;
  color_ = NULL;
  return temp;
}
inline void YAmbient::set_allocated_color(::y3d::YColor* color) {
  delete color_;
  color_ = color;
  if (color) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YAmbient.color)
}

// .y3d.YImage image = 3;
inline bool YAmbient::has_image() const {
  return this != internal_default_instance() && image_ != NULL;
}
inline void YAmbient::clear_image() {
  if (GetArenaNoVirtual() == NULL && image_ != NULL) delete image_;
  image_ = NULL;
}
inline const ::y3d::YImage& YAmbient::image() const {
  // @@protoc_insertion_point(field_get:y3d.YAmbient.image)
  return image_ != NULL ? *image_
                         : *::y3d::YImage::internal_default_instance();
}
inline ::y3d::YImage* YAmbient::mutable_image() {
  
  if (image_ == NULL) {
    image_ = new ::y3d::YImage;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YAmbient.image)
  return image_;
}
inline ::y3d::YImage* YAmbient::release_image() {
  // @@protoc_insertion_point(field_release:y3d.YAmbient.image)
  
  ::y3d::YImage* temp = image_;
  image_ = NULL;
  return temp;
}
inline void YAmbient::set_allocated_image(::y3d::YImage* image) {
  delete image_;
  image_ = image;
  if (image) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YAmbient.image)
}

// -------------------------------------------------------------------

// YEmissive

// string set_name = 1;
inline void YEmissive::clear_set_name() {
  set_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YEmissive::set_name() const {
  // @@protoc_insertion_point(field_get:y3d.YEmissive.set_name)
  return set_name_.GetNoArena();
}
inline void YEmissive::set_set_name(const ::std::string& value) {
  
  set_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YEmissive.set_name)
}
#if LANG_CXX11
inline void YEmissive::set_set_name(::std::string&& value) {
  
  set_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.YEmissive.set_name)
}
#endif
inline void YEmissive::set_set_name(const char* value) {
  
  set_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YEmissive.set_name)
}
inline void YEmissive::set_set_name(const char* value, size_t size) {
  
  set_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YEmissive.set_name)
}
inline ::std::string* YEmissive::mutable_set_name() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YEmissive.set_name)
  return set_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YEmissive::release_set_name() {
  // @@protoc_insertion_point(field_release:y3d.YEmissive.set_name)
  
  return set_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YEmissive::set_allocated_set_name(::std::string* set_name) {
  if (set_name != NULL) {
    
  } else {
    
  }
  set_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), set_name);
  // @@protoc_insertion_point(field_set_allocated:y3d.YEmissive.set_name)
}

// .y3d.YColor color = 2;
inline bool YEmissive::has_color() const {
  return this != internal_default_instance() && color_ != NULL;
}
inline void YEmissive::clear_color() {
  if (GetArenaNoVirtual() == NULL && color_ != NULL) delete color_;
  color_ = NULL;
}
inline const ::y3d::YColor& YEmissive::color() const {
  // @@protoc_insertion_point(field_get:y3d.YEmissive.color)
  return color_ != NULL ? *color_
                         : *::y3d::YColor::internal_default_instance();
}
inline ::y3d::YColor* YEmissive::mutable_color() {
  
  if (color_ == NULL) {
    color_ = new ::y3d::YColor;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YEmissive.color)
  return color_;
}
inline ::y3d::YColor* YEmissive::release_color() {
  // @@protoc_insertion_point(field_release:y3d.YEmissive.color)
  
  ::y3d::YColor* temp = color_;
  color_ = NULL;
  return temp;
}
inline void YEmissive::set_allocated_color(::y3d::YColor* color) {
  delete color_;
  color_ = color;
  if (color) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YEmissive.color)
}

// .y3d.YImage image = 3;
inline bool YEmissive::has_image() const {
  return this != internal_default_instance() && image_ != NULL;
}
inline void YEmissive::clear_image() {
  if (GetArenaNoVirtual() == NULL && image_ != NULL) delete image_;
  image_ = NULL;
}
inline const ::y3d::YImage& YEmissive::image() const {
  // @@protoc_insertion_point(field_get:y3d.YEmissive.image)
  return image_ != NULL ? *image_
                         : *::y3d::YImage::internal_default_instance();
}
inline ::y3d::YImage* YEmissive::mutable_image() {
  
  if (image_ == NULL) {
    image_ = new ::y3d::YImage;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YEmissive.image)
  return image_;
}
inline ::y3d::YImage* YEmissive::release_image() {
  // @@protoc_insertion_point(field_release:y3d.YEmissive.image)
  
  ::y3d::YImage* temp = image_;
  image_ = NULL;
  return temp;
}
inline void YEmissive::set_allocated_image(::y3d::YImage* image) {
  delete image_;
  image_ = image;
  if (image) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YEmissive.image)
}

// -------------------------------------------------------------------

// YMatPBR

// -------------------------------------------------------------------

// YMatMap

// .y3d.YImage image = 1;
inline bool YMatMap::has_image() const {
  return this != internal_default_instance() && image_ != NULL;
}
inline void YMatMap::clear_image() {
  if (GetArenaNoVirtual() == NULL && image_ != NULL) delete image_;
  image_ = NULL;
}
inline const ::y3d::YImage& YMatMap::image() const {
  // @@protoc_insertion_point(field_get:y3d.YMatMap.image)
  return image_ != NULL ? *image_
                         : *::y3d::YImage::internal_default_instance();
}
inline ::y3d::YImage* YMatMap::mutable_image() {
  
  if (image_ == NULL) {
    image_ = new ::y3d::YImage;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YMatMap.image)
  return image_;
}
inline ::y3d::YImage* YMatMap::release_image() {
  // @@protoc_insertion_point(field_release:y3d.YMatMap.image)
  
  ::y3d::YImage* temp = image_;
  image_ = NULL;
  return temp;
}
inline void YMatMap::set_allocated_image(::y3d::YImage* image) {
  delete image_;
  image_ = image;
  if (image) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YMatMap.image)
}

// float scale = 2;
inline void YMatMap::clear_scale() {
  scale_ = 0;
}
inline float YMatMap::scale() const {
  // @@protoc_insertion_point(field_get:y3d.YMatMap.scale)
  return scale_;
}
inline void YMatMap::set_scale(float value) {
  
  scale_ = value;
  // @@protoc_insertion_point(field_set:y3d.YMatMap.scale)
}

// string name = 3;
inline void YMatMap::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YMatMap::name() const {
  // @@protoc_insertion_point(field_get:y3d.YMatMap.name)
  return name_.GetNoArena();
}
inline void YMatMap::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YMatMap.name)
}
#if LANG_CXX11
inline void YMatMap::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.YMatMap.name)
}
#endif
inline void YMatMap::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YMatMap.name)
}
inline void YMatMap::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YMatMap.name)
}
inline ::std::string* YMatMap::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YMatMap.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YMatMap::release_name() {
  // @@protoc_insertion_point(field_release:y3d.YMatMap.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YMatMap::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:y3d.YMatMap.name)
}

// -------------------------------------------------------------------

// YBaseMap

// .y3d.YMatMap albedo = 1;
inline bool YBaseMap::has_albedo() const {
  return this != internal_default_instance() && albedo_ != NULL;
}
inline void YBaseMap::clear_albedo() {
  if (GetArenaNoVirtual() == NULL && albedo_ != NULL) delete albedo_;
  albedo_ = NULL;
}
inline const ::y3d::YMatMap& YBaseMap::albedo() const {
  // @@protoc_insertion_point(field_get:y3d.YBaseMap.albedo)
  return albedo_ != NULL ? *albedo_
                         : *::y3d::YMatMap::internal_default_instance();
}
inline ::y3d::YMatMap* YBaseMap::mutable_albedo() {
  
  if (albedo_ == NULL) {
    albedo_ = new ::y3d::YMatMap;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YBaseMap.albedo)
  return albedo_;
}
inline ::y3d::YMatMap* YBaseMap::release_albedo() {
  // @@protoc_insertion_point(field_release:y3d.YBaseMap.albedo)
  
  ::y3d::YMatMap* temp = albedo_;
  albedo_ = NULL;
  return temp;
}
inline void YBaseMap::set_allocated_albedo(::y3d::YMatMap* albedo) {
  delete albedo_;
  albedo_ = albedo;
  if (albedo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YBaseMap.albedo)
}

// .y3d.YMatMap bump = 2;
inline bool YBaseMap::has_bump() const {
  return this != internal_default_instance() && bump_ != NULL;
}
inline void YBaseMap::clear_bump() {
  if (GetArenaNoVirtual() == NULL && bump_ != NULL) delete bump_;
  bump_ = NULL;
}
inline const ::y3d::YMatMap& YBaseMap::bump() const {
  // @@protoc_insertion_point(field_get:y3d.YBaseMap.bump)
  return bump_ != NULL ? *bump_
                         : *::y3d::YMatMap::internal_default_instance();
}
inline ::y3d::YMatMap* YBaseMap::mutable_bump() {
  
  if (bump_ == NULL) {
    bump_ = new ::y3d::YMatMap;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YBaseMap.bump)
  return bump_;
}
inline ::y3d::YMatMap* YBaseMap::release_bump() {
  // @@protoc_insertion_point(field_release:y3d.YBaseMap.bump)
  
  ::y3d::YMatMap* temp = bump_;
  bump_ = NULL;
  return temp;
}
inline void YBaseMap::set_allocated_bump(::y3d::YMatMap* bump) {
  delete bump_;
  bump_ = bump;
  if (bump) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YBaseMap.bump)
}

// .y3d.YMatMap normal = 3;
inline bool YBaseMap::has_normal() const {
  return this != internal_default_instance() && normal_ != NULL;
}
inline void YBaseMap::clear_normal() {
  if (GetArenaNoVirtual() == NULL && normal_ != NULL) delete normal_;
  normal_ = NULL;
}
inline const ::y3d::YMatMap& YBaseMap::normal() const {
  // @@protoc_insertion_point(field_get:y3d.YBaseMap.normal)
  return normal_ != NULL ? *normal_
                         : *::y3d::YMatMap::internal_default_instance();
}
inline ::y3d::YMatMap* YBaseMap::mutable_normal() {
  
  if (normal_ == NULL) {
    normal_ = new ::y3d::YMatMap;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YBaseMap.normal)
  return normal_;
}
inline ::y3d::YMatMap* YBaseMap::release_normal() {
  // @@protoc_insertion_point(field_release:y3d.YBaseMap.normal)
  
  ::y3d::YMatMap* temp = normal_;
  normal_ = NULL;
  return temp;
}
inline void YBaseMap::set_allocated_normal(::y3d::YMatMap* normal) {
  delete normal_;
  normal_ = normal;
  if (normal) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YBaseMap.normal)
}

// .y3d.YMatMap ao = 4;
inline bool YBaseMap::has_ao() const {
  return this != internal_default_instance() && ao_ != NULL;
}
inline void YBaseMap::clear_ao() {
  if (GetArenaNoVirtual() == NULL && ao_ != NULL) delete ao_;
  ao_ = NULL;
}
inline const ::y3d::YMatMap& YBaseMap::ao() const {
  // @@protoc_insertion_point(field_get:y3d.YBaseMap.ao)
  return ao_ != NULL ? *ao_
                         : *::y3d::YMatMap::internal_default_instance();
}
inline ::y3d::YMatMap* YBaseMap::mutable_ao() {
  
  if (ao_ == NULL) {
    ao_ = new ::y3d::YMatMap;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YBaseMap.ao)
  return ao_;
}
inline ::y3d::YMatMap* YBaseMap::release_ao() {
  // @@protoc_insertion_point(field_release:y3d.YBaseMap.ao)
  
  ::y3d::YMatMap* temp = ao_;
  ao_ = NULL;
  return temp;
}
inline void YBaseMap::set_allocated_ao(::y3d::YMatMap* ao) {
  delete ao_;
  ao_ = ao;
  if (ao) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YBaseMap.ao)
}

// .y3d.YMatMap specular = 5;
inline bool YBaseMap::has_specular() const {
  return this != internal_default_instance() && specular_ != NULL;
}
inline void YBaseMap::clear_specular() {
  if (GetArenaNoVirtual() == NULL && specular_ != NULL) delete specular_;
  specular_ = NULL;
}
inline const ::y3d::YMatMap& YBaseMap::specular() const {
  // @@protoc_insertion_point(field_get:y3d.YBaseMap.specular)
  return specular_ != NULL ? *specular_
                         : *::y3d::YMatMap::internal_default_instance();
}
inline ::y3d::YMatMap* YBaseMap::mutable_specular() {
  
  if (specular_ == NULL) {
    specular_ = new ::y3d::YMatMap;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YBaseMap.specular)
  return specular_;
}
inline ::y3d::YMatMap* YBaseMap::release_specular() {
  // @@protoc_insertion_point(field_release:y3d.YBaseMap.specular)
  
  ::y3d::YMatMap* temp = specular_;
  specular_ = NULL;
  return temp;
}
inline void YBaseMap::set_allocated_specular(::y3d::YMatMap* specular) {
  delete specular_;
  specular_ = specular;
  if (specular) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YBaseMap.specular)
}

// .y3d.YMatMap displacement = 6;
inline bool YBaseMap::has_displacement() const {
  return this != internal_default_instance() && displacement_ != NULL;
}
inline void YBaseMap::clear_displacement() {
  if (GetArenaNoVirtual() == NULL && displacement_ != NULL) delete displacement_;
  displacement_ = NULL;
}
inline const ::y3d::YMatMap& YBaseMap::displacement() const {
  // @@protoc_insertion_point(field_get:y3d.YBaseMap.displacement)
  return displacement_ != NULL ? *displacement_
                         : *::y3d::YMatMap::internal_default_instance();
}
inline ::y3d::YMatMap* YBaseMap::mutable_displacement() {
  
  if (displacement_ == NULL) {
    displacement_ = new ::y3d::YMatMap;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YBaseMap.displacement)
  return displacement_;
}
inline ::y3d::YMatMap* YBaseMap::release_displacement() {
  // @@protoc_insertion_point(field_release:y3d.YBaseMap.displacement)
  
  ::y3d::YMatMap* temp = displacement_;
  displacement_ = NULL;
  return temp;
}
inline void YBaseMap::set_allocated_displacement(::y3d::YMatMap* displacement) {
  delete displacement_;
  displacement_ = displacement;
  if (displacement) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YBaseMap.displacement)
}

// .y3d.YMatMap transclucency = 79;
inline bool YBaseMap::has_transclucency() const {
  return this != internal_default_instance() && transclucency_ != NULL;
}
inline void YBaseMap::clear_transclucency() {
  if (GetArenaNoVirtual() == NULL && transclucency_ != NULL) delete transclucency_;
  transclucency_ = NULL;
}
inline const ::y3d::YMatMap& YBaseMap::transclucency() const {
  // @@protoc_insertion_point(field_get:y3d.YBaseMap.transclucency)
  return transclucency_ != NULL ? *transclucency_
                         : *::y3d::YMatMap::internal_default_instance();
}
inline ::y3d::YMatMap* YBaseMap::mutable_transclucency() {
  
  if (transclucency_ == NULL) {
    transclucency_ = new ::y3d::YMatMap;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YBaseMap.transclucency)
  return transclucency_;
}
inline ::y3d::YMatMap* YBaseMap::release_transclucency() {
  // @@protoc_insertion_point(field_release:y3d.YBaseMap.transclucency)
  
  ::y3d::YMatMap* temp = transclucency_;
  transclucency_ = NULL;
  return temp;
}
inline void YBaseMap::set_allocated_transclucency(::y3d::YMatMap* transclucency) {
  delete transclucency_;
  transclucency_ = transclucency;
  if (transclucency) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YBaseMap.transclucency)
}

// .y3d.YMatMap roughness = 8;
inline bool YBaseMap::has_roughness() const {
  return this != internal_default_instance() && roughness_ != NULL;
}
inline void YBaseMap::clear_roughness() {
  if (GetArenaNoVirtual() == NULL && roughness_ != NULL) delete roughness_;
  roughness_ = NULL;
}
inline const ::y3d::YMatMap& YBaseMap::roughness() const {
  // @@protoc_insertion_point(field_get:y3d.YBaseMap.roughness)
  return roughness_ != NULL ? *roughness_
                         : *::y3d::YMatMap::internal_default_instance();
}
inline ::y3d::YMatMap* YBaseMap::mutable_roughness() {
  
  if (roughness_ == NULL) {
    roughness_ = new ::y3d::YMatMap;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YBaseMap.roughness)
  return roughness_;
}
inline ::y3d::YMatMap* YBaseMap::release_roughness() {
  // @@protoc_insertion_point(field_release:y3d.YBaseMap.roughness)
  
  ::y3d::YMatMap* temp = roughness_;
  roughness_ = NULL;
  return temp;
}
inline void YBaseMap::set_allocated_roughness(::y3d::YMatMap* roughness) {
  delete roughness_;
  roughness_ = roughness;
  if (roughness) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YBaseMap.roughness)
}

// .y3d.YMatMap opactity = 9;
inline bool YBaseMap::has_opactity() const {
  return this != internal_default_instance() && opactity_ != NULL;
}
inline void YBaseMap::clear_opactity() {
  if (GetArenaNoVirtual() == NULL && opactity_ != NULL) delete opactity_;
  opactity_ = NULL;
}
inline const ::y3d::YMatMap& YBaseMap::opactity() const {
  // @@protoc_insertion_point(field_get:y3d.YBaseMap.opactity)
  return opactity_ != NULL ? *opactity_
                         : *::y3d::YMatMap::internal_default_instance();
}
inline ::y3d::YMatMap* YBaseMap::mutable_opactity() {
  
  if (opactity_ == NULL) {
    opactity_ = new ::y3d::YMatMap;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YBaseMap.opactity)
  return opactity_;
}
inline ::y3d::YMatMap* YBaseMap::release_opactity() {
  // @@protoc_insertion_point(field_release:y3d.YBaseMap.opactity)
  
  ::y3d::YMatMap* temp = opactity_;
  opactity_ = NULL;
  return temp;
}
inline void YBaseMap::set_allocated_opactity(::y3d::YMatMap* opactity) {
  delete opactity_;
  opactity_ = opactity;
  if (opactity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YBaseMap.opactity)
}

// -------------------------------------------------------------------

// YMatStandard

// uint32 id = 1;
inline void YMatStandard::clear_id() {
  id_ = 0u;
}
inline ::google::protobuf::uint32 YMatStandard::id() const {
  // @@protoc_insertion_point(field_get:y3d.YMatStandard.id)
  return id_;
}
inline void YMatStandard::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:y3d.YMatStandard.id)
}

// string name = 2;
inline void YMatStandard::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YMatStandard::name() const {
  // @@protoc_insertion_point(field_get:y3d.YMatStandard.name)
  return name_.GetNoArena();
}
inline void YMatStandard::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YMatStandard.name)
}
#if LANG_CXX11
inline void YMatStandard::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.YMatStandard.name)
}
#endif
inline void YMatStandard::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YMatStandard.name)
}
inline void YMatStandard::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YMatStandard.name)
}
inline ::std::string* YMatStandard::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YMatStandard.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YMatStandard::release_name() {
  // @@protoc_insertion_point(field_release:y3d.YMatStandard.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YMatStandard::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:y3d.YMatStandard.name)
}

// .y3d.YDiffuse diffuse = 3;
inline bool YMatStandard::has_diffuse() const {
  return this != internal_default_instance() && diffuse_ != NULL;
}
inline void YMatStandard::clear_diffuse() {
  if (GetArenaNoVirtual() == NULL && diffuse_ != NULL) delete diffuse_;
  diffuse_ = NULL;
}
inline const ::y3d::YDiffuse& YMatStandard::diffuse() const {
  // @@protoc_insertion_point(field_get:y3d.YMatStandard.diffuse)
  return diffuse_ != NULL ? *diffuse_
                         : *::y3d::YDiffuse::internal_default_instance();
}
inline ::y3d::YDiffuse* YMatStandard::mutable_diffuse() {
  
  if (diffuse_ == NULL) {
    diffuse_ = new ::y3d::YDiffuse;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YMatStandard.diffuse)
  return diffuse_;
}
inline ::y3d::YDiffuse* YMatStandard::release_diffuse() {
  // @@protoc_insertion_point(field_release:y3d.YMatStandard.diffuse)
  
  ::y3d::YDiffuse* temp = diffuse_;
  diffuse_ = NULL;
  return temp;
}
inline void YMatStandard::set_allocated_diffuse(::y3d::YDiffuse* diffuse) {
  delete diffuse_;
  diffuse_ = diffuse;
  if (diffuse) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YMatStandard.diffuse)
}

// .y3d.YSpecular specular = 4;
inline bool YMatStandard::has_specular() const {
  return this != internal_default_instance() && specular_ != NULL;
}
inline void YMatStandard::clear_specular() {
  if (GetArenaNoVirtual() == NULL && specular_ != NULL) delete specular_;
  specular_ = NULL;
}
inline const ::y3d::YSpecular& YMatStandard::specular() const {
  // @@protoc_insertion_point(field_get:y3d.YMatStandard.specular)
  return specular_ != NULL ? *specular_
                         : *::y3d::YSpecular::internal_default_instance();
}
inline ::y3d::YSpecular* YMatStandard::mutable_specular() {
  
  if (specular_ == NULL) {
    specular_ = new ::y3d::YSpecular;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YMatStandard.specular)
  return specular_;
}
inline ::y3d::YSpecular* YMatStandard::release_specular() {
  // @@protoc_insertion_point(field_release:y3d.YMatStandard.specular)
  
  ::y3d::YSpecular* temp = specular_;
  specular_ = NULL;
  return temp;
}
inline void YMatStandard::set_allocated_specular(::y3d::YSpecular* specular) {
  delete specular_;
  specular_ = specular;
  if (specular) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YMatStandard.specular)
}

// .y3d.YAmbient ambient = 5;
inline bool YMatStandard::has_ambient() const {
  return this != internal_default_instance() && ambient_ != NULL;
}
inline void YMatStandard::clear_ambient() {
  if (GetArenaNoVirtual() == NULL && ambient_ != NULL) delete ambient_;
  ambient_ = NULL;
}
inline const ::y3d::YAmbient& YMatStandard::ambient() const {
  // @@protoc_insertion_point(field_get:y3d.YMatStandard.ambient)
  return ambient_ != NULL ? *ambient_
                         : *::y3d::YAmbient::internal_default_instance();
}
inline ::y3d::YAmbient* YMatStandard::mutable_ambient() {
  
  if (ambient_ == NULL) {
    ambient_ = new ::y3d::YAmbient;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YMatStandard.ambient)
  return ambient_;
}
inline ::y3d::YAmbient* YMatStandard::release_ambient() {
  // @@protoc_insertion_point(field_release:y3d.YMatStandard.ambient)
  
  ::y3d::YAmbient* temp = ambient_;
  ambient_ = NULL;
  return temp;
}
inline void YMatStandard::set_allocated_ambient(::y3d::YAmbient* ambient) {
  delete ambient_;
  ambient_ = ambient;
  if (ambient) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YMatStandard.ambient)
}

// .y3d.YEmissive emissive = 6;
inline bool YMatStandard::has_emissive() const {
  return this != internal_default_instance() && emissive_ != NULL;
}
inline void YMatStandard::clear_emissive() {
  if (GetArenaNoVirtual() == NULL && emissive_ != NULL) delete emissive_;
  emissive_ = NULL;
}
inline const ::y3d::YEmissive& YMatStandard::emissive() const {
  // @@protoc_insertion_point(field_get:y3d.YMatStandard.emissive)
  return emissive_ != NULL ? *emissive_
                         : *::y3d::YEmissive::internal_default_instance();
}
inline ::y3d::YEmissive* YMatStandard::mutable_emissive() {
  
  if (emissive_ == NULL) {
    emissive_ = new ::y3d::YEmissive;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YMatStandard.emissive)
  return emissive_;
}
inline ::y3d::YEmissive* YMatStandard::release_emissive() {
  // @@protoc_insertion_point(field_release:y3d.YMatStandard.emissive)
  
  ::y3d::YEmissive* temp = emissive_;
  emissive_ = NULL;
  return temp;
}
inline void YMatStandard::set_allocated_emissive(::y3d::YEmissive* emissive) {
  delete emissive_;
  emissive_ = emissive;
  if (emissive) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YMatStandard.emissive)
}

// .y3d.YBaseMap map = 7;
inline bool YMatStandard::has_map() const {
  return this != internal_default_instance() && map_ != NULL;
}
inline void YMatStandard::clear_map() {
  if (GetArenaNoVirtual() == NULL && map_ != NULL) delete map_;
  map_ = NULL;
}
inline const ::y3d::YBaseMap& YMatStandard::map() const {
  // @@protoc_insertion_point(field_get:y3d.YMatStandard.map)
  return map_ != NULL ? *map_
                         : *::y3d::YBaseMap::internal_default_instance();
}
inline ::y3d::YBaseMap* YMatStandard::mutable_map() {
  
  if (map_ == NULL) {
    map_ = new ::y3d::YBaseMap;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YMatStandard.map)
  return map_;
}
inline ::y3d::YBaseMap* YMatStandard::release_map() {
  // @@protoc_insertion_point(field_release:y3d.YMatStandard.map)
  
  ::y3d::YBaseMap* temp = map_;
  map_ = NULL;
  return temp;
}
inline void YMatStandard::set_allocated_map(::y3d::YBaseMap* map) {
  delete map_;
  map_ = map;
  if (map) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YMatStandard.map)
}

// -------------------------------------------------------------------

// YMatVray

// .y3d.BRDF_Type brdf = 1;
inline void YMatVray::clear_brdf() {
  brdf_ = 0;
}
inline ::y3d::BRDF_Type YMatVray::brdf() const {
  // @@protoc_insertion_point(field_get:y3d.YMatVray.brdf)
  return static_cast< ::y3d::BRDF_Type >(brdf_);
}
inline void YMatVray::set_brdf(::y3d::BRDF_Type value) {
  
  brdf_ = value;
  // @@protoc_insertion_point(field_set:y3d.YMatVray.brdf)
}

// .y3d.YDiffuse diffuse = 2;
inline bool YMatVray::has_diffuse() const {
  return this != internal_default_instance() && diffuse_ != NULL;
}
inline void YMatVray::clear_diffuse() {
  if (GetArenaNoVirtual() == NULL && diffuse_ != NULL) delete diffuse_;
  diffuse_ = NULL;
}
inline const ::y3d::YDiffuse& YMatVray::diffuse() const {
  // @@protoc_insertion_point(field_get:y3d.YMatVray.diffuse)
  return diffuse_ != NULL ? *diffuse_
                         : *::y3d::YDiffuse::internal_default_instance();
}
inline ::y3d::YDiffuse* YMatVray::mutable_diffuse() {
  
  if (diffuse_ == NULL) {
    diffuse_ = new ::y3d::YDiffuse;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YMatVray.diffuse)
  return diffuse_;
}
inline ::y3d::YDiffuse* YMatVray::release_diffuse() {
  // @@protoc_insertion_point(field_release:y3d.YMatVray.diffuse)
  
  ::y3d::YDiffuse* temp = diffuse_;
  diffuse_ = NULL;
  return temp;
}
inline void YMatVray::set_allocated_diffuse(::y3d::YDiffuse* diffuse) {
  delete diffuse_;
  diffuse_ = diffuse;
  if (diffuse) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YMatVray.diffuse)
}

// .y3d.YBaseMap map = 3;
inline bool YMatVray::has_map() const {
  return this != internal_default_instance() && map_ != NULL;
}
inline void YMatVray::clear_map() {
  if (GetArenaNoVirtual() == NULL && map_ != NULL) delete map_;
  map_ = NULL;
}
inline const ::y3d::YBaseMap& YMatVray::map() const {
  // @@protoc_insertion_point(field_get:y3d.YMatVray.map)
  return map_ != NULL ? *map_
                         : *::y3d::YBaseMap::internal_default_instance();
}
inline ::y3d::YBaseMap* YMatVray::mutable_map() {
  
  if (map_ == NULL) {
    map_ = new ::y3d::YBaseMap;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YMatVray.map)
  return map_;
}
inline ::y3d::YBaseMap* YMatVray::release_map() {
  // @@protoc_insertion_point(field_release:y3d.YMatVray.map)
  
  ::y3d::YBaseMap* temp = map_;
  map_ = NULL;
  return temp;
}
inline void YMatVray::set_allocated_map(::y3d::YBaseMap* map) {
  delete map_;
  map_ = map;
  if (map) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YMatVray.map)
}

// -------------------------------------------------------------------

// YMat

// uint32 id = 1;
inline void YMat::clear_id() {
  id_ = 0u;
}
inline ::google::protobuf::uint32 YMat::id() const {
  // @@protoc_insertion_point(field_get:y3d.YMat.id)
  return id_;
}
inline void YMat::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:y3d.YMat.id)
}

// string name = 2;
inline void YMat::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YMat::name() const {
  // @@protoc_insertion_point(field_get:y3d.YMat.name)
  return name_.GetNoArena();
}
inline void YMat::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YMat.name)
}
#if LANG_CXX11
inline void YMat::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.YMat.name)
}
#endif
inline void YMat::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YMat.name)
}
inline void YMat::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YMat.name)
}
inline ::std::string* YMat::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YMat.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YMat::release_name() {
  // @@protoc_insertion_point(field_release:y3d.YMat.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YMat::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:y3d.YMat.name)
}

// .y3d.YMatStandard m_standard = 3;
inline bool YMat::has_m_standard() const {
  return this != internal_default_instance() && m_standard_ != NULL;
}
inline void YMat::clear_m_standard() {
  if (GetArenaNoVirtual() == NULL && m_standard_ != NULL) delete m_standard_;
  m_standard_ = NULL;
}
inline const ::y3d::YMatStandard& YMat::m_standard() const {
  // @@protoc_insertion_point(field_get:y3d.YMat.m_standard)
  return m_standard_ != NULL ? *m_standard_
                         : *::y3d::YMatStandard::internal_default_instance();
}
inline ::y3d::YMatStandard* YMat::mutable_m_standard() {
  
  if (m_standard_ == NULL) {
    m_standard_ = new ::y3d::YMatStandard;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YMat.m_standard)
  return m_standard_;
}
inline ::y3d::YMatStandard* YMat::release_m_standard() {
  // @@protoc_insertion_point(field_release:y3d.YMat.m_standard)
  
  ::y3d::YMatStandard* temp = m_standard_;
  m_standard_ = NULL;
  return temp;
}
inline void YMat::set_allocated_m_standard(::y3d::YMatStandard* m_standard) {
  delete m_standard_;
  m_standard_ = m_standard;
  if (m_standard) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YMat.m_standard)
}

// .y3d.YMatVray m_vray = 4;
inline bool YMat::has_m_vray() const {
  return this != internal_default_instance() && m_vray_ != NULL;
}
inline void YMat::clear_m_vray() {
  if (GetArenaNoVirtual() == NULL && m_vray_ != NULL) delete m_vray_;
  m_vray_ = NULL;
}
inline const ::y3d::YMatVray& YMat::m_vray() const {
  // @@protoc_insertion_point(field_get:y3d.YMat.m_vray)
  return m_vray_ != NULL ? *m_vray_
                         : *::y3d::YMatVray::internal_default_instance();
}
inline ::y3d::YMatVray* YMat::mutable_m_vray() {
  
  if (m_vray_ == NULL) {
    m_vray_ = new ::y3d::YMatVray;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YMat.m_vray)
  return m_vray_;
}
inline ::y3d::YMatVray* YMat::release_m_vray() {
  // @@protoc_insertion_point(field_release:y3d.YMat.m_vray)
  
  ::y3d::YMatVray* temp = m_vray_;
  m_vray_ = NULL;
  return temp;
}
inline void YMat::set_allocated_m_vray(::y3d::YMatVray* m_vray) {
  delete m_vray_;
  m_vray_ = m_vray;
  if (m_vray) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YMat.m_vray)
}

// .y3d.YMatPBR m_pbr = 5;
inline bool YMat::has_m_pbr() const {
  return this != internal_default_instance() && m_pbr_ != NULL;
}
inline void YMat::clear_m_pbr() {
  if (GetArenaNoVirtual() == NULL && m_pbr_ != NULL) delete m_pbr_;
  m_pbr_ = NULL;
}
inline const ::y3d::YMatPBR& YMat::m_pbr() const {
  // @@protoc_insertion_point(field_get:y3d.YMat.m_pbr)
  return m_pbr_ != NULL ? *m_pbr_
                         : *::y3d::YMatPBR::internal_default_instance();
}
inline ::y3d::YMatPBR* YMat::mutable_m_pbr() {
  
  if (m_pbr_ == NULL) {
    m_pbr_ = new ::y3d::YMatPBR;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YMat.m_pbr)
  return m_pbr_;
}
inline ::y3d::YMatPBR* YMat::release_m_pbr() {
  // @@protoc_insertion_point(field_release:y3d.YMat.m_pbr)
  
  ::y3d::YMatPBR* temp = m_pbr_;
  m_pbr_ = NULL;
  return temp;
}
inline void YMat::set_allocated_m_pbr(::y3d::YMatPBR* m_pbr) {
  delete m_pbr_;
  m_pbr_ = m_pbr;
  if (m_pbr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YMat.m_pbr)
}

// .y3d.YMultiMat m_multi = 6;
inline bool YMat::has_m_multi() const {
  return this != internal_default_instance() && m_multi_ != NULL;
}
inline void YMat::clear_m_multi() {
  if (GetArenaNoVirtual() == NULL && m_multi_ != NULL) delete m_multi_;
  m_multi_ = NULL;
}
inline const ::y3d::YMultiMat& YMat::m_multi() const {
  // @@protoc_insertion_point(field_get:y3d.YMat.m_multi)
  return m_multi_ != NULL ? *m_multi_
                         : *::y3d::YMultiMat::internal_default_instance();
}
inline ::y3d::YMultiMat* YMat::mutable_m_multi() {
  
  if (m_multi_ == NULL) {
    m_multi_ = new ::y3d::YMultiMat;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YMat.m_multi)
  return m_multi_;
}
inline ::y3d::YMultiMat* YMat::release_m_multi() {
  // @@protoc_insertion_point(field_release:y3d.YMat.m_multi)
  
  ::y3d::YMultiMat* temp = m_multi_;
  m_multi_ = NULL;
  return temp;
}
inline void YMat::set_allocated_m_multi(::y3d::YMultiMat* m_multi) {
  delete m_multi_;
  m_multi_ = m_multi;
  if (m_multi) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YMat.m_multi)
}

// -------------------------------------------------------------------

// YMultiMat

// .y3d.YDiffuse default_diffuse = 1;
inline bool YMultiMat::has_default_diffuse() const {
  return this != internal_default_instance() && default_diffuse_ != NULL;
}
inline void YMultiMat::clear_default_diffuse() {
  if (GetArenaNoVirtual() == NULL && default_diffuse_ != NULL) delete default_diffuse_;
  default_diffuse_ = NULL;
}
inline const ::y3d::YDiffuse& YMultiMat::default_diffuse() const {
  // @@protoc_insertion_point(field_get:y3d.YMultiMat.default_diffuse)
  return default_diffuse_ != NULL ? *default_diffuse_
                         : *::y3d::YDiffuse::internal_default_instance();
}
inline ::y3d::YDiffuse* YMultiMat::mutable_default_diffuse() {
  
  if (default_diffuse_ == NULL) {
    default_diffuse_ = new ::y3d::YDiffuse;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YMultiMat.default_diffuse)
  return default_diffuse_;
}
inline ::y3d::YDiffuse* YMultiMat::release_default_diffuse() {
  // @@protoc_insertion_point(field_release:y3d.YMultiMat.default_diffuse)
  
  ::y3d::YDiffuse* temp = default_diffuse_;
  default_diffuse_ = NULL;
  return temp;
}
inline void YMultiMat::set_allocated_default_diffuse(::y3d::YDiffuse* default_diffuse) {
  delete default_diffuse_;
  default_diffuse_ = default_diffuse;
  if (default_diffuse) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YMultiMat.default_diffuse)
}

// repeated .y3d.YMat materials = 2;
inline int YMultiMat::materials_size() const {
  return materials_.size();
}
inline void YMultiMat::clear_materials() {
  materials_.Clear();
}
inline const ::y3d::YMat& YMultiMat::materials(int index) const {
  // @@protoc_insertion_point(field_get:y3d.YMultiMat.materials)
  return materials_.Get(index);
}
inline ::y3d::YMat* YMultiMat::mutable_materials(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.YMultiMat.materials)
  return materials_.Mutable(index);
}
inline ::y3d::YMat* YMultiMat::add_materials() {
  // @@protoc_insertion_point(field_add:y3d.YMultiMat.materials)
  return materials_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::y3d::YMat >*
YMultiMat::mutable_materials() {
  // @@protoc_insertion_point(field_mutable_list:y3d.YMultiMat.materials)
  return &materials_;
}
inline const ::google::protobuf::RepeatedPtrField< ::y3d::YMat >&
YMultiMat::materials() const {
  // @@protoc_insertion_point(field_list:y3d.YMultiMat.materials)
  return materials_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace y3d

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::y3d::BRDF_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::y3d::BRDF_Type>() {
  return ::y3d::BRDF_Type_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ymat_2eproto__INCLUDED
