// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: y3d.proto

#ifndef PROTOBUF_y3d_2eproto__INCLUDED
#define PROTOBUF_y3d_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
#include <google/protobuf/timestamp.pb.h>
#include "xnormal.pb.h"
#include "ymat.pb.h"
// @@protoc_insertion_point(includes)
namespace google {
namespace protobuf {
class Any;
class AnyDefaultTypeInternal;
Y3D_EXPORT_MACRO extern AnyDefaultTypeInternal _Any_default_instance_;
class Timestamp;
class TimestampDefaultTypeInternal;
Y3D_EXPORT_MACRO extern TimestampDefaultTypeInternal _Timestamp_default_instance_;
}  // namespace protobuf
}  // namespace google
namespace xnormal {
class Settings;
class SettingsDefaultTypeInternal;
Y3D_EXPORT_MACRO extern SettingsDefaultTypeInternal _Settings_default_instance_;
class UnspecifiedType;
class UnspecifiedTypeDefaultTypeInternal;
Y3D_EXPORT_MACRO extern UnspecifiedTypeDefaultTypeInternal _UnspecifiedType_default_instance_;
class tDetail;
class tDetailDefaultTypeInternal;
Y3D_EXPORT_MACRO extern tDetailDefaultTypeInternal _tDetail_default_instance_;
class tGenerateMaps;
class tGenerateMapsDefaultTypeInternal;
Y3D_EXPORT_MACRO extern tGenerateMapsDefaultTypeInternal _tGenerateMaps_default_instance_;
class tHighPolyMesh;
class tHighPolyMeshDefaultTypeInternal;
Y3D_EXPORT_MACRO extern tHighPolyMeshDefaultTypeInternal _tHighPolyMesh_default_instance_;
class tHighPolyModel;
class tHighPolyModelDefaultTypeInternal;
Y3D_EXPORT_MACRO extern tHighPolyModelDefaultTypeInternal _tHighPolyModel_default_instance_;
class tLowPolyMesh;
class tLowPolyMeshDefaultTypeInternal;
Y3D_EXPORT_MACRO extern tLowPolyMeshDefaultTypeInternal _tLowPolyMesh_default_instance_;
class tLowPolyModel;
class tLowPolyModelDefaultTypeInternal;
Y3D_EXPORT_MACRO extern tLowPolyModelDefaultTypeInternal _tLowPolyModel_default_instance_;
class tMatrix;
class tMatrixDefaultTypeInternal;
Y3D_EXPORT_MACRO extern tMatrixDefaultTypeInternal _tMatrix_default_instance_;
class tRGB8;
class tRGB8DefaultTypeInternal;
Y3D_EXPORT_MACRO extern tRGB8DefaultTypeInternal _tRGB8_default_instance_;
class tVector3;
class tVector3DefaultTypeInternal;
Y3D_EXPORT_MACRO extern tVector3DefaultTypeInternal _tVector3_default_instance_;
class tViewer3D;
class tViewer3DDefaultTypeInternal;
Y3D_EXPORT_MACRO extern tViewer3DDefaultTypeInternal _tViewer3D_default_instance_;
}  // namespace xnormal
namespace y3d {
class AllWorkerParam;
class AllWorkerParamDefaultTypeInternal;
Y3D_EXPORT_MACRO extern AllWorkerParamDefaultTypeInternal _AllWorkerParam_default_instance_;
class BatchOptimizeParam;
class BatchOptimizeParamDefaultTypeInternal;
Y3D_EXPORT_MACRO extern BatchOptimizeParamDefaultTypeInternal _BatchOptimizeParam_default_instance_;
class BlenderUnwrap;
class BlenderUnwrapDefaultTypeInternal;
Y3D_EXPORT_MACRO extern BlenderUnwrapDefaultTypeInternal _BlenderUnwrap_default_instance_;
class EDelete;
class EDeleteDefaultTypeInternal;
Y3D_EXPORT_MACRO extern EDeleteDefaultTypeInternal _EDelete_default_instance_;
class EIsolate;
class EIsolateDefaultTypeInternal;
Y3D_EXPORT_MACRO extern EIsolateDefaultTypeInternal _EIsolate_default_instance_;
class ELowpoly;
class ELowpolyDefaultTypeInternal;
Y3D_EXPORT_MACRO extern ELowpolyDefaultTypeInternal _ELowpoly_default_instance_;
class EMove;
class EMoveDefaultTypeInternal;
Y3D_EXPORT_MACRO extern EMoveDefaultTypeInternal _EMove_default_instance_;
class ENone;
class ENoneDefaultTypeInternal;
Y3D_EXPORT_MACRO extern ENoneDefaultTypeInternal _ENone_default_instance_;
class ENormal;
class ENormalDefaultTypeInternal;
Y3D_EXPORT_MACRO extern ENormalDefaultTypeInternal _ENormal_default_instance_;
class EPacking;
class EPackingDefaultTypeInternal;
Y3D_EXPORT_MACRO extern EPackingDefaultTypeInternal _EPacking_default_instance_;
class ERotate;
class ERotateDefaultTypeInternal;
Y3D_EXPORT_MACRO extern ERotateDefaultTypeInternal _ERotate_default_instance_;
class ESelect;
class ESelectDefaultTypeInternal;
Y3D_EXPORT_MACRO extern ESelectDefaultTypeInternal _ESelect_default_instance_;
class ESelectMany;
class ESelectManyDefaultTypeInternal;
Y3D_EXPORT_MACRO extern ESelectManyDefaultTypeInternal _ESelectMany_default_instance_;
class EUnwrap;
class EUnwrapDefaultTypeInternal;
Y3D_EXPORT_MACRO extern EUnwrapDefaultTypeInternal _EUnwrap_default_instance_;
class EmptyParam;
class EmptyParamDefaultTypeInternal;
Y3D_EXPORT_MACRO extern EmptyParamDefaultTypeInternal _EmptyParam_default_instance_;
class FRangeItem;
class FRangeItemDefaultTypeInternal;
Y3D_EXPORT_MACRO extern FRangeItemDefaultTypeInternal _FRangeItem_default_instance_;
class FilterView;
class FilterViewDefaultTypeInternal;
Y3D_EXPORT_MACRO extern FilterViewDefaultTypeInternal _FilterView_default_instance_;
class IntParam;
class IntParamDefaultTypeInternal;
Y3D_EXPORT_MACRO extern IntParamDefaultTypeInternal _IntParam_default_instance_;
class LPoly3DMax;
class LPoly3DMaxDefaultTypeInternal;
Y3D_EXPORT_MACRO extern LPoly3DMaxDefaultTypeInternal _LPoly3DMax_default_instance_;
class LPolyBlender;
class LPolyBlenderDefaultTypeInternal;
Y3D_EXPORT_MACRO extern LPolyBlenderDefaultTypeInternal _LPolyBlender_default_instance_;
class LPolyMeshlab;
class LPolyMeshlabDefaultTypeInternal;
Y3D_EXPORT_MACRO extern LPolyMeshlabDefaultTypeInternal _LPolyMeshlab_default_instance_;
class Make4TestParam;
class Make4TestParamDefaultTypeInternal;
Y3D_EXPORT_MACRO extern Make4TestParamDefaultTypeInternal _Make4TestParam_default_instance_;
class MaxUnwrap;
class MaxUnwrapDefaultTypeInternal;
Y3D_EXPORT_MACRO extern MaxUnwrapDefaultTypeInternal _MaxUnwrap_default_instance_;
class NewProjectParam;
class NewProjectParamDefaultTypeInternal;
Y3D_EXPORT_MACRO extern NewProjectParamDefaultTypeInternal _NewProjectParam_default_instance_;
class Normal3DMax;
class Normal3DMaxDefaultTypeInternal;
Y3D_EXPORT_MACRO extern Normal3DMaxDefaultTypeInternal _Normal3DMax_default_instance_;
class OptimizeOptions;
class OptimizeOptionsDefaultTypeInternal;
Y3D_EXPORT_MACRO extern OptimizeOptionsDefaultTypeInternal _OptimizeOptions_default_instance_;
class OptimizeParam;
class OptimizeParamDefaultTypeInternal;
Y3D_EXPORT_MACRO extern OptimizeParamDefaultTypeInternal _OptimizeParam_default_instance_;
class PSetting;
class PSettingDefaultTypeInternal;
Y3D_EXPORT_MACRO extern PSettingDefaultTypeInternal _PSetting_default_instance_;
class Pack3DMax;
class Pack3DMaxDefaultTypeInternal;
Y3D_EXPORT_MACRO extern Pack3DMaxDefaultTypeInternal _Pack3DMax_default_instance_;
class PackRect;
class PackRectDefaultTypeInternal;
Y3D_EXPORT_MACRO extern PackRectDefaultTypeInternal _PackRect_default_instance_;
class ProjectInfo;
class ProjectInfoDefaultTypeInternal;
Y3D_EXPORT_MACRO extern ProjectInfoDefaultTypeInternal _ProjectInfo_default_instance_;
class RenameParam;
class RenameParamDefaultTypeInternal;
Y3D_EXPORT_MACRO extern RenameParamDefaultTypeInternal _RenameParam_default_instance_;
class ResponseEvent;
class ResponseEventDefaultTypeInternal;
Y3D_EXPORT_MACRO extern ResponseEventDefaultTypeInternal _ResponseEvent_default_instance_;
class ResponseNProject;
class ResponseNProjectDefaultTypeInternal;
Y3D_EXPORT_MACRO extern ResponseNProjectDefaultTypeInternal _ResponseNProject_default_instance_;
class ResultReply;
class ResultReplyDefaultTypeInternal;
Y3D_EXPORT_MACRO extern ResultReplyDefaultTypeInternal _ResultReply_default_instance_;
class SettingData;
class SettingDataDefaultTypeInternal;
Y3D_EXPORT_MACRO extern SettingDataDefaultTypeInternal _SettingData_default_instance_;
class StringParam;
class StringParamDefaultTypeInternal;
Y3D_EXPORT_MACRO extern StringParamDefaultTypeInternal _StringParam_default_instance_;
class TestOParam;
class TestOParamDefaultTypeInternal;
Y3D_EXPORT_MACRO extern TestOParamDefaultTypeInternal _TestOParam_default_instance_;
class TestObject;
class TestObjectDefaultTypeInternal;
Y3D_EXPORT_MACRO extern TestObjectDefaultTypeInternal _TestObject_default_instance_;
class TestParam;
class TestParamDefaultTypeInternal;
Y3D_EXPORT_MACRO extern TestParamDefaultTypeInternal _TestParam_default_instance_;
class WorkerApp;
class WorkerAppDefaultTypeInternal;
Y3D_EXPORT_MACRO extern WorkerAppDefaultTypeInternal _WorkerApp_default_instance_;
class WorkerParam;
class WorkerParamDefaultTypeInternal;
Y3D_EXPORT_MACRO extern WorkerParamDefaultTypeInternal _WorkerParam_default_instance_;
class YAmbient;
class YAmbientDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YAmbientDefaultTypeInternal _YAmbient_default_instance_;
class YArea;
class YAreaDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YAreaDefaultTypeInternal _YArea_default_instance_;
class YAreaList;
class YAreaListDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YAreaListDefaultTypeInternal _YAreaList_default_instance_;
class YBaseMap;
class YBaseMapDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YBaseMapDefaultTypeInternal _YBaseMap_default_instance_;
class YBox3;
class YBox3DefaultTypeInternal;
Y3D_EXPORT_MACRO extern YBox3DefaultTypeInternal _YBox3_default_instance_;
class YCamera;
class YCameraDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YCameraDefaultTypeInternal _YCamera_default_instance_;
class YColor;
class YColorDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YColorDefaultTypeInternal _YColor_default_instance_;
class YDiffuse;
class YDiffuseDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YDiffuseDefaultTypeInternal _YDiffuse_default_instance_;
class YEmissive;
class YEmissiveDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YEmissiveDefaultTypeInternal _YEmissive_default_instance_;
class YEvent;
class YEventDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YEventDefaultTypeInternal _YEvent_default_instance_;
class YGroup;
class YGroupDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YGroupDefaultTypeInternal _YGroup_default_instance_;
class YGroupVer;
class YGroupVerDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YGroupVerDefaultTypeInternal _YGroupVer_default_instance_;
class YImage;
class YImageDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YImageDefaultTypeInternal _YImage_default_instance_;
class YItemMesh;
class YItemMeshDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YItemMeshDefaultTypeInternal _YItemMesh_default_instance_;
class YJob;
class YJobDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YJobDefaultTypeInternal _YJob_default_instance_;
class YJobAction;
class YJobActionDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YJobActionDefaultTypeInternal _YJobAction_default_instance_;
class YJobList;
class YJobListDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YJobListDefaultTypeInternal _YJobList_default_instance_;
class YLayer;
class YLayerDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YLayerDefaultTypeInternal _YLayer_default_instance_;
class YLight;
class YLightDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YLightDefaultTypeInternal _YLight_default_instance_;
class YMainWorker;
class YMainWorkerDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YMainWorkerDefaultTypeInternal _YMainWorker_default_instance_;
class YMasterServer;
class YMasterServerDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YMasterServerDefaultTypeInternal _YMasterServer_default_instance_;
class YMat;
class YMatDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YMatDefaultTypeInternal _YMat_default_instance_;
class YMatMap;
class YMatMapDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YMatMapDefaultTypeInternal _YMatMap_default_instance_;
class YMatPBR;
class YMatPBRDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YMatPBRDefaultTypeInternal _YMatPBR_default_instance_;
class YMatStandard;
class YMatStandardDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YMatStandardDefaultTypeInternal _YMatStandard_default_instance_;
class YMatVray;
class YMatVrayDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YMatVrayDefaultTypeInternal _YMatVray_default_instance_;
class YMesh;
class YMeshDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YMeshDefaultTypeInternal _YMesh_default_instance_;
class YMultiMat;
class YMultiMatDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YMultiMatDefaultTypeInternal _YMultiMat_default_instance_;
class YObject;
class YObjectDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YObjectDefaultTypeInternal _YObject_default_instance_;
class YPoint3;
class YPoint3DefaultTypeInternal;
Y3D_EXPORT_MACRO extern YPoint3DefaultTypeInternal _YPoint3_default_instance_;
class YRGBColor;
class YRGBColorDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YRGBColorDefaultTypeInternal _YRGBColor_default_instance_;
class YResource;
class YResourceDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YResourceDefaultTypeInternal _YResource_default_instance_;
class YSpecular;
class YSpecularDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YSpecularDefaultTypeInternal _YSpecular_default_instance_;
class YSubWorker;
class YSubWorkerDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YSubWorkerDefaultTypeInternal _YSubWorker_default_instance_;
class YSystem;
class YSystemDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YSystemDefaultTypeInternal _YSystem_default_instance_;
class YWorker;
class YWorkerDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YWorkerDefaultTypeInternal _YWorker_default_instance_;
class YWorkerList;
class YWorkerListDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YWorkerListDefaultTypeInternal _YWorkerList_default_instance_;
class YWorkerRequest;
class YWorkerRequestDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YWorkerRequestDefaultTypeInternal _YWorkerRequest_default_instance_;
class YWorkerResponse;
class YWorkerResponseDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YWorkerResponseDefaultTypeInternal _YWorkerResponse_default_instance_;
}  // namespace y3d

namespace y3d {

namespace protobuf_y3d_2eproto {
// Internal implementation detail -- do not call these.
struct Y3D_EXPORT_MACRO TableStruct {
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void Y3D_EXPORT_MACRO AddDescriptors();
void Y3D_EXPORT_MACRO InitDefaults();
}  // namespace protobuf_y3d_2eproto

enum YResource_ResourceType {
  YResource_ResourceType_BINARY = 0,
  YResource_ResourceType_IMAGE = 1,
  YResource_ResourceType_FLATBUFFER = 2,
  YResource_ResourceType_PROTOBUF = 3,
  YResource_ResourceType_CAPNP = 4,
  YResource_ResourceType_YResource_ResourceType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  YResource_ResourceType_YResource_ResourceType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
Y3D_EXPORT_MACRO bool YResource_ResourceType_IsValid(int value);
const YResource_ResourceType YResource_ResourceType_ResourceType_MIN = YResource_ResourceType_BINARY;
const YResource_ResourceType YResource_ResourceType_ResourceType_MAX = YResource_ResourceType_CAPNP;
const int YResource_ResourceType_ResourceType_ARRAYSIZE = YResource_ResourceType_ResourceType_MAX + 1;

Y3D_EXPORT_MACRO const ::google::protobuf::EnumDescriptor* YResource_ResourceType_descriptor();
inline const ::std::string& YResource_ResourceType_Name(YResource_ResourceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    YResource_ResourceType_descriptor(), value);
}
inline bool YResource_ResourceType_Parse(
    const ::std::string& name, YResource_ResourceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<YResource_ResourceType>(
    YResource_ResourceType_descriptor(), name, value);
}
enum YMesh_MeshType {
  YMesh_MeshType_Unknown = 0,
  YMesh_MeshType_Editable_Mesh = 1,
  YMesh_MeshType_Editable_Poly = 2,
  YMesh_MeshType_Box = 3,
  YMesh_MeshType_Sphere = 4,
  YMesh_MeshType_GeoSphere = 5,
  YMesh_MeshType_Cylinder = 6,
  YMesh_MeshType_Tube = 7,
  YMesh_MeshType_Torus = 8,
  YMesh_MeshType_Pyramid = 9,
  YMesh_MeshType_Teapot = 10,
  YMesh_MeshType_Plane = 11,
  YMesh_MeshType_Target = 12,
  YMesh_MeshType_Cone = 13,
  YMesh_MeshType_YMesh_MeshType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  YMesh_MeshType_YMesh_MeshType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
Y3D_EXPORT_MACRO bool YMesh_MeshType_IsValid(int value);
const YMesh_MeshType YMesh_MeshType_MeshType_MIN = YMesh_MeshType_Unknown;
const YMesh_MeshType YMesh_MeshType_MeshType_MAX = YMesh_MeshType_Cone;
const int YMesh_MeshType_MeshType_ARRAYSIZE = YMesh_MeshType_MeshType_MAX + 1;

Y3D_EXPORT_MACRO const ::google::protobuf::EnumDescriptor* YMesh_MeshType_descriptor();
inline const ::std::string& YMesh_MeshType_Name(YMesh_MeshType value) {
  return ::google::protobuf::internal::NameOfEnum(
    YMesh_MeshType_descriptor(), value);
}
inline bool YMesh_MeshType_Parse(
    const ::std::string& name, YMesh_MeshType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<YMesh_MeshType>(
    YMesh_MeshType_descriptor(), name, value);
}
enum YMesh_XrefStatus {
  YMesh_XrefStatus_ORIGINAL = 0,
  YMesh_XrefStatus_XREF_HIGHT = 1,
  YMesh_XrefStatus_XREF_LOW = 2,
  YMesh_XrefStatus_XREF_LOW_DISPLAY = 3,
  YMesh_XrefStatus_BOX = 4,
  YMesh_XrefStatus_MERGED = 5,
  YMesh_XrefStatus_FINAL = 6,
  YMesh_XrefStatus_YMesh_XrefStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  YMesh_XrefStatus_YMesh_XrefStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
Y3D_EXPORT_MACRO bool YMesh_XrefStatus_IsValid(int value);
const YMesh_XrefStatus YMesh_XrefStatus_XrefStatus_MIN = YMesh_XrefStatus_ORIGINAL;
const YMesh_XrefStatus YMesh_XrefStatus_XrefStatus_MAX = YMesh_XrefStatus_FINAL;
const int YMesh_XrefStatus_XrefStatus_ARRAYSIZE = YMesh_XrefStatus_XrefStatus_MAX + 1;

Y3D_EXPORT_MACRO const ::google::protobuf::EnumDescriptor* YMesh_XrefStatus_descriptor();
inline const ::std::string& YMesh_XrefStatus_Name(YMesh_XrefStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    YMesh_XrefStatus_descriptor(), value);
}
inline bool YMesh_XrefStatus_Parse(
    const ::std::string& name, YMesh_XrefStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<YMesh_XrefStatus>(
    YMesh_XrefStatus_descriptor(), name, value);
}
enum LPoly3DMax_OpMode {
  LPoly3DMax_OpMode_CRUNCH_BORDERS = 0,
  LPoly3DMax_OpMode_PROTECT_BORDERS = 1,
  LPoly3DMax_OpMode_EXCLUDE_BORDERS = 2,
  LPoly3DMax_OpMode_LPoly3DMax_OpMode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LPoly3DMax_OpMode_LPoly3DMax_OpMode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
Y3D_EXPORT_MACRO bool LPoly3DMax_OpMode_IsValid(int value);
const LPoly3DMax_OpMode LPoly3DMax_OpMode_OpMode_MIN = LPoly3DMax_OpMode_CRUNCH_BORDERS;
const LPoly3DMax_OpMode LPoly3DMax_OpMode_OpMode_MAX = LPoly3DMax_OpMode_EXCLUDE_BORDERS;
const int LPoly3DMax_OpMode_OpMode_ARRAYSIZE = LPoly3DMax_OpMode_OpMode_MAX + 1;

Y3D_EXPORT_MACRO const ::google::protobuf::EnumDescriptor* LPoly3DMax_OpMode_descriptor();
inline const ::std::string& LPoly3DMax_OpMode_Name(LPoly3DMax_OpMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    LPoly3DMax_OpMode_descriptor(), value);
}
inline bool LPoly3DMax_OpMode_Parse(
    const ::std::string& name, LPoly3DMax_OpMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LPoly3DMax_OpMode>(
    LPoly3DMax_OpMode_descriptor(), name, value);
}
enum LPoly3DMax_NormalMode {
  LPoly3DMax_NormalMode_CRUNCH_NORMALS = 0,
  LPoly3DMax_NormalMode_PROTECT_NORMALS = 1,
  LPoly3DMax_NormalMode_EXCLUDE_NORMALS = 2,
  LPoly3DMax_NormalMode_LPoly3DMax_NormalMode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LPoly3DMax_NormalMode_LPoly3DMax_NormalMode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
Y3D_EXPORT_MACRO bool LPoly3DMax_NormalMode_IsValid(int value);
const LPoly3DMax_NormalMode LPoly3DMax_NormalMode_NormalMode_MIN = LPoly3DMax_NormalMode_CRUNCH_NORMALS;
const LPoly3DMax_NormalMode LPoly3DMax_NormalMode_NormalMode_MAX = LPoly3DMax_NormalMode_EXCLUDE_NORMALS;
const int LPoly3DMax_NormalMode_NormalMode_ARRAYSIZE = LPoly3DMax_NormalMode_NormalMode_MAX + 1;

Y3D_EXPORT_MACRO const ::google::protobuf::EnumDescriptor* LPoly3DMax_NormalMode_descriptor();
inline const ::std::string& LPoly3DMax_NormalMode_Name(LPoly3DMax_NormalMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    LPoly3DMax_NormalMode_descriptor(), value);
}
inline bool LPoly3DMax_NormalMode_Parse(
    const ::std::string& name, LPoly3DMax_NormalMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LPoly3DMax_NormalMode>(
    LPoly3DMax_NormalMode_descriptor(), name, value);
}
enum YWorker_ServingStatus {
  YWorker_ServingStatus_UNKNOWN = 0,
  YWorker_ServingStatus_SERVING = 1,
  YWorker_ServingStatus_NOT_SERVING = 2,
  YWorker_ServingStatus_NOT_CONNECT_MASTER = 3,
  YWorker_ServingStatus_NO_PROJECT = 4,
  YWorker_ServingStatus_YWorker_ServingStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  YWorker_ServingStatus_YWorker_ServingStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
Y3D_EXPORT_MACRO bool YWorker_ServingStatus_IsValid(int value);
const YWorker_ServingStatus YWorker_ServingStatus_ServingStatus_MIN = YWorker_ServingStatus_UNKNOWN;
const YWorker_ServingStatus YWorker_ServingStatus_ServingStatus_MAX = YWorker_ServingStatus_NO_PROJECT;
const int YWorker_ServingStatus_ServingStatus_ARRAYSIZE = YWorker_ServingStatus_ServingStatus_MAX + 1;

Y3D_EXPORT_MACRO const ::google::protobuf::EnumDescriptor* YWorker_ServingStatus_descriptor();
inline const ::std::string& YWorker_ServingStatus_Name(YWorker_ServingStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    YWorker_ServingStatus_descriptor(), value);
}
inline bool YWorker_ServingStatus_Parse(
    const ::std::string& name, YWorker_ServingStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<YWorker_ServingStatus>(
    YWorker_ServingStatus_descriptor(), name, value);
}
enum ObjectType {
  GEOMETRY = 0,
  LIGHT = 1,
  CAMERA = 2,
  SHAPE = 3,
  OTHER = 4,
  ObjectType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ObjectType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
Y3D_EXPORT_MACRO bool ObjectType_IsValid(int value);
const ObjectType ObjectType_MIN = GEOMETRY;
const ObjectType ObjectType_MAX = OTHER;
const int ObjectType_ARRAYSIZE = ObjectType_MAX + 1;

Y3D_EXPORT_MACRO const ::google::protobuf::EnumDescriptor* ObjectType_descriptor();
inline const ::std::string& ObjectType_Name(ObjectType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ObjectType_descriptor(), value);
}
inline bool ObjectType_Parse(
    const ::std::string& name, ObjectType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ObjectType>(
    ObjectType_descriptor(), name, value);
}
enum GVerType {
  NO_VER = 0,
  ORIGINAL = 1,
  IN_BAKE = 2,
  STANDARD = 3,
  GVerType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  GVerType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
Y3D_EXPORT_MACRO bool GVerType_IsValid(int value);
const GVerType GVerType_MIN = NO_VER;
const GVerType GVerType_MAX = STANDARD;
const int GVerType_ARRAYSIZE = GVerType_MAX + 1;

Y3D_EXPORT_MACRO const ::google::protobuf::EnumDescriptor* GVerType_descriptor();
inline const ::std::string& GVerType_Name(GVerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GVerType_descriptor(), value);
}
inline bool GVerType_Parse(
    const ::std::string& name, GVerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GVerType>(
    GVerType_descriptor(), name, value);
}
// ===================================================================

class Y3D_EXPORT_MACRO YPoint3 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YPoint3) */ {
 public:
  YPoint3();
  virtual ~YPoint3();

  YPoint3(const YPoint3& from);

  inline YPoint3& operator=(const YPoint3& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YPoint3& default_instance();

  static inline const YPoint3* internal_default_instance() {
    return reinterpret_cast<const YPoint3*>(
               &_YPoint3_default_instance_);
  }

  void Swap(YPoint3* other);

  // implements Message ----------------------------------------------

  inline YPoint3* New() const PROTOBUF_FINAL { return New(NULL); }

  YPoint3* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YPoint3& from);
  void MergeFrom(const YPoint3& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YPoint3* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // float z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:y3d.YPoint3)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  float z_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YBox3 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YBox3) */ {
 public:
  YBox3();
  virtual ~YBox3();

  YBox3(const YBox3& from);

  inline YBox3& operator=(const YBox3& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YBox3& default_instance();

  static inline const YBox3* internal_default_instance() {
    return reinterpret_cast<const YBox3*>(
               &_YBox3_default_instance_);
  }

  void Swap(YBox3* other);

  // implements Message ----------------------------------------------

  inline YBox3* New() const PROTOBUF_FINAL { return New(NULL); }

  YBox3* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YBox3& from);
  void MergeFrom(const YBox3& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YBox3* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .y3d.YPoint3 pmin = 1;
  bool has_pmin() const;
  void clear_pmin();
  static const int kPminFieldNumber = 1;
  const ::y3d::YPoint3& pmin() const;
  ::y3d::YPoint3* mutable_pmin();
  ::y3d::YPoint3* release_pmin();
  void set_allocated_pmin(::y3d::YPoint3* pmin);

  // .y3d.YPoint3 pmax = 2;
  bool has_pmax() const;
  void clear_pmax();
  static const int kPmaxFieldNumber = 2;
  const ::y3d::YPoint3& pmax() const;
  ::y3d::YPoint3* mutable_pmax();
  ::y3d::YPoint3* release_pmax();
  void set_allocated_pmax(::y3d::YPoint3* pmax);

  // @@protoc_insertion_point(class_scope:y3d.YBox3)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::y3d::YPoint3* pmin_;
  ::y3d::YPoint3* pmax_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YResource : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YResource) */ {
 public:
  YResource();
  virtual ~YResource();

  YResource(const YResource& from);

  inline YResource& operator=(const YResource& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YResource& default_instance();

  static inline const YResource* internal_default_instance() {
    return reinterpret_cast<const YResource*>(
               &_YResource_default_instance_);
  }

  void Swap(YResource* other);

  // implements Message ----------------------------------------------

  inline YResource* New() const PROTOBUF_FINAL { return New(NULL); }

  YResource* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YResource& from);
  void MergeFrom(const YResource& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YResource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef YResource_ResourceType ResourceType;
  static const ResourceType BINARY =
    YResource_ResourceType_BINARY;
  static const ResourceType IMAGE =
    YResource_ResourceType_IMAGE;
  static const ResourceType FLATBUFFER =
    YResource_ResourceType_FLATBUFFER;
  static const ResourceType PROTOBUF =
    YResource_ResourceType_PROTOBUF;
  static const ResourceType CAPNP =
    YResource_ResourceType_CAPNP;
  static inline bool ResourceType_IsValid(int value) {
    return YResource_ResourceType_IsValid(value);
  }
  static const ResourceType ResourceType_MIN =
    YResource_ResourceType_ResourceType_MIN;
  static const ResourceType ResourceType_MAX =
    YResource_ResourceType_ResourceType_MAX;
  static const int ResourceType_ARRAYSIZE =
    YResource_ResourceType_ResourceType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResourceType_descriptor() {
    return YResource_ResourceType_descriptor();
  }
  static inline const ::std::string& ResourceType_Name(ResourceType value) {
    return YResource_ResourceType_Name(value);
  }
  static inline bool ResourceType_Parse(const ::std::string& name,
      ResourceType* value) {
    return YResource_ResourceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string rid = 1;
  void clear_rid();
  static const int kRidFieldNumber = 1;
  const ::std::string& rid() const;
  void set_rid(const ::std::string& value);
  #if LANG_CXX11
  void set_rid(::std::string&& value);
  #endif
  void set_rid(const char* value);
  void set_rid(const char* value, size_t size);
  ::std::string* mutable_rid();
  ::std::string* release_rid();
  void set_allocated_rid(::std::string* rid);

  // string link = 3;
  void clear_link();
  static const int kLinkFieldNumber = 3;
  const ::std::string& link() const;
  void set_link(const ::std::string& value);
  #if LANG_CXX11
  void set_link(::std::string&& value);
  #endif
  void set_link(const char* value);
  void set_link(const char* value, size_t size);
  ::std::string* mutable_link();
  ::std::string* release_link();
  void set_allocated_link(::std::string* link);

  // .y3d.YResource.ResourceType rtype = 2;
  void clear_rtype();
  static const int kRtypeFieldNumber = 2;
  ::y3d::YResource_ResourceType rtype() const;
  void set_rtype(::y3d::YResource_ResourceType value);

  // @@protoc_insertion_point(class_scope:y3d.YResource)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr rid_;
  ::google::protobuf::internal::ArenaStringPtr link_;
  int rtype_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YLight : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YLight) */ {
 public:
  YLight();
  virtual ~YLight();

  YLight(const YLight& from);

  inline YLight& operator=(const YLight& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YLight& default_instance();

  static inline const YLight* internal_default_instance() {
    return reinterpret_cast<const YLight*>(
               &_YLight_default_instance_);
  }

  void Swap(YLight* other);

  // implements Message ----------------------------------------------

  inline YLight* New() const PROTOBUF_FINAL { return New(NULL); }

  YLight* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YLight& from);
  void MergeFrom(const YLight& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YLight* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float diffuse = 3;
  int diffuse_size() const;
  void clear_diffuse();
  static const int kDiffuseFieldNumber = 3;
  float diffuse(int index) const;
  void set_diffuse(int index, float value);
  void add_diffuse(float value);
  const ::google::protobuf::RepeatedField< float >&
      diffuse() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_diffuse();

  // repeated float specular = 4;
  int specular_size() const;
  void clear_specular();
  static const int kSpecularFieldNumber = 4;
  float specular(int index) const;
  void set_specular(int index, float value);
  void add_specular(float value);
  const ::google::protobuf::RepeatedField< float >&
      specular() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_specular();

  // repeated string excludedMeshesIds = 9;
  int excludedmeshesids_size() const;
  void clear_excludedmeshesids();
  static const int kExcludedMeshesIdsFieldNumber = 9;
  const ::std::string& excludedmeshesids(int index) const;
  ::std::string* mutable_excludedmeshesids(int index);
  void set_excludedmeshesids(int index, const ::std::string& value);
  void set_excludedmeshesids(int index, const char* value);
  void set_excludedmeshesids(int index, const char* value, size_t size);
  ::std::string* add_excludedmeshesids();
  void add_excludedmeshesids(const ::std::string& value);
  void add_excludedmeshesids(const char* value);
  void add_excludedmeshesids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& excludedmeshesids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_excludedmeshesids();

  // repeated string includedOnlyMeshesIds = 10;
  int includedonlymeshesids_size() const;
  void clear_includedonlymeshesids();
  static const int kIncludedOnlyMeshesIdsFieldNumber = 10;
  const ::std::string& includedonlymeshesids(int index) const;
  ::std::string* mutable_includedonlymeshesids(int index);
  void set_includedonlymeshesids(int index, const ::std::string& value);
  void set_includedonlymeshesids(int index, const char* value);
  void set_includedonlymeshesids(int index, const char* value, size_t size);
  ::std::string* add_includedonlymeshesids();
  void add_includedonlymeshesids(const ::std::string& value);
  void add_includedonlymeshesids(const char* value);
  void add_includedonlymeshesids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& includedonlymeshesids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_includedonlymeshesids();

  // float intensity = 5;
  void clear_intensity();
  static const int kIntensityFieldNumber = 5;
  float intensity() const;
  void set_intensity(float value);

  // float range = 6;
  void clear_range();
  static const int kRangeFieldNumber = 6;
  float range() const;
  void set_range(float value);

  // float angle = 7;
  void clear_angle();
  static const int kAngleFieldNumber = 7;
  float angle() const;
  void set_angle(float value);

  // float exponent = 8;
  void clear_exponent();
  static const int kExponentFieldNumber = 8;
  float exponent() const;
  void set_exponent(float value);

  // @@protoc_insertion_point(class_scope:y3d.YLight)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > diffuse_;
  mutable int _diffuse_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > specular_;
  mutable int _specular_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> excludedmeshesids_;
  ::google::protobuf::RepeatedPtrField< ::std::string> includedonlymeshesids_;
  float intensity_;
  float range_;
  float angle_;
  float exponent_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YCamera : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YCamera) */ {
 public:
  YCamera();
  virtual ~YCamera();

  YCamera(const YCamera& from);

  inline YCamera& operator=(const YCamera& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YCamera& default_instance();

  static inline const YCamera* internal_default_instance() {
    return reinterpret_cast<const YCamera*>(
               &_YCamera_default_instance_);
  }

  void Swap(YCamera* other);

  // implements Message ----------------------------------------------

  inline YCamera* New() const PROTOBUF_FINAL { return New(NULL); }

  YCamera* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YCamera& from);
  void MergeFrom(const YCamera& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YCamera* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float rotation = 3;
  int rotation_size() const;
  void clear_rotation();
  static const int kRotationFieldNumber = 3;
  float rotation(int index) const;
  void set_rotation(int index, float value);
  void add_rotation(float value);
  const ::google::protobuf::RepeatedField< float >&
      rotation() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_rotation();

  // repeated float target = 4;
  int target_size() const;
  void clear_target();
  static const int kTargetFieldNumber = 4;
  float target(int index) const;
  void set_target(int index, float value);
  void add_target(float value);
  const ::google::protobuf::RepeatedField< float >&
      target() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_target();

  // float fov = 5;
  void clear_fov();
  static const int kFovFieldNumber = 5;
  float fov() const;
  void set_fov(float value);

  // @@protoc_insertion_point(class_scope:y3d.YCamera)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > rotation_;
  mutable int _rotation_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > target_;
  mutable int _target_cached_byte_size_;
  float fov_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YMesh : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YMesh) */ {
 public:
  YMesh();
  virtual ~YMesh();

  YMesh(const YMesh& from);

  inline YMesh& operator=(const YMesh& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YMesh& default_instance();

  static inline const YMesh* internal_default_instance() {
    return reinterpret_cast<const YMesh*>(
               &_YMesh_default_instance_);
  }

  void Swap(YMesh* other);

  // implements Message ----------------------------------------------

  inline YMesh* New() const PROTOBUF_FINAL { return New(NULL); }

  YMesh* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YMesh& from);
  void MergeFrom(const YMesh& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YMesh* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef YMesh_MeshType MeshType;
  static const MeshType Unknown =
    YMesh_MeshType_Unknown;
  static const MeshType Editable_Mesh =
    YMesh_MeshType_Editable_Mesh;
  static const MeshType Editable_Poly =
    YMesh_MeshType_Editable_Poly;
  static const MeshType Box =
    YMesh_MeshType_Box;
  static const MeshType Sphere =
    YMesh_MeshType_Sphere;
  static const MeshType GeoSphere =
    YMesh_MeshType_GeoSphere;
  static const MeshType Cylinder =
    YMesh_MeshType_Cylinder;
  static const MeshType Tube =
    YMesh_MeshType_Tube;
  static const MeshType Torus =
    YMesh_MeshType_Torus;
  static const MeshType Pyramid =
    YMesh_MeshType_Pyramid;
  static const MeshType Teapot =
    YMesh_MeshType_Teapot;
  static const MeshType Plane =
    YMesh_MeshType_Plane;
  static const MeshType Target =
    YMesh_MeshType_Target;
  static const MeshType Cone =
    YMesh_MeshType_Cone;
  static inline bool MeshType_IsValid(int value) {
    return YMesh_MeshType_IsValid(value);
  }
  static const MeshType MeshType_MIN =
    YMesh_MeshType_MeshType_MIN;
  static const MeshType MeshType_MAX =
    YMesh_MeshType_MeshType_MAX;
  static const int MeshType_ARRAYSIZE =
    YMesh_MeshType_MeshType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MeshType_descriptor() {
    return YMesh_MeshType_descriptor();
  }
  static inline const ::std::string& MeshType_Name(MeshType value) {
    return YMesh_MeshType_Name(value);
  }
  static inline bool MeshType_Parse(const ::std::string& name,
      MeshType* value) {
    return YMesh_MeshType_Parse(name, value);
  }

  typedef YMesh_XrefStatus XrefStatus;
  static const XrefStatus ORIGINAL =
    YMesh_XrefStatus_ORIGINAL;
  static const XrefStatus XREF_HIGHT =
    YMesh_XrefStatus_XREF_HIGHT;
  static const XrefStatus XREF_LOW =
    YMesh_XrefStatus_XREF_LOW;
  static const XrefStatus XREF_LOW_DISPLAY =
    YMesh_XrefStatus_XREF_LOW_DISPLAY;
  static const XrefStatus BOX =
    YMesh_XrefStatus_BOX;
  static const XrefStatus MERGED =
    YMesh_XrefStatus_MERGED;
  static const XrefStatus FINAL =
    YMesh_XrefStatus_FINAL;
  static inline bool XrefStatus_IsValid(int value) {
    return YMesh_XrefStatus_IsValid(value);
  }
  static const XrefStatus XrefStatus_MIN =
    YMesh_XrefStatus_XrefStatus_MIN;
  static const XrefStatus XrefStatus_MAX =
    YMesh_XrefStatus_XrefStatus_MAX;
  static const int XrefStatus_ARRAYSIZE =
    YMesh_XrefStatus_XrefStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  XrefStatus_descriptor() {
    return YMesh_XrefStatus_descriptor();
  }
  static inline const ::std::string& XrefStatus_Name(XrefStatus value) {
    return YMesh_XrefStatus_Name(value);
  }
  static inline bool XrefStatus_Parse(const ::std::string& name,
      XrefStatus* value) {
    return YMesh_XrefStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string vername = 7;
  void clear_vername();
  static const int kVernameFieldNumber = 7;
  const ::std::string& vername() const;
  void set_vername(const ::std::string& value);
  #if LANG_CXX11
  void set_vername(::std::string&& value);
  #endif
  void set_vername(const char* value);
  void set_vername(const char* value, size_t size);
  ::std::string* mutable_vername();
  ::std::string* release_vername();
  void set_allocated_vername(::std::string* vername);

  // .y3d.YBox3 bbox = 2;
  bool has_bbox() const;
  void clear_bbox();
  static const int kBboxFieldNumber = 2;
  const ::y3d::YBox3& bbox() const;
  ::y3d::YBox3* mutable_bbox();
  ::y3d::YBox3* release_bbox();
  void set_allocated_bbox(::y3d::YBox3* bbox);

  // .y3d.YResource res = 3;
  bool has_res() const;
  void clear_res();
  static const int kResFieldNumber = 3;
  const ::y3d::YResource& res() const;
  ::y3d::YResource* mutable_res();
  ::y3d::YResource* release_res();
  void set_allocated_res(::y3d::YResource* res);

  // int32 num_faces = 1;
  void clear_num_faces();
  static const int kNumFacesFieldNumber = 1;
  ::google::protobuf::int32 num_faces() const;
  void set_num_faces(::google::protobuf::int32 value);

  // .y3d.YMesh.XrefStatus xstatus = 5;
  void clear_xstatus();
  static const int kXstatusFieldNumber = 5;
  ::y3d::YMesh_XrefStatus xstatus() const;
  void set_xstatus(::y3d::YMesh_XrefStatus value);

  // .y3d.YMesh.MeshType mtype = 6;
  void clear_mtype();
  static const int kMtypeFieldNumber = 6;
  ::y3d::YMesh_MeshType mtype() const;
  void set_mtype(::y3d::YMesh_MeshType value);

  // @@protoc_insertion_point(class_scope:y3d.YMesh)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr vername_;
  ::y3d::YBox3* bbox_;
  ::y3d::YResource* res_;
  ::google::protobuf::int32 num_faces_;
  int xstatus_;
  int mtype_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------


// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YObject : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YObject) */ {
 public:
  YObject();
  virtual ~YObject();

  YObject(const YObject& from);

  inline YObject& operator=(const YObject& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YObject& default_instance();

  enum DataCase {
    kLight = 10,
    kCamera = 11,
    kMesh = 12,
    DATA_NOT_SET = 0,
  };

  static inline const YObject* internal_default_instance() {
    return reinterpret_cast<const YObject*>(
               &_YObject_default_instance_);
  }

  void Swap(YObject* other);

  // implements Message ----------------------------------------------

  inline YObject* New() const PROTOBUF_FINAL { return New(NULL); }

  YObject* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YObject& from);
  void MergeFrom(const YObject& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YObject* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .google.protobuf.Any> extra = 5;
  int extra_size() const;
  void clear_extra();
  static const int kExtraFieldNumber = 5;
  const ::google::protobuf::Map< ::std::string, ::google::protobuf::Any >&
      extra() const;
  ::google::protobuf::Map< ::std::string, ::google::protobuf::Any >*
      mutable_extra();

  // repeated string tags = 7;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 7;
  const ::std::string& tags(int index) const;
  ::std::string* mutable_tags(int index);
  void set_tags(int index, const ::std::string& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  ::std::string* add_tags();
  void add_tags(const ::std::string& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& tags() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tags();

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .y3d.YPoint3 pos = 3;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 3;
  const ::y3d::YPoint3& pos() const;
  ::y3d::YPoint3* mutable_pos();
  ::y3d::YPoint3* release_pos();
  void set_allocated_pos(::y3d::YPoint3* pos);

  // .y3d.TestObject ver_obj = 13;
  bool has_ver_obj() const;
  void clear_ver_obj();
  static const int kVerObjFieldNumber = 13;
  const ::y3d::TestObject& ver_obj() const;
  ::y3d::TestObject* mutable_ver_obj();
  ::y3d::TestObject* release_ver_obj();
  void set_allocated_ver_obj(::y3d::TestObject* ver_obj);

  // .y3d.ObjectType otype = 6;
  void clear_otype();
  static const int kOtypeFieldNumber = 6;
  ::y3d::ObjectType otype() const;
  void set_otype(::y3d::ObjectType value);

  // int32 cate_id = 8;
  void clear_cate_id();
  static const int kCateIdFieldNumber = 8;
  ::google::protobuf::int32 cate_id() const;
  void set_cate_id(::google::protobuf::int32 value);

  // .y3d.YLight light = 10;
  bool has_light() const;
  void clear_light();
  static const int kLightFieldNumber = 10;
  const ::y3d::YLight& light() const;
  ::y3d::YLight* mutable_light();
  ::y3d::YLight* release_light();
  void set_allocated_light(::y3d::YLight* light);

  // .y3d.YCamera camera = 11;
  bool has_camera() const;
  void clear_camera();
  static const int kCameraFieldNumber = 11;
  const ::y3d::YCamera& camera() const;
  ::y3d::YCamera* mutable_camera();
  ::y3d::YCamera* release_camera();
  void set_allocated_camera(::y3d::YCamera* camera);

  // .y3d.YMesh mesh = 12;
  bool has_mesh() const;
  void clear_mesh();
  static const int kMeshFieldNumber = 12;
  const ::y3d::YMesh& mesh() const;
  ::y3d::YMesh* mutable_mesh();
  ::y3d::YMesh* release_mesh();
  void set_allocated_mesh(::y3d::YMesh* mesh);

  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:y3d.YObject)
 private:
  void set_has_light();
  void set_has_camera();
  void set_has_mesh();

  inline bool has_data() const;
  void clear_data();
  inline void clear_has_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::google::protobuf::Any,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 >
      YObject_ExtraEntry;
  ::google::protobuf::internal::MapField<
      ::std::string, ::google::protobuf::Any,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > extra_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tags_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::y3d::YPoint3* pos_;
  ::y3d::TestObject* ver_obj_;
  int otype_;
  ::google::protobuf::int32 cate_id_;
  union DataUnion {
    DataUnion() {}
    ::y3d::YLight* light_;
    ::y3d::YCamera* camera_;
    ::y3d::YMesh* mesh_;
  } data_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------


// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YArea : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YArea) */ {
 public:
  YArea();
  virtual ~YArea();

  YArea(const YArea& from);

  inline YArea& operator=(const YArea& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YArea& default_instance();

  static inline const YArea* internal_default_instance() {
    return reinterpret_cast<const YArea*>(
               &_YArea_default_instance_);
  }

  void Swap(YArea* other);

  // implements Message ----------------------------------------------

  inline YArea* New() const PROTOBUF_FINAL { return New(NULL); }

  YArea* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YArea& from);
  void MergeFrom(const YArea& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YArea* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // repeated .y3d.YGroup groups = 2;
  int groups_size() const;
  void clear_groups();
  static const int kGroupsFieldNumber = 2;
  const ::y3d::YGroup& groups(int index) const;
  ::y3d::YGroup* mutable_groups(int index);
  ::y3d::YGroup* add_groups();
  ::google::protobuf::RepeatedPtrField< ::y3d::YGroup >*
      mutable_groups();
  const ::google::protobuf::RepeatedPtrField< ::y3d::YGroup >&
      groups() const;

  // repeated .y3d.YObject objs = 3;
  int objs_size() const;
  void clear_objs();
  static const int kObjsFieldNumber = 3;
  const ::y3d::YObject& objs(int index) const;
  ::y3d::YObject* mutable_objs(int index);
  ::y3d::YObject* add_objs();
  ::google::protobuf::RepeatedPtrField< ::y3d::YObject >*
      mutable_objs();
  const ::google::protobuf::RepeatedPtrField< ::y3d::YObject >&
      objs() const;

  // map<string, .y3d.YGroupVer> gvers = 6;
  int gvers_size() const;
  void clear_gvers();
  static const int kGversFieldNumber = 6;
  const ::google::protobuf::Map< ::std::string, ::y3d::YGroupVer >&
      gvers() const;
  ::google::protobuf::Map< ::std::string, ::y3d::YGroupVer >*
      mutable_gvers();

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:y3d.YArea)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::y3d::YGroup > groups_;
  ::google::protobuf::RepeatedPtrField< ::y3d::YObject > objs_;
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::y3d::YGroupVer,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 >
      YArea_GversEntry;
  ::google::protobuf::internal::MapField<
      ::std::string, ::y3d::YGroupVer,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > gvers_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YAreaList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YAreaList) */ {
 public:
  YAreaList();
  virtual ~YAreaList();

  YAreaList(const YAreaList& from);

  inline YAreaList& operator=(const YAreaList& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YAreaList& default_instance();

  static inline const YAreaList* internal_default_instance() {
    return reinterpret_cast<const YAreaList*>(
               &_YAreaList_default_instance_);
  }

  void Swap(YAreaList* other);

  // implements Message ----------------------------------------------

  inline YAreaList* New() const PROTOBUF_FINAL { return New(NULL); }

  YAreaList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YAreaList& from);
  void MergeFrom(const YAreaList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YAreaList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .y3d.YArea areas = 1;
  int areas_size() const;
  void clear_areas();
  static const int kAreasFieldNumber = 1;
  const ::y3d::YArea& areas(int index) const;
  ::y3d::YArea* mutable_areas(int index);
  ::y3d::YArea* add_areas();
  ::google::protobuf::RepeatedPtrField< ::y3d::YArea >*
      mutable_areas();
  const ::google::protobuf::RepeatedPtrField< ::y3d::YArea >&
      areas() const;

  // @@protoc_insertion_point(class_scope:y3d.YAreaList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::y3d::YArea > areas_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YLayer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YLayer) */ {
 public:
  YLayer();
  virtual ~YLayer();

  YLayer(const YLayer& from);

  inline YLayer& operator=(const YLayer& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YLayer& default_instance();

  static inline const YLayer* internal_default_instance() {
    return reinterpret_cast<const YLayer*>(
               &_YLayer_default_instance_);
  }

  void Swap(YLayer* other);

  // implements Message ----------------------------------------------

  inline YLayer* New() const PROTOBUF_FINAL { return New(NULL); }

  YLayer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YLayer& from);
  void MergeFrom(const YLayer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YLayer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .y3d.YGroup groups = 2;
  int groups_size() const;
  void clear_groups();
  static const int kGroupsFieldNumber = 2;
  const ::y3d::YGroup& groups(int index) const;
  ::y3d::YGroup* mutable_groups(int index);
  ::y3d::YGroup* add_groups();
  ::google::protobuf::RepeatedPtrField< ::y3d::YGroup >*
      mutable_groups();
  const ::google::protobuf::RepeatedPtrField< ::y3d::YGroup >&
      groups() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:y3d.YLayer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::y3d::YGroup > groups_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YGroup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YGroup) */ {
 public:
  YGroup();
  virtual ~YGroup();

  YGroup(const YGroup& from);

  inline YGroup& operator=(const YGroup& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YGroup& default_instance();

  static inline const YGroup* internal_default_instance() {
    return reinterpret_cast<const YGroup*>(
               &_YGroup_default_instance_);
  }

  void Swap(YGroup* other);

  // implements Message ----------------------------------------------

  inline YGroup* New() const PROTOBUF_FINAL { return New(NULL); }

  YGroup* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YGroup& from);
  void MergeFrom(const YGroup& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YGroup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .y3d.YObject objs = 2;
  int objs_size() const;
  void clear_objs();
  static const int kObjsFieldNumber = 2;
  const ::y3d::YObject& objs(int index) const;
  ::y3d::YObject* mutable_objs(int index);
  ::y3d::YObject* add_objs();
  ::google::protobuf::RepeatedPtrField< ::y3d::YObject >*
      mutable_objs();
  const ::google::protobuf::RepeatedPtrField< ::y3d::YObject >&
      objs() const;

  // repeated .y3d.YGroup children = 3;
  int children_size() const;
  void clear_children();
  static const int kChildrenFieldNumber = 3;
  const ::y3d::YGroup& children(int index) const;
  ::y3d::YGroup* mutable_children(int index);
  ::y3d::YGroup* add_children();
  ::google::protobuf::RepeatedPtrField< ::y3d::YGroup >*
      mutable_children();
  const ::google::protobuf::RepeatedPtrField< ::y3d::YGroup >&
      children() const;

  // repeated string xref = 5;
  int xref_size() const;
  void clear_xref();
  static const int kXrefFieldNumber = 5;
  const ::std::string& xref(int index) const;
  ::std::string* mutable_xref(int index);
  void set_xref(int index, const ::std::string& value);
  void set_xref(int index, const char* value);
  void set_xref(int index, const char* value, size_t size);
  ::std::string* add_xref();
  void add_xref(const ::std::string& value);
  void add_xref(const char* value);
  void add_xref(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& xref() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_xref();

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .y3d.GVerType gv_type = 4;
  void clear_gv_type();
  static const int kGvTypeFieldNumber = 4;
  ::y3d::GVerType gv_type() const;
  void set_gv_type(::y3d::GVerType value);

  // @@protoc_insertion_point(class_scope:y3d.YGroup)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::y3d::YObject > objs_;
  ::google::protobuf::RepeatedPtrField< ::y3d::YGroup > children_;
  ::google::protobuf::RepeatedPtrField< ::std::string> xref_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  int gv_type_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YGroupVer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YGroupVer) */ {
 public:
  YGroupVer();
  virtual ~YGroupVer();

  YGroupVer(const YGroupVer& from);

  inline YGroupVer& operator=(const YGroupVer& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YGroupVer& default_instance();

  static inline const YGroupVer* internal_default_instance() {
    return reinterpret_cast<const YGroupVer*>(
               &_YGroupVer_default_instance_);
  }

  void Swap(YGroupVer* other);

  // implements Message ----------------------------------------------

  inline YGroupVer* New() const PROTOBUF_FINAL { return New(NULL); }

  YGroupVer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YGroupVer& from);
  void MergeFrom(const YGroupVer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YGroupVer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string vname = 1;
  void clear_vname();
  static const int kVnameFieldNumber = 1;
  const ::std::string& vname() const;
  void set_vname(const ::std::string& value);
  #if LANG_CXX11
  void set_vname(::std::string&& value);
  #endif
  void set_vname(const char* value);
  void set_vname(const char* value, size_t size);
  ::std::string* mutable_vname();
  ::std::string* release_vname();
  void set_allocated_vname(::std::string* vname);

  // .y3d.YGroup groupData = 2;
  bool has_groupdata() const;
  void clear_groupdata();
  static const int kGroupDataFieldNumber = 2;
  const ::y3d::YGroup& groupdata() const;
  ::y3d::YGroup* mutable_groupdata();
  ::y3d::YGroup* release_groupdata();
  void set_allocated_groupdata(::y3d::YGroup* groupdata);

  // int32 step = 3;
  void clear_step();
  static const int kStepFieldNumber = 3;
  ::google::protobuf::int32 step() const;
  void set_step(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:y3d.YGroupVer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr vname_;
  ::y3d::YGroup* groupdata_;
  ::google::protobuf::int32 step_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO FilterView : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.FilterView) */ {
 public:
  FilterView();
  virtual ~FilterView();

  FilterView(const FilterView& from);

  inline FilterView& operator=(const FilterView& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FilterView& default_instance();

  static inline const FilterView* internal_default_instance() {
    return reinterpret_cast<const FilterView*>(
               &_FilterView_default_instance_);
  }

  void Swap(FilterView* other);

  // implements Message ----------------------------------------------

  inline FilterView* New() const PROTOBUF_FINAL { return New(NULL); }

  FilterView* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FilterView& from);
  void MergeFrom(const FilterView& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FilterView* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string search = 3;
  void clear_search();
  static const int kSearchFieldNumber = 3;
  const ::std::string& search() const;
  void set_search(const ::std::string& value);
  #if LANG_CXX11
  void set_search(::std::string&& value);
  #endif
  void set_search(const char* value);
  void set_search(const char* value, size_t size);
  ::std::string* mutable_search();
  ::std::string* release_search();
  void set_allocated_search(::std::string* search);

  // .y3d.ObjectType otype = 1;
  void clear_otype();
  static const int kOtypeFieldNumber = 1;
  ::y3d::ObjectType otype() const;
  void set_otype(::y3d::ObjectType value);

  // int32 face_range = 2;
  void clear_face_range();
  static const int kFaceRangeFieldNumber = 2;
  ::google::protobuf::int32 face_range() const;
  void set_face_range(::google::protobuf::int32 value);

  // int32 aid = 4;
  void clear_aid();
  static const int kAidFieldNumber = 4;
  ::google::protobuf::int32 aid() const;
  void set_aid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:y3d.FilterView)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr search_;
  int otype_;
  ::google::protobuf::int32 face_range_;
  ::google::protobuf::int32 aid_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO FRangeItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.FRangeItem) */ {
 public:
  FRangeItem();
  virtual ~FRangeItem();

  FRangeItem(const FRangeItem& from);

  inline FRangeItem& operator=(const FRangeItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FRangeItem& default_instance();

  static inline const FRangeItem* internal_default_instance() {
    return reinterpret_cast<const FRangeItem*>(
               &_FRangeItem_default_instance_);
  }

  void Swap(FRangeItem* other);

  // implements Message ----------------------------------------------

  inline FRangeItem* New() const PROTOBUF_FINAL { return New(NULL); }

  FRangeItem* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FRangeItem& from);
  void MergeFrom(const FRangeItem& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FRangeItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .y3d.YColor fr_color = 3;
  bool has_fr_color() const;
  void clear_fr_color();
  static const int kFrColorFieldNumber = 3;
  const ::y3d::YColor& fr_color() const;
  ::y3d::YColor* mutable_fr_color();
  ::y3d::YColor* release_fr_color();
  void set_allocated_fr_color(::y3d::YColor* fr_color);

  // int32 f_start = 1;
  void clear_f_start();
  static const int kFStartFieldNumber = 1;
  ::google::protobuf::int32 f_start() const;
  void set_f_start(::google::protobuf::int32 value);

  // int32 f_end = 2;
  void clear_f_end();
  static const int kFEndFieldNumber = 2;
  ::google::protobuf::int32 f_end() const;
  void set_f_end(::google::protobuf::int32 value);

  // float ratio = 4;
  void clear_ratio();
  static const int kRatioFieldNumber = 4;
  float ratio() const;
  void set_ratio(float value);

  // bool has_xref = 5;
  void clear_has_xref();
  static const int kHasXrefFieldNumber = 5;
  bool has_xref() const;
  void set_has_xref(bool value);

  // @@protoc_insertion_point(class_scope:y3d.FRangeItem)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::y3d::YColor* fr_color_;
  ::google::protobuf::int32 f_start_;
  ::google::protobuf::int32 f_end_;
  float ratio_;
  bool has_xref_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO OptimizeOptions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.OptimizeOptions) */ {
 public:
  OptimizeOptions();
  virtual ~OptimizeOptions();

  OptimizeOptions(const OptimizeOptions& from);

  inline OptimizeOptions& operator=(const OptimizeOptions& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OptimizeOptions& default_instance();

  static inline const OptimizeOptions* internal_default_instance() {
    return reinterpret_cast<const OptimizeOptions*>(
               &_OptimizeOptions_default_instance_);
  }

  void Swap(OptimizeOptions* other);

  // implements Message ----------------------------------------------

  inline OptimizeOptions* New() const PROTOBUF_FINAL { return New(NULL); }

  OptimizeOptions* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OptimizeOptions& from);
  void MergeFrom(const OptimizeOptions& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OptimizeOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .y3d.FRangeItem fr = 2;
  int fr_size() const;
  void clear_fr();
  static const int kFrFieldNumber = 2;
  const ::y3d::FRangeItem& fr(int index) const;
  ::y3d::FRangeItem* mutable_fr(int index);
  ::y3d::FRangeItem* add_fr();
  ::google::protobuf::RepeatedPtrField< ::y3d::FRangeItem >*
      mutable_fr();
  const ::google::protobuf::RepeatedPtrField< ::y3d::FRangeItem >&
      fr() const;

  // bool use_range = 1;
  void clear_use_range();
  static const int kUseRangeFieldNumber = 1;
  bool use_range() const;
  void set_use_range(bool value);

  // int32 min_hpoly = 3;
  void clear_min_hpoly();
  static const int kMinHpolyFieldNumber = 3;
  ::google::protobuf::int32 min_hpoly() const;
  void set_min_hpoly(::google::protobuf::int32 value);

  // int32 out_range_count = 4;
  void clear_out_range_count();
  static const int kOutRangeCountFieldNumber = 4;
  ::google::protobuf::int32 out_range_count() const;
  void set_out_range_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:y3d.OptimizeOptions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::y3d::FRangeItem > fr_;
  bool use_range_;
  ::google::protobuf::int32 min_hpoly_;
  ::google::protobuf::int32 out_range_count_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO ResultReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.ResultReply) */ {
 public:
  ResultReply();
  virtual ~ResultReply();

  ResultReply(const ResultReply& from);

  inline ResultReply& operator=(const ResultReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResultReply& default_instance();

  static inline const ResultReply* internal_default_instance() {
    return reinterpret_cast<const ResultReply*>(
               &_ResultReply_default_instance_);
  }

  void Swap(ResultReply* other);

  // implements Message ----------------------------------------------

  inline ResultReply* New() const PROTOBUF_FINAL { return New(NULL); }

  ResultReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResultReply& from);
  void MergeFrom(const ResultReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResultReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 2;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // bool error = 1;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  bool error() const;
  void set_error(bool value);

  // @@protoc_insertion_point(class_scope:y3d.ResultReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  bool error_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO EmptyParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.EmptyParam) */ {
 public:
  EmptyParam();
  virtual ~EmptyParam();

  EmptyParam(const EmptyParam& from);

  inline EmptyParam& operator=(const EmptyParam& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmptyParam& default_instance();

  static inline const EmptyParam* internal_default_instance() {
    return reinterpret_cast<const EmptyParam*>(
               &_EmptyParam_default_instance_);
  }

  void Swap(EmptyParam* other);

  // implements Message ----------------------------------------------

  inline EmptyParam* New() const PROTOBUF_FINAL { return New(NULL); }

  EmptyParam* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EmptyParam& from);
  void MergeFrom(const EmptyParam& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EmptyParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:y3d.EmptyParam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO RenameParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.RenameParam) */ {
 public:
  RenameParam();
  virtual ~RenameParam();

  RenameParam(const RenameParam& from);

  inline RenameParam& operator=(const RenameParam& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RenameParam& default_instance();

  static inline const RenameParam* internal_default_instance() {
    return reinterpret_cast<const RenameParam*>(
               &_RenameParam_default_instance_);
  }

  void Swap(RenameParam* other);

  // implements Message ----------------------------------------------

  inline RenameParam* New() const PROTOBUF_FINAL { return New(NULL); }

  RenameParam* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RenameParam& from);
  void MergeFrom(const RenameParam& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RenameParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool use_select = 1;
  void clear_use_select();
  static const int kUseSelectFieldNumber = 1;
  bool use_select() const;
  void set_use_select(bool value);

  // @@protoc_insertion_point(class_scope:y3d.RenameParam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool use_select_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO Make4TestParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.Make4TestParam) */ {
 public:
  Make4TestParam();
  virtual ~Make4TestParam();

  Make4TestParam(const Make4TestParam& from);

  inline Make4TestParam& operator=(const Make4TestParam& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Make4TestParam& default_instance();

  static inline const Make4TestParam* internal_default_instance() {
    return reinterpret_cast<const Make4TestParam*>(
               &_Make4TestParam_default_instance_);
  }

  void Swap(Make4TestParam* other);

  // implements Message ----------------------------------------------

  inline Make4TestParam* New() const PROTOBUF_FINAL { return New(NULL); }

  Make4TestParam* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Make4TestParam& from);
  void MergeFrom(const Make4TestParam& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Make4TestParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .y3d.ELowpoly lowpoly = 2;
  int lowpoly_size() const;
  void clear_lowpoly();
  static const int kLowpolyFieldNumber = 2;
  const ::y3d::ELowpoly& lowpoly(int index) const;
  ::y3d::ELowpoly* mutable_lowpoly(int index);
  ::y3d::ELowpoly* add_lowpoly();
  ::google::protobuf::RepeatedPtrField< ::y3d::ELowpoly >*
      mutable_lowpoly();
  const ::google::protobuf::RepeatedPtrField< ::y3d::ELowpoly >&
      lowpoly() const;

  // string oname = 1;
  void clear_oname();
  static const int kOnameFieldNumber = 1;
  const ::std::string& oname() const;
  void set_oname(const ::std::string& value);
  #if LANG_CXX11
  void set_oname(::std::string&& value);
  #endif
  void set_oname(const char* value);
  void set_oname(const char* value, size_t size);
  ::std::string* mutable_oname();
  ::std::string* release_oname();
  void set_allocated_oname(::std::string* oname);

  // @@protoc_insertion_point(class_scope:y3d.Make4TestParam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::y3d::ELowpoly > lowpoly_;
  ::google::protobuf::internal::ArenaStringPtr oname_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO TestOParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.TestOParam) */ {
 public:
  TestOParam();
  virtual ~TestOParam();

  TestOParam(const TestOParam& from);

  inline TestOParam& operator=(const TestOParam& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TestOParam& default_instance();

  static inline const TestOParam* internal_default_instance() {
    return reinterpret_cast<const TestOParam*>(
               &_TestOParam_default_instance_);
  }

  void Swap(TestOParam* other);

  // implements Message ----------------------------------------------

  inline TestOParam* New() const PROTOBUF_FINAL { return New(NULL); }

  TestOParam* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TestOParam& from);
  void MergeFrom(const TestOParam& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TestOParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string oname = 2;
  void clear_oname();
  static const int kOnameFieldNumber = 2;
  const ::std::string& oname() const;
  void set_oname(const ::std::string& value);
  #if LANG_CXX11
  void set_oname(::std::string&& value);
  #endif
  void set_oname(const char* value);
  void set_oname(const char* value, size_t size);
  ::std::string* mutable_oname();
  ::std::string* release_oname();
  void set_allocated_oname(::std::string* oname);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // float low_ratio = 3;
  void clear_low_ratio();
  static const int kLowRatioFieldNumber = 3;
  float low_ratio() const;
  void set_low_ratio(float value);

  // @@protoc_insertion_point(class_scope:y3d.TestOParam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr oname_;
  ::google::protobuf::int32 id_;
  float low_ratio_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO OptimizeParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.OptimizeParam) */ {
 public:
  OptimizeParam();
  virtual ~OptimizeParam();

  OptimizeParam(const OptimizeParam& from);

  inline OptimizeParam& operator=(const OptimizeParam& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OptimizeParam& default_instance();

  static inline const OptimizeParam* internal_default_instance() {
    return reinterpret_cast<const OptimizeParam*>(
               &_OptimizeParam_default_instance_);
  }

  void Swap(OptimizeParam* other);

  // implements Message ----------------------------------------------

  inline OptimizeParam* New() const PROTOBUF_FINAL { return New(NULL); }

  OptimizeParam* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OptimizeParam& from);
  void MergeFrom(const OptimizeParam& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OptimizeParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float ratio = 1;
  void clear_ratio();
  static const int kRatioFieldNumber = 1;
  float ratio() const;
  void set_ratio(float value);

  // @@protoc_insertion_point(class_scope:y3d.OptimizeParam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float ratio_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO BatchOptimizeParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.BatchOptimizeParam) */ {
 public:
  BatchOptimizeParam();
  virtual ~BatchOptimizeParam();

  BatchOptimizeParam(const BatchOptimizeParam& from);

  inline BatchOptimizeParam& operator=(const BatchOptimizeParam& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchOptimizeParam& default_instance();

  static inline const BatchOptimizeParam* internal_default_instance() {
    return reinterpret_cast<const BatchOptimizeParam*>(
               &_BatchOptimizeParam_default_instance_);
  }

  void Swap(BatchOptimizeParam* other);

  // implements Message ----------------------------------------------

  inline BatchOptimizeParam* New() const PROTOBUF_FINAL { return New(NULL); }

  BatchOptimizeParam* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BatchOptimizeParam& from);
  void MergeFrom(const BatchOptimizeParam& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BatchOptimizeParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string folder = 2;
  void clear_folder();
  static const int kFolderFieldNumber = 2;
  const ::std::string& folder() const;
  void set_folder(const ::std::string& value);
  #if LANG_CXX11
  void set_folder(::std::string&& value);
  #endif
  void set_folder(const char* value);
  void set_folder(const char* value, size_t size);
  ::std::string* mutable_folder();
  ::std::string* release_folder();
  void set_allocated_folder(::std::string* folder);

  // string filename = 3;
  void clear_filename();
  static const int kFilenameFieldNumber = 3;
  const ::std::string& filename() const;
  void set_filename(const ::std::string& value);
  #if LANG_CXX11
  void set_filename(::std::string&& value);
  #endif
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  ::std::string* mutable_filename();
  ::std::string* release_filename();
  void set_allocated_filename(::std::string* filename);

  // float ratio = 1;
  void clear_ratio();
  static const int kRatioFieldNumber = 1;
  float ratio() const;
  void set_ratio(float value);

  // @@protoc_insertion_point(class_scope:y3d.BatchOptimizeParam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr folder_;
  ::google::protobuf::internal::ArenaStringPtr filename_;
  float ratio_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO StringParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.StringParam) */ {
 public:
  StringParam();
  virtual ~StringParam();

  StringParam(const StringParam& from);

  inline StringParam& operator=(const StringParam& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StringParam& default_instance();

  static inline const StringParam* internal_default_instance() {
    return reinterpret_cast<const StringParam*>(
               &_StringParam_default_instance_);
  }

  void Swap(StringParam* other);

  // implements Message ----------------------------------------------

  inline StringParam* New() const PROTOBUF_FINAL { return New(NULL); }

  StringParam* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StringParam& from);
  void MergeFrom(const StringParam& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StringParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string str = 1;
  void clear_str();
  static const int kStrFieldNumber = 1;
  const ::std::string& str() const;
  void set_str(const ::std::string& value);
  #if LANG_CXX11
  void set_str(::std::string&& value);
  #endif
  void set_str(const char* value);
  void set_str(const char* value, size_t size);
  ::std::string* mutable_str();
  ::std::string* release_str();
  void set_allocated_str(::std::string* str);

  // @@protoc_insertion_point(class_scope:y3d.StringParam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr str_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO IntParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.IntParam) */ {
 public:
  IntParam();
  virtual ~IntParam();

  IntParam(const IntParam& from);

  inline IntParam& operator=(const IntParam& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IntParam& default_instance();

  static inline const IntParam* internal_default_instance() {
    return reinterpret_cast<const IntParam*>(
               &_IntParam_default_instance_);
  }

  void Swap(IntParam* other);

  // implements Message ----------------------------------------------

  inline IntParam* New() const PROTOBUF_FINAL { return New(NULL); }

  IntParam* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IntParam& from);
  void MergeFrom(const IntParam& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IntParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 int_value = 1;
  void clear_int_value();
  static const int kIntValueFieldNumber = 1;
  ::google::protobuf::int32 int_value() const;
  void set_int_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:y3d.IntParam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 int_value_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO TestParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.TestParam) */ {
 public:
  TestParam();
  virtual ~TestParam();

  TestParam(const TestParam& from);

  inline TestParam& operator=(const TestParam& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TestParam& default_instance();

  static inline const TestParam* internal_default_instance() {
    return reinterpret_cast<const TestParam*>(
               &_TestParam_default_instance_);
  }

  void Swap(TestParam* other);

  // implements Message ----------------------------------------------

  inline TestParam* New() const PROTOBUF_FINAL { return New(NULL); }

  TestParam* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TestParam& from);
  void MergeFrom(const TestParam& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TestParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string test_name = 1;
  void clear_test_name();
  static const int kTestNameFieldNumber = 1;
  const ::std::string& test_name() const;
  void set_test_name(const ::std::string& value);
  #if LANG_CXX11
  void set_test_name(::std::string&& value);
  #endif
  void set_test_name(const char* value);
  void set_test_name(const char* value, size_t size);
  ::std::string* mutable_test_name();
  ::std::string* release_test_name();
  void set_allocated_test_name(::std::string* test_name);

  // .google.protobuf.Any anything = 2;
  bool has_anything() const;
  void clear_anything();
  static const int kAnythingFieldNumber = 2;
  const ::google::protobuf::Any& anything() const;
  ::google::protobuf::Any* mutable_anything();
  ::google::protobuf::Any* release_anything();
  void set_allocated_anything(::google::protobuf::Any* anything);

  // @@protoc_insertion_point(class_scope:y3d.TestParam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr test_name_;
  ::google::protobuf::Any* anything_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO WorkerParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.WorkerParam) */ {
 public:
  WorkerParam();
  virtual ~WorkerParam();

  WorkerParam(const WorkerParam& from);

  inline WorkerParam& operator=(const WorkerParam& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WorkerParam& default_instance();

  enum WtypeCase {
    kWid = 1,
    kWname = 2,
    kWorker = 3,
    WTYPE_NOT_SET = 0,
  };

  static inline const WorkerParam* internal_default_instance() {
    return reinterpret_cast<const WorkerParam*>(
               &_WorkerParam_default_instance_);
  }

  void Swap(WorkerParam* other);

  // implements Message ----------------------------------------------

  inline WorkerParam* New() const PROTOBUF_FINAL { return New(NULL); }

  WorkerParam* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WorkerParam& from);
  void MergeFrom(const WorkerParam& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WorkerParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 wid = 1;
  private:
  bool has_wid() const;
  public:
  void clear_wid();
  static const int kWidFieldNumber = 1;
  ::google::protobuf::int32 wid() const;
  void set_wid(::google::protobuf::int32 value);

  // string wname = 2;
  private:
  bool has_wname() const;
  public:
  void clear_wname();
  static const int kWnameFieldNumber = 2;
  const ::std::string& wname() const;
  void set_wname(const ::std::string& value);
  #if LANG_CXX11
  void set_wname(::std::string&& value);
  #endif
  void set_wname(const char* value);
  void set_wname(const char* value, size_t size);
  ::std::string* mutable_wname();
  ::std::string* release_wname();
  void set_allocated_wname(::std::string* wname);

  // .y3d.YWorker worker = 3;
  bool has_worker() const;
  void clear_worker();
  static const int kWorkerFieldNumber = 3;
  const ::y3d::YWorker& worker() const;
  ::y3d::YWorker* mutable_worker();
  ::y3d::YWorker* release_worker();
  void set_allocated_worker(::y3d::YWorker* worker);

  WtypeCase wtype_case() const;
  // @@protoc_insertion_point(class_scope:y3d.WorkerParam)
 private:
  void set_has_wid();
  void set_has_wname();
  void set_has_worker();

  inline bool has_wtype() const;
  void clear_wtype();
  inline void clear_has_wtype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union WtypeUnion {
    WtypeUnion() {}
    ::google::protobuf::int32 wid_;
    ::google::protobuf::internal::ArenaStringPtr wname_;
    ::y3d::YWorker* worker_;
  } wtype_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO AllWorkerParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.AllWorkerParam) */ {
 public:
  AllWorkerParam();
  virtual ~AllWorkerParam();

  AllWorkerParam(const AllWorkerParam& from);

  inline AllWorkerParam& operator=(const AllWorkerParam& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AllWorkerParam& default_instance();

  static inline const AllWorkerParam* internal_default_instance() {
    return reinterpret_cast<const AllWorkerParam*>(
               &_AllWorkerParam_default_instance_);
  }

  void Swap(AllWorkerParam* other);

  // implements Message ----------------------------------------------

  inline AllWorkerParam* New() const PROTOBUF_FINAL { return New(NULL); }

  AllWorkerParam* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AllWorkerParam& from);
  void MergeFrom(const AllWorkerParam& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AllWorkerParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::google::protobuf::int32 status() const;
  void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:y3d.AllWorkerParam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 status_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YEvent) */ {
 public:
  YEvent();
  virtual ~YEvent();

  YEvent(const YEvent& from);

  inline YEvent& operator=(const YEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YEvent& default_instance();

  enum EventCase {
    kNoevent = 1,
    kSelect = 2,
    kMove = 3,
    kRotate = 4,
    kDel = 5,
    kSelectMany = 6,
    kIsolate = 7,
    EVENT_NOT_SET = 0,
  };

  static inline const YEvent* internal_default_instance() {
    return reinterpret_cast<const YEvent*>(
               &_YEvent_default_instance_);
  }

  void Swap(YEvent* other);

  // implements Message ----------------------------------------------

  inline YEvent* New() const PROTOBUF_FINAL { return New(NULL); }

  YEvent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YEvent& from);
  void MergeFrom(const YEvent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .y3d.ENone noevent = 1;
  bool has_noevent() const;
  void clear_noevent();
  static const int kNoeventFieldNumber = 1;
  const ::y3d::ENone& noevent() const;
  ::y3d::ENone* mutable_noevent();
  ::y3d::ENone* release_noevent();
  void set_allocated_noevent(::y3d::ENone* noevent);

  // .y3d.ESelect select = 2;
  bool has_select() const;
  void clear_select();
  static const int kSelectFieldNumber = 2;
  const ::y3d::ESelect& select() const;
  ::y3d::ESelect* mutable_select();
  ::y3d::ESelect* release_select();
  void set_allocated_select(::y3d::ESelect* select);

  // .y3d.EMove move = 3;
  bool has_move() const;
  void clear_move();
  static const int kMoveFieldNumber = 3;
  const ::y3d::EMove& move() const;
  ::y3d::EMove* mutable_move();
  ::y3d::EMove* release_move();
  void set_allocated_move(::y3d::EMove* move);

  // .y3d.ERotate rotate = 4;
  bool has_rotate() const;
  void clear_rotate();
  static const int kRotateFieldNumber = 4;
  const ::y3d::ERotate& rotate() const;
  ::y3d::ERotate* mutable_rotate();
  ::y3d::ERotate* release_rotate();
  void set_allocated_rotate(::y3d::ERotate* rotate);

  // .y3d.EDelete del = 5;
  bool has_del() const;
  void clear_del();
  static const int kDelFieldNumber = 5;
  const ::y3d::EDelete& del() const;
  ::y3d::EDelete* mutable_del();
  ::y3d::EDelete* release_del();
  void set_allocated_del(::y3d::EDelete* del);

  // .y3d.ESelectMany select_many = 6;
  bool has_select_many() const;
  void clear_select_many();
  static const int kSelectManyFieldNumber = 6;
  const ::y3d::ESelectMany& select_many() const;
  ::y3d::ESelectMany* mutable_select_many();
  ::y3d::ESelectMany* release_select_many();
  void set_allocated_select_many(::y3d::ESelectMany* select_many);

  // .y3d.EIsolate isolate = 7;
  bool has_isolate() const;
  void clear_isolate();
  static const int kIsolateFieldNumber = 7;
  const ::y3d::EIsolate& isolate() const;
  ::y3d::EIsolate* mutable_isolate();
  ::y3d::EIsolate* release_isolate();
  void set_allocated_isolate(::y3d::EIsolate* isolate);

  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:y3d.YEvent)
 private:
  void set_has_noevent();
  void set_has_select();
  void set_has_move();
  void set_has_rotate();
  void set_has_del();
  void set_has_select_many();
  void set_has_isolate();

  inline bool has_event() const;
  void clear_event();
  inline void clear_has_event();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union EventUnion {
    EventUnion() {}
    ::y3d::ENone* noevent_;
    ::y3d::ESelect* select_;
    ::y3d::EMove* move_;
    ::y3d::ERotate* rotate_;
    ::y3d::EDelete* del_;
    ::y3d::ESelectMany* select_many_;
    ::y3d::EIsolate* isolate_;
  } event_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO ENone : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.ENone) */ {
 public:
  ENone();
  virtual ~ENone();

  ENone(const ENone& from);

  inline ENone& operator=(const ENone& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ENone& default_instance();

  static inline const ENone* internal_default_instance() {
    return reinterpret_cast<const ENone*>(
               &_ENone_default_instance_);
  }

  void Swap(ENone* other);

  // implements Message ----------------------------------------------

  inline ENone* New() const PROTOBUF_FINAL { return New(NULL); }

  ENone* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ENone& from);
  void MergeFrom(const ENone& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ENone* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:y3d.ENone)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO ESelect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.ESelect) */ {
 public:
  ESelect();
  virtual ~ESelect();

  ESelect(const ESelect& from);

  inline ESelect& operator=(const ESelect& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ESelect& default_instance();

  static inline const ESelect* internal_default_instance() {
    return reinterpret_cast<const ESelect*>(
               &_ESelect_default_instance_);
  }

  void Swap(ESelect* other);

  // implements Message ----------------------------------------------

  inline ESelect* New() const PROTOBUF_FINAL { return New(NULL); }

  ESelect* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ESelect& from);
  void MergeFrom(const ESelect& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ESelect* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // bool isolate = 2;
  void clear_isolate();
  static const int kIsolateFieldNumber = 2;
  bool isolate() const;
  void set_isolate(bool value);

  // @@protoc_insertion_point(class_scope:y3d.ESelect)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  bool isolate_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO ESelectMany : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.ESelectMany) */ {
 public:
  ESelectMany();
  virtual ~ESelectMany();

  ESelectMany(const ESelectMany& from);

  inline ESelectMany& operator=(const ESelectMany& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ESelectMany& default_instance();

  static inline const ESelectMany* internal_default_instance() {
    return reinterpret_cast<const ESelectMany*>(
               &_ESelectMany_default_instance_);
  }

  void Swap(ESelectMany* other);

  // implements Message ----------------------------------------------

  inline ESelectMany* New() const PROTOBUF_FINAL { return New(NULL); }

  ESelectMany* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ESelectMany& from);
  void MergeFrom(const ESelectMany& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ESelectMany* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string name = 1;
  int name_size() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name(int index) const;
  ::std::string* mutable_name(int index);
  void set_name(int index, const ::std::string& value);
  void set_name(int index, const char* value);
  void set_name(int index, const char* value, size_t size);
  ::std::string* add_name();
  void add_name(const ::std::string& value);
  void add_name(const char* value);
  void add_name(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& name() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_name();

  // bool isolate = 2;
  void clear_isolate();
  static const int kIsolateFieldNumber = 2;
  bool isolate() const;
  void set_isolate(bool value);

  // @@protoc_insertion_point(class_scope:y3d.ESelectMany)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> name_;
  bool isolate_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO EMove : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.EMove) */ {
 public:
  EMove();
  virtual ~EMove();

  EMove(const EMove& from);

  inline EMove& operator=(const EMove& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EMove& default_instance();

  static inline const EMove* internal_default_instance() {
    return reinterpret_cast<const EMove*>(
               &_EMove_default_instance_);
  }

  void Swap(EMove* other);

  // implements Message ----------------------------------------------

  inline EMove* New() const PROTOBUF_FINAL { return New(NULL); }

  EMove* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EMove& from);
  void MergeFrom(const EMove& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EMove* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float point = 1;
  int point_size() const;
  void clear_point();
  static const int kPointFieldNumber = 1;
  float point(int index) const;
  void set_point(int index, float value);
  void add_point(float value);
  const ::google::protobuf::RepeatedField< float >&
      point() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_point();

  // @@protoc_insertion_point(class_scope:y3d.EMove)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > point_;
  mutable int _point_cached_byte_size_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO ERotate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.ERotate) */ {
 public:
  ERotate();
  virtual ~ERotate();

  ERotate(const ERotate& from);

  inline ERotate& operator=(const ERotate& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ERotate& default_instance();

  static inline const ERotate* internal_default_instance() {
    return reinterpret_cast<const ERotate*>(
               &_ERotate_default_instance_);
  }

  void Swap(ERotate* other);

  // implements Message ----------------------------------------------

  inline ERotate* New() const PROTOBUF_FINAL { return New(NULL); }

  ERotate* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ERotate& from);
  void MergeFrom(const ERotate& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ERotate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float rotate = 1;
  int rotate_size() const;
  void clear_rotate();
  static const int kRotateFieldNumber = 1;
  float rotate(int index) const;
  void set_rotate(int index, float value);
  void add_rotate(float value);
  const ::google::protobuf::RepeatedField< float >&
      rotate() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_rotate();

  // @@protoc_insertion_point(class_scope:y3d.ERotate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > rotate_;
  mutable int _rotate_cached_byte_size_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO EDelete : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.EDelete) */ {
 public:
  EDelete();
  virtual ~EDelete();

  EDelete(const EDelete& from);

  inline EDelete& operator=(const EDelete& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EDelete& default_instance();

  static inline const EDelete* internal_default_instance() {
    return reinterpret_cast<const EDelete*>(
               &_EDelete_default_instance_);
  }

  void Swap(EDelete* other);

  // implements Message ----------------------------------------------

  inline EDelete* New() const PROTOBUF_FINAL { return New(NULL); }

  EDelete* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EDelete& from);
  void MergeFrom(const EDelete& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EDelete* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:y3d.EDelete)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO EIsolate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.EIsolate) */ {
 public:
  EIsolate();
  virtual ~EIsolate();

  EIsolate(const EIsolate& from);

  inline EIsolate& operator=(const EIsolate& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EIsolate& default_instance();

  static inline const EIsolate* internal_default_instance() {
    return reinterpret_cast<const EIsolate*>(
               &_EIsolate_default_instance_);
  }

  void Swap(EIsolate* other);

  // implements Message ----------------------------------------------

  inline EIsolate* New() const PROTOBUF_FINAL { return New(NULL); }

  EIsolate* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EIsolate& from);
  void MergeFrom(const EIsolate& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EIsolate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // bool endIsolate = 2;
  void clear_endisolate();
  static const int kEndIsolateFieldNumber = 2;
  bool endisolate() const;
  void set_endisolate(bool value);

  // @@protoc_insertion_point(class_scope:y3d.EIsolate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  bool endisolate_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO ResponseEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.ResponseEvent) */ {
 public:
  ResponseEvent();
  virtual ~ResponseEvent();

  ResponseEvent(const ResponseEvent& from);

  inline ResponseEvent& operator=(const ResponseEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseEvent& default_instance();

  static inline const ResponseEvent* internal_default_instance() {
    return reinterpret_cast<const ResponseEvent*>(
               &_ResponseEvent_default_instance_);
  }

  void Swap(ResponseEvent* other);

  // implements Message ----------------------------------------------

  inline ResponseEvent* New() const PROTOBUF_FINAL { return New(NULL); }

  ResponseEvent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResponseEvent& from);
  void MergeFrom(const ResponseEvent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResponseEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string msg = 2;
  void clear_msg();
  static const int kMsgFieldNumber = 2;
  const ::std::string& msg() const;
  void set_msg(const ::std::string& value);
  #if LANG_CXX11
  void set_msg(::std::string&& value);
  #endif
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  ::std::string* mutable_msg();
  ::std::string* release_msg();
  void set_allocated_msg(::std::string* msg);

  // bool error = 1;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  bool error() const;
  void set_error(bool value);

  // @@protoc_insertion_point(class_scope:y3d.ResponseEvent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr msg_;
  bool error_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO EUnwrap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.EUnwrap) */ {
 public:
  EUnwrap();
  virtual ~EUnwrap();

  EUnwrap(const EUnwrap& from);

  inline EUnwrap& operator=(const EUnwrap& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EUnwrap& default_instance();

  enum SettingCase {
    kMax3D = 3,
    kBlender = 4,
    SETTING_NOT_SET = 0,
  };

  static inline const EUnwrap* internal_default_instance() {
    return reinterpret_cast<const EUnwrap*>(
               &_EUnwrap_default_instance_);
  }

  void Swap(EUnwrap* other);

  // implements Message ----------------------------------------------

  inline EUnwrap* New() const PROTOBUF_FINAL { return New(NULL); }

  EUnwrap* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EUnwrap& from);
  void MergeFrom(const EUnwrap& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EUnwrap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string oname = 1;
  void clear_oname();
  static const int kOnameFieldNumber = 1;
  const ::std::string& oname() const;
  void set_oname(const ::std::string& value);
  #if LANG_CXX11
  void set_oname(::std::string&& value);
  #endif
  void set_oname(const char* value);
  void set_oname(const char* value, size_t size);
  ::std::string* mutable_oname();
  ::std::string* release_oname();
  void set_allocated_oname(::std::string* oname);

  // int32 channel = 2;
  void clear_channel();
  static const int kChannelFieldNumber = 2;
  ::google::protobuf::int32 channel() const;
  void set_channel(::google::protobuf::int32 value);

  // .y3d.MaxUnwrap max3d = 3;
  bool has_max3d() const;
  void clear_max3d();
  static const int kMax3DFieldNumber = 3;
  const ::y3d::MaxUnwrap& max3d() const;
  ::y3d::MaxUnwrap* mutable_max3d();
  ::y3d::MaxUnwrap* release_max3d();
  void set_allocated_max3d(::y3d::MaxUnwrap* max3d);

  // .y3d.BlenderUnwrap blender = 4;
  bool has_blender() const;
  void clear_blender();
  static const int kBlenderFieldNumber = 4;
  const ::y3d::BlenderUnwrap& blender() const;
  ::y3d::BlenderUnwrap* mutable_blender();
  ::y3d::BlenderUnwrap* release_blender();
  void set_allocated_blender(::y3d::BlenderUnwrap* blender);

  SettingCase setting_case() const;
  // @@protoc_insertion_point(class_scope:y3d.EUnwrap)
 private:
  void set_has_max3d();
  void set_has_blender();

  inline bool has_setting() const;
  void clear_setting();
  inline void clear_has_setting();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr oname_;
  ::google::protobuf::int32 channel_;
  union SettingUnion {
    SettingUnion() {}
    ::y3d::MaxUnwrap* max3d_;
    ::y3d::BlenderUnwrap* blender_;
  } setting_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO BlenderUnwrap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.BlenderUnwrap) */ {
 public:
  BlenderUnwrap();
  virtual ~BlenderUnwrap();

  BlenderUnwrap(const BlenderUnwrap& from);

  inline BlenderUnwrap& operator=(const BlenderUnwrap& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlenderUnwrap& default_instance();

  static inline const BlenderUnwrap* internal_default_instance() {
    return reinterpret_cast<const BlenderUnwrap*>(
               &_BlenderUnwrap_default_instance_);
  }

  void Swap(BlenderUnwrap* other);

  // implements Message ----------------------------------------------

  inline BlenderUnwrap* New() const PROTOBUF_FINAL { return New(NULL); }

  BlenderUnwrap* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BlenderUnwrap& from);
  void MergeFrom(const BlenderUnwrap& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BlenderUnwrap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:y3d.BlenderUnwrap)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO MaxUnwrap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.MaxUnwrap) */ {
 public:
  MaxUnwrap();
  virtual ~MaxUnwrap();

  MaxUnwrap(const MaxUnwrap& from);

  inline MaxUnwrap& operator=(const MaxUnwrap& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MaxUnwrap& default_instance();

  static inline const MaxUnwrap* internal_default_instance() {
    return reinterpret_cast<const MaxUnwrap*>(
               &_MaxUnwrap_default_instance_);
  }

  void Swap(MaxUnwrap* other);

  // implements Message ----------------------------------------------

  inline MaxUnwrap* New() const PROTOBUF_FINAL { return New(NULL); }

  MaxUnwrap* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MaxUnwrap& from);
  void MergeFrom(const MaxUnwrap& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MaxUnwrap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float angle = 1;
  void clear_angle();
  static const int kAngleFieldNumber = 1;
  float angle() const;
  void set_angle(float value);

  // float spacing = 2;
  void clear_spacing();
  static const int kSpacingFieldNumber = 2;
  float spacing() const;
  void set_spacing(float value);

  // @@protoc_insertion_point(class_scope:y3d.MaxUnwrap)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float angle_;
  float spacing_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO EPacking : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.EPacking) */ {
 public:
  EPacking();
  virtual ~EPacking();

  EPacking(const EPacking& from);

  inline EPacking& operator=(const EPacking& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EPacking& default_instance();

  enum PackCase {
    kPackmax = 4,
    kPackrect = 5,
    PACK_NOT_SET = 0,
  };

  static inline const EPacking* internal_default_instance() {
    return reinterpret_cast<const EPacking*>(
               &_EPacking_default_instance_);
  }

  void Swap(EPacking* other);

  // implements Message ----------------------------------------------

  inline EPacking* New() const PROTOBUF_FINAL { return New(NULL); }

  EPacking* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EPacking& from);
  void MergeFrom(const EPacking& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EPacking* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string oname = 1;
  void clear_oname();
  static const int kOnameFieldNumber = 1;
  const ::std::string& oname() const;
  void set_oname(const ::std::string& value);
  #if LANG_CXX11
  void set_oname(::std::string&& value);
  #endif
  void set_oname(const char* value);
  void set_oname(const char* value, size_t size);
  ::std::string* mutable_oname();
  ::std::string* release_oname();
  void set_allocated_oname(::std::string* oname);

  // string uvname = 2;
  void clear_uvname();
  static const int kUvnameFieldNumber = 2;
  const ::std::string& uvname() const;
  void set_uvname(const ::std::string& value);
  #if LANG_CXX11
  void set_uvname(::std::string&& value);
  #endif
  void set_uvname(const char* value);
  void set_uvname(const char* value, size_t size);
  ::std::string* mutable_uvname();
  ::std::string* release_uvname();
  void set_allocated_uvname(::std::string* uvname);

  // int32 tile_Size = 3;
  void clear_tile_size();
  static const int kTileSizeFieldNumber = 3;
  ::google::protobuf::int32 tile_size() const;
  void set_tile_size(::google::protobuf::int32 value);

  // .y3d.Pack3DMax packmax = 4;
  bool has_packmax() const;
  void clear_packmax();
  static const int kPackmaxFieldNumber = 4;
  const ::y3d::Pack3DMax& packmax() const;
  ::y3d::Pack3DMax* mutable_packmax();
  ::y3d::Pack3DMax* release_packmax();
  void set_allocated_packmax(::y3d::Pack3DMax* packmax);

  // .y3d.PackRect packrect = 5;
  bool has_packrect() const;
  void clear_packrect();
  static const int kPackrectFieldNumber = 5;
  const ::y3d::PackRect& packrect() const;
  ::y3d::PackRect* mutable_packrect();
  ::y3d::PackRect* release_packrect();
  void set_allocated_packrect(::y3d::PackRect* packrect);

  PackCase pack_case() const;
  // @@protoc_insertion_point(class_scope:y3d.EPacking)
 private:
  void set_has_packmax();
  void set_has_packrect();

  inline bool has_pack() const;
  void clear_pack();
  inline void clear_has_pack();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr oname_;
  ::google::protobuf::internal::ArenaStringPtr uvname_;
  ::google::protobuf::int32 tile_size_;
  union PackUnion {
    PackUnion() {}
    ::y3d::Pack3DMax* packmax_;
    ::y3d::PackRect* packrect_;
  } pack_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO PackRect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.PackRect) */ {
 public:
  PackRect();
  virtual ~PackRect();

  PackRect(const PackRect& from);

  inline PackRect& operator=(const PackRect& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PackRect& default_instance();

  static inline const PackRect* internal_default_instance() {
    return reinterpret_cast<const PackRect*>(
               &_PackRect_default_instance_);
  }

  void Swap(PackRect* other);

  // implements Message ----------------------------------------------

  inline PackRect* New() const PROTOBUF_FINAL { return New(NULL); }

  PackRect* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PackRect& from);
  void MergeFrom(const PackRect& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PackRect* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 density = 1;
  void clear_density();
  static const int kDensityFieldNumber = 1;
  ::google::protobuf::int32 density() const;
  void set_density(::google::protobuf::int32 value);

  // float padding = 2;
  void clear_padding();
  static const int kPaddingFieldNumber = 2;
  float padding() const;
  void set_padding(float value);

  // @@protoc_insertion_point(class_scope:y3d.PackRect)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 density_;
  float padding_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO Pack3DMax : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.Pack3DMax) */ {
 public:
  Pack3DMax();
  virtual ~Pack3DMax();

  Pack3DMax(const Pack3DMax& from);

  inline Pack3DMax& operator=(const Pack3DMax& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pack3DMax& default_instance();

  static inline const Pack3DMax* internal_default_instance() {
    return reinterpret_cast<const Pack3DMax*>(
               &_Pack3DMax_default_instance_);
  }

  void Swap(Pack3DMax* other);

  // implements Message ----------------------------------------------

  inline Pack3DMax* New() const PROTOBUF_FINAL { return New(NULL); }

  Pack3DMax* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Pack3DMax& from);
  void MergeFrom(const Pack3DMax& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Pack3DMax* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 numTile = 1;
  void clear_numtile();
  static const int kNumTileFieldNumber = 1;
  ::google::protobuf::int32 numtile() const;
  void set_numtile(::google::protobuf::int32 value);

  // bool normalize = 2;
  void clear_normalize();
  static const int kNormalizeFieldNumber = 2;
  bool normalize() const;
  void set_normalize(bool value);

  // bool rotate_clusters = 3;
  void clear_rotate_clusters();
  static const int kRotateClustersFieldNumber = 3;
  bool rotate_clusters() const;
  void set_rotate_clusters(bool value);

  // bool fill_holes = 4;
  void clear_fill_holes();
  static const int kFillHolesFieldNumber = 4;
  bool fill_holes() const;
  void set_fill_holes(bool value);

  // bool padding = 5;
  void clear_padding();
  static const int kPaddingFieldNumber = 5;
  bool padding() const;
  void set_padding(bool value);

  // @@protoc_insertion_point(class_scope:y3d.Pack3DMax)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 numtile_;
  bool normalize_;
  bool rotate_clusters_;
  bool fill_holes_;
  bool padding_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO ELowpoly : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.ELowpoly) */ {
 public:
  ELowpoly();
  virtual ~ELowpoly();

  ELowpoly(const ELowpoly& from);

  inline ELowpoly& operator=(const ELowpoly& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ELowpoly& default_instance();

  enum LowtypeCase {
    kLp3Dmax = 2,
    kLpBlender = 3,
    kLpMeshlab = 4,
    LOWTYPE_NOT_SET = 0,
  };

  static inline const ELowpoly* internal_default_instance() {
    return reinterpret_cast<const ELowpoly*>(
               &_ELowpoly_default_instance_);
  }

  void Swap(ELowpoly* other);

  // implements Message ----------------------------------------------

  inline ELowpoly* New() const PROTOBUF_FINAL { return New(NULL); }

  ELowpoly* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ELowpoly& from);
  void MergeFrom(const ELowpoly& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ELowpoly* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string oname = 1;
  void clear_oname();
  static const int kOnameFieldNumber = 1;
  const ::std::string& oname() const;
  void set_oname(const ::std::string& value);
  #if LANG_CXX11
  void set_oname(::std::string&& value);
  #endif
  void set_oname(const char* value);
  void set_oname(const char* value, size_t size);
  ::std::string* mutable_oname();
  ::std::string* release_oname();
  void set_allocated_oname(::std::string* oname);

  // .y3d.LPoly3DMax lp_3dmax = 2;
  bool has_lp_3dmax() const;
  void clear_lp_3dmax();
  static const int kLp3DmaxFieldNumber = 2;
  const ::y3d::LPoly3DMax& lp_3dmax() const;
  ::y3d::LPoly3DMax* mutable_lp_3dmax();
  ::y3d::LPoly3DMax* release_lp_3dmax();
  void set_allocated_lp_3dmax(::y3d::LPoly3DMax* lp_3dmax);

  // .y3d.LPolyBlender lp_blender = 3;
  bool has_lp_blender() const;
  void clear_lp_blender();
  static const int kLpBlenderFieldNumber = 3;
  const ::y3d::LPolyBlender& lp_blender() const;
  ::y3d::LPolyBlender* mutable_lp_blender();
  ::y3d::LPolyBlender* release_lp_blender();
  void set_allocated_lp_blender(::y3d::LPolyBlender* lp_blender);

  // .y3d.LPolyMeshlab lp_meshlab = 4;
  bool has_lp_meshlab() const;
  void clear_lp_meshlab();
  static const int kLpMeshlabFieldNumber = 4;
  const ::y3d::LPolyMeshlab& lp_meshlab() const;
  ::y3d::LPolyMeshlab* mutable_lp_meshlab();
  ::y3d::LPolyMeshlab* release_lp_meshlab();
  void set_allocated_lp_meshlab(::y3d::LPolyMeshlab* lp_meshlab);

  LowtypeCase lowtype_case() const;
  // @@protoc_insertion_point(class_scope:y3d.ELowpoly)
 private:
  void set_has_lp_3dmax();
  void set_has_lp_blender();
  void set_has_lp_meshlab();

  inline bool has_lowtype() const;
  void clear_lowtype();
  inline void clear_has_lowtype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr oname_;
  union LowtypeUnion {
    LowtypeUnion() {}
    ::y3d::LPoly3DMax* lp_3dmax_;
    ::y3d::LPolyBlender* lp_blender_;
    ::y3d::LPolyMeshlab* lp_meshlab_;
  } lowtype_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO LPoly3DMax : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.LPoly3DMax) */ {
 public:
  LPoly3DMax();
  virtual ~LPoly3DMax();

  LPoly3DMax(const LPoly3DMax& from);

  inline LPoly3DMax& operator=(const LPoly3DMax& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LPoly3DMax& default_instance();

  static inline const LPoly3DMax* internal_default_instance() {
    return reinterpret_cast<const LPoly3DMax*>(
               &_LPoly3DMax_default_instance_);
  }

  void Swap(LPoly3DMax* other);

  // implements Message ----------------------------------------------

  inline LPoly3DMax* New() const PROTOBUF_FINAL { return New(NULL); }

  LPoly3DMax* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LPoly3DMax& from);
  void MergeFrom(const LPoly3DMax& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LPoly3DMax* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef LPoly3DMax_OpMode OpMode;
  static const OpMode CRUNCH_BORDERS =
    LPoly3DMax_OpMode_CRUNCH_BORDERS;
  static const OpMode PROTECT_BORDERS =
    LPoly3DMax_OpMode_PROTECT_BORDERS;
  static const OpMode EXCLUDE_BORDERS =
    LPoly3DMax_OpMode_EXCLUDE_BORDERS;
  static inline bool OpMode_IsValid(int value) {
    return LPoly3DMax_OpMode_IsValid(value);
  }
  static const OpMode OpMode_MIN =
    LPoly3DMax_OpMode_OpMode_MIN;
  static const OpMode OpMode_MAX =
    LPoly3DMax_OpMode_OpMode_MAX;
  static const int OpMode_ARRAYSIZE =
    LPoly3DMax_OpMode_OpMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OpMode_descriptor() {
    return LPoly3DMax_OpMode_descriptor();
  }
  static inline const ::std::string& OpMode_Name(OpMode value) {
    return LPoly3DMax_OpMode_Name(value);
  }
  static inline bool OpMode_Parse(const ::std::string& name,
      OpMode* value) {
    return LPoly3DMax_OpMode_Parse(name, value);
  }

  typedef LPoly3DMax_NormalMode NormalMode;
  static const NormalMode CRUNCH_NORMALS =
    LPoly3DMax_NormalMode_CRUNCH_NORMALS;
  static const NormalMode PROTECT_NORMALS =
    LPoly3DMax_NormalMode_PROTECT_NORMALS;
  static const NormalMode EXCLUDE_NORMALS =
    LPoly3DMax_NormalMode_EXCLUDE_NORMALS;
  static inline bool NormalMode_IsValid(int value) {
    return LPoly3DMax_NormalMode_IsValid(value);
  }
  static const NormalMode NormalMode_MIN =
    LPoly3DMax_NormalMode_NormalMode_MIN;
  static const NormalMode NormalMode_MAX =
    LPoly3DMax_NormalMode_NormalMode_MAX;
  static const int NormalMode_ARRAYSIZE =
    LPoly3DMax_NormalMode_NormalMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  NormalMode_descriptor() {
    return LPoly3DMax_NormalMode_descriptor();
  }
  static inline const ::std::string& NormalMode_Name(NormalMode value) {
    return LPoly3DMax_NormalMode_Name(value);
  }
  static inline bool NormalMode_Parse(const ::std::string& name,
      NormalMode* value) {
    return LPoly3DMax_NormalMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // float vertex_percent = 1;
  void clear_vertex_percent();
  static const int kVertexPercentFieldNumber = 1;
  float vertex_percent() const;
  void set_vertex_percent(float value);

  // int32 vertex_count = 2;
  void clear_vertex_count();
  static const int kVertexCountFieldNumber = 2;
  ::google::protobuf::int32 vertex_count() const;
  void set_vertex_count(::google::protobuf::int32 value);

  // .y3d.LPoly3DMax.OpMode optimization_mode = 3;
  void clear_optimization_mode();
  static const int kOptimizationModeFieldNumber = 3;
  ::y3d::LPoly3DMax_OpMode optimization_mode() const;
  void set_optimization_mode(::y3d::LPoly3DMax_OpMode value);

  // .y3d.LPoly3DMax.NormalMode normals = 4;
  void clear_normals();
  static const int kNormalsFieldNumber = 4;
  ::y3d::LPoly3DMax_NormalMode normals() const;
  void set_normals(::y3d::LPoly3DMax_NormalMode value);

  // bool favor_compact_faces = 5;
  void clear_favor_compact_faces();
  static const int kFavorCompactFacesFieldNumber = 5;
  bool favor_compact_faces() const;
  void set_favor_compact_faces(bool value);

  // bool prevent_flipped_normals = 6;
  void clear_prevent_flipped_normals();
  static const int kPreventFlippedNormalsFieldNumber = 6;
  bool prevent_flipped_normals() const;
  void set_prevent_flipped_normals(bool value);

  // bool lock_vertex_position = 7;
  void clear_lock_vertex_position();
  static const int kLockVertexPositionFieldNumber = 7;
  bool lock_vertex_position() const;
  void set_lock_vertex_position(bool value);

  // @@protoc_insertion_point(class_scope:y3d.LPoly3DMax)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float vertex_percent_;
  ::google::protobuf::int32 vertex_count_;
  int optimization_mode_;
  int normals_;
  bool favor_compact_faces_;
  bool prevent_flipped_normals_;
  bool lock_vertex_position_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO LPolyBlender : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.LPolyBlender) */ {
 public:
  LPolyBlender();
  virtual ~LPolyBlender();

  LPolyBlender(const LPolyBlender& from);

  inline LPolyBlender& operator=(const LPolyBlender& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LPolyBlender& default_instance();

  static inline const LPolyBlender* internal_default_instance() {
    return reinterpret_cast<const LPolyBlender*>(
               &_LPolyBlender_default_instance_);
  }

  void Swap(LPolyBlender* other);

  // implements Message ----------------------------------------------

  inline LPolyBlender* New() const PROTOBUF_FINAL { return New(NULL); }

  LPolyBlender* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LPolyBlender& from);
  void MergeFrom(const LPolyBlender& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LPolyBlender* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float ratio = 1;
  void clear_ratio();
  static const int kRatioFieldNumber = 1;
  float ratio() const;
  void set_ratio(float value);

  // @@protoc_insertion_point(class_scope:y3d.LPolyBlender)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float ratio_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO LPolyMeshlab : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.LPolyMeshlab) */ {
 public:
  LPolyMeshlab();
  virtual ~LPolyMeshlab();

  LPolyMeshlab(const LPolyMeshlab& from);

  inline LPolyMeshlab& operator=(const LPolyMeshlab& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LPolyMeshlab& default_instance();

  static inline const LPolyMeshlab* internal_default_instance() {
    return reinterpret_cast<const LPolyMeshlab*>(
               &_LPolyMeshlab_default_instance_);
  }

  void Swap(LPolyMeshlab* other);

  // implements Message ----------------------------------------------

  inline LPolyMeshlab* New() const PROTOBUF_FINAL { return New(NULL); }

  LPolyMeshlab* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LPolyMeshlab& from);
  void MergeFrom(const LPolyMeshlab& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LPolyMeshlab* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:y3d.LPolyMeshlab)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO ENormal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.ENormal) */ {
 public:
  ENormal();
  virtual ~ENormal();

  ENormal(const ENormal& from);

  inline ENormal& operator=(const ENormal& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ENormal& default_instance();

  enum NtypeCase {
    kNormal3Dmax = 6,
    kNormalXnormal = 7,
    NTYPE_NOT_SET = 0,
  };

  static inline const ENormal* internal_default_instance() {
    return reinterpret_cast<const ENormal*>(
               &_ENormal_default_instance_);
  }

  void Swap(ENormal* other);

  // implements Message ----------------------------------------------

  inline ENormal* New() const PROTOBUF_FINAL { return New(NULL); }

  ENormal* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ENormal& from);
  void MergeFrom(const ENormal& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ENormal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string oname = 1;
  void clear_oname();
  static const int kOnameFieldNumber = 1;
  const ::std::string& oname() const;
  void set_oname(const ::std::string& value);
  #if LANG_CXX11
  void set_oname(::std::string&& value);
  #endif
  void set_oname(const char* value);
  void set_oname(const char* value, size_t size);
  ::std::string* mutable_oname();
  ::std::string* release_oname();
  void set_allocated_oname(::std::string* oname);

  // string lowpoly = 2;
  void clear_lowpoly();
  static const int kLowpolyFieldNumber = 2;
  const ::std::string& lowpoly() const;
  void set_lowpoly(const ::std::string& value);
  #if LANG_CXX11
  void set_lowpoly(::std::string&& value);
  #endif
  void set_lowpoly(const char* value);
  void set_lowpoly(const char* value, size_t size);
  ::std::string* mutable_lowpoly();
  ::std::string* release_lowpoly();
  void set_allocated_lowpoly(::std::string* lowpoly);

  // string highpoly = 3;
  void clear_highpoly();
  static const int kHighpolyFieldNumber = 3;
  const ::std::string& highpoly() const;
  void set_highpoly(const ::std::string& value);
  #if LANG_CXX11
  void set_highpoly(::std::string&& value);
  #endif
  void set_highpoly(const char* value);
  void set_highpoly(const char* value, size_t size);
  ::std::string* mutable_highpoly();
  ::std::string* release_highpoly();
  void set_allocated_highpoly(::std::string* highpoly);

  // string out_tex = 5;
  void clear_out_tex();
  static const int kOutTexFieldNumber = 5;
  const ::std::string& out_tex() const;
  void set_out_tex(const ::std::string& value);
  #if LANG_CXX11
  void set_out_tex(::std::string&& value);
  #endif
  void set_out_tex(const char* value);
  void set_out_tex(const char* value, size_t size);
  ::std::string* mutable_out_tex();
  ::std::string* release_out_tex();
  void set_allocated_out_tex(::std::string* out_tex);

  // uint32 tex_size = 4;
  void clear_tex_size();
  static const int kTexSizeFieldNumber = 4;
  ::google::protobuf::uint32 tex_size() const;
  void set_tex_size(::google::protobuf::uint32 value);

  // .y3d.Normal3DMax normal_3dmax = 6;
  bool has_normal_3dmax() const;
  void clear_normal_3dmax();
  static const int kNormal3DmaxFieldNumber = 6;
  const ::y3d::Normal3DMax& normal_3dmax() const;
  ::y3d::Normal3DMax* mutable_normal_3dmax();
  ::y3d::Normal3DMax* release_normal_3dmax();
  void set_allocated_normal_3dmax(::y3d::Normal3DMax* normal_3dmax);

  // .xnormal.Settings normal_xnormal = 7;
  bool has_normal_xnormal() const;
  void clear_normal_xnormal();
  static const int kNormalXnormalFieldNumber = 7;
  const ::xnormal::Settings& normal_xnormal() const;
  ::xnormal::Settings* mutable_normal_xnormal();
  ::xnormal::Settings* release_normal_xnormal();
  void set_allocated_normal_xnormal(::xnormal::Settings* normal_xnormal);

  NtypeCase ntype_case() const;
  // @@protoc_insertion_point(class_scope:y3d.ENormal)
 private:
  void set_has_normal_3dmax();
  void set_has_normal_xnormal();

  inline bool has_ntype() const;
  void clear_ntype();
  inline void clear_has_ntype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr oname_;
  ::google::protobuf::internal::ArenaStringPtr lowpoly_;
  ::google::protobuf::internal::ArenaStringPtr highpoly_;
  ::google::protobuf::internal::ArenaStringPtr out_tex_;
  ::google::protobuf::uint32 tex_size_;
  union NtypeUnion {
    NtypeUnion() {}
    ::y3d::Normal3DMax* normal_3dmax_;
    ::xnormal::Settings* normal_xnormal_;
  } ntype_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO Normal3DMax : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.Normal3DMax) */ {
 public:
  Normal3DMax();
  virtual ~Normal3DMax();

  Normal3DMax(const Normal3DMax& from);

  inline Normal3DMax& operator=(const Normal3DMax& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Normal3DMax& default_instance();

  static inline const Normal3DMax* internal_default_instance() {
    return reinterpret_cast<const Normal3DMax*>(
               &_Normal3DMax_default_instance_);
  }

  void Swap(Normal3DMax* other);

  // implements Message ----------------------------------------------

  inline Normal3DMax* New() const PROTOBUF_FINAL { return New(NULL); }

  Normal3DMax* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Normal3DMax& from);
  void MergeFrom(const Normal3DMax& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Normal3DMax* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:y3d.Normal3DMax)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO ProjectInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.ProjectInfo) */ {
 public:
  ProjectInfo();
  virtual ~ProjectInfo();

  ProjectInfo(const ProjectInfo& from);

  inline ProjectInfo& operator=(const ProjectInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProjectInfo& default_instance();

  static inline const ProjectInfo* internal_default_instance() {
    return reinterpret_cast<const ProjectInfo*>(
               &_ProjectInfo_default_instance_);
  }

  void Swap(ProjectInfo* other);

  // implements Message ----------------------------------------------

  inline ProjectInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ProjectInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProjectInfo& from);
  void MergeFrom(const ProjectInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProjectInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .y3d.FilterView fview = 6;
  int fview_size() const;
  void clear_fview();
  static const int kFviewFieldNumber = 6;
  const ::y3d::FilterView& fview(int index) const;
  ::y3d::FilterView* mutable_fview(int index);
  ::y3d::FilterView* add_fview();
  ::google::protobuf::RepeatedPtrField< ::y3d::FilterView >*
      mutable_fview();
  const ::google::protobuf::RepeatedPtrField< ::y3d::FilterView >&
      fview() const;

  // repeated .y3d.YWorker workers = 9;
  int workers_size() const;
  void clear_workers();
  static const int kWorkersFieldNumber = 9;
  const ::y3d::YWorker& workers(int index) const;
  ::y3d::YWorker* mutable_workers(int index);
  ::y3d::YWorker* add_workers();
  ::google::protobuf::RepeatedPtrField< ::y3d::YWorker >*
      mutable_workers();
  const ::google::protobuf::RepeatedPtrField< ::y3d::YWorker >&
      workers() const;

  // string pname = 1;
  void clear_pname();
  static const int kPnameFieldNumber = 1;
  const ::std::string& pname() const;
  void set_pname(const ::std::string& value);
  #if LANG_CXX11
  void set_pname(::std::string&& value);
  #endif
  void set_pname(const char* value);
  void set_pname(const char* value, size_t size);
  ::std::string* mutable_pname();
  ::std::string* release_pname();
  void set_allocated_pname(::std::string* pname);

  // string project_path = 2;
  void clear_project_path();
  static const int kProjectPathFieldNumber = 2;
  const ::std::string& project_path() const;
  void set_project_path(const ::std::string& value);
  #if LANG_CXX11
  void set_project_path(::std::string&& value);
  #endif
  void set_project_path(const char* value);
  void set_project_path(const char* value, size_t size);
  ::std::string* mutable_project_path();
  ::std::string* release_project_path();
  void set_allocated_project_path(::std::string* project_path);

  // string original_path = 8;
  void clear_original_path();
  static const int kOriginalPathFieldNumber = 8;
  const ::std::string& original_path() const;
  void set_original_path(const ::std::string& value);
  #if LANG_CXX11
  void set_original_path(::std::string&& value);
  #endif
  void set_original_path(const char* value);
  void set_original_path(const char* value, size_t size);
  ::std::string* mutable_original_path();
  ::std::string* release_original_path();
  void set_allocated_original_path(::std::string* original_path);

  // .google.protobuf.Timestamp ts = 3;
  bool has_ts() const;
  void clear_ts();
  static const int kTsFieldNumber = 3;
  const ::google::protobuf::Timestamp& ts() const;
  ::google::protobuf::Timestamp* mutable_ts();
  ::google::protobuf::Timestamp* release_ts();
  void set_allocated_ts(::google::protobuf::Timestamp* ts);

  // .y3d.OptimizeOptions optimize_ops = 5;
  bool has_optimize_ops() const;
  void clear_optimize_ops();
  static const int kOptimizeOpsFieldNumber = 5;
  const ::y3d::OptimizeOptions& optimize_ops() const;
  ::y3d::OptimizeOptions* mutable_optimize_ops();
  ::y3d::OptimizeOptions* release_optimize_ops();
  void set_allocated_optimize_ops(::y3d::OptimizeOptions* optimize_ops);

  // float optimize_ratio = 7;
  void clear_optimize_ratio();
  static const int kOptimizeRatioFieldNumber = 7;
  float optimize_ratio() const;
  void set_optimize_ratio(float value);

  // @@protoc_insertion_point(class_scope:y3d.ProjectInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::y3d::FilterView > fview_;
  ::google::protobuf::RepeatedPtrField< ::y3d::YWorker > workers_;
  ::google::protobuf::internal::ArenaStringPtr pname_;
  ::google::protobuf::internal::ArenaStringPtr project_path_;
  ::google::protobuf::internal::ArenaStringPtr original_path_;
  ::google::protobuf::Timestamp* ts_;
  ::y3d::OptimizeOptions* optimize_ops_;
  float optimize_ratio_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------


// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO SettingData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.SettingData) */ {
 public:
  SettingData();
  virtual ~SettingData();

  SettingData(const SettingData& from);

  inline SettingData& operator=(const SettingData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SettingData& default_instance();

  static inline const SettingData* internal_default_instance() {
    return reinterpret_cast<const SettingData*>(
               &_SettingData_default_instance_);
  }

  void Swap(SettingData* other);

  // implements Message ----------------------------------------------

  inline SettingData* New() const PROTOBUF_FINAL { return New(NULL); }

  SettingData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SettingData& from);
  void MergeFrom(const SettingData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SettingData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .google.protobuf.Any> data = 2;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::google::protobuf::Any >&
      data() const;
  ::google::protobuf::Map< ::std::string, ::google::protobuf::Any >*
      mutable_data();

  // string aset_name = 1;
  void clear_aset_name();
  static const int kAsetNameFieldNumber = 1;
  const ::std::string& aset_name() const;
  void set_aset_name(const ::std::string& value);
  #if LANG_CXX11
  void set_aset_name(::std::string&& value);
  #endif
  void set_aset_name(const char* value);
  void set_aset_name(const char* value, size_t size);
  ::std::string* mutable_aset_name();
  ::std::string* release_aset_name();
  void set_allocated_aset_name(::std::string* aset_name);

  // @@protoc_insertion_point(class_scope:y3d.SettingData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::google::protobuf::Any,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 >
      SettingData_DataEntry;
  ::google::protobuf::internal::MapField<
      ::std::string, ::google::protobuf::Any,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > data_;
  ::google::protobuf::internal::ArenaStringPtr aset_name_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO PSetting : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.PSetting) */ {
 public:
  PSetting();
  virtual ~PSetting();

  PSetting(const PSetting& from);

  inline PSetting& operator=(const PSetting& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PSetting& default_instance();

  static inline const PSetting* internal_default_instance() {
    return reinterpret_cast<const PSetting*>(
               &_PSetting_default_instance_);
  }

  void Swap(PSetting* other);

  // implements Message ----------------------------------------------

  inline PSetting* New() const PROTOBUF_FINAL { return New(NULL); }

  PSetting* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PSetting& from);
  void MergeFrom(const PSetting& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PSetting* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .y3d.SettingData extra = 1;
  bool has_extra() const;
  void clear_extra();
  static const int kExtraFieldNumber = 1;
  const ::y3d::SettingData& extra() const;
  ::y3d::SettingData* mutable_extra();
  ::y3d::SettingData* release_extra();
  void set_allocated_extra(::y3d::SettingData* extra);

  // int32 max_recent = 2;
  void clear_max_recent();
  static const int kMaxRecentFieldNumber = 2;
  ::google::protobuf::int32 max_recent() const;
  void set_max_recent(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:y3d.PSetting)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::y3d::SettingData* extra_;
  ::google::protobuf::int32 max_recent_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------


// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YSystem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YSystem) */ {
 public:
  YSystem();
  virtual ~YSystem();

  YSystem(const YSystem& from);

  inline YSystem& operator=(const YSystem& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YSystem& default_instance();

  static inline const YSystem* internal_default_instance() {
    return reinterpret_cast<const YSystem*>(
               &_YSystem_default_instance_);
  }

  void Swap(YSystem* other);

  // implements Message ----------------------------------------------

  inline YSystem* New() const PROTOBUF_FINAL { return New(NULL); }

  YSystem* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YSystem& from);
  void MergeFrom(const YSystem& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YSystem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // repeated .y3d.ProjectInfo projects = 4;
  int projects_size() const;
  void clear_projects();
  static const int kProjectsFieldNumber = 4;
  const ::y3d::ProjectInfo& projects(int index) const;
  ::y3d::ProjectInfo* mutable_projects(int index);
  ::y3d::ProjectInfo* add_projects();
  ::google::protobuf::RepeatedPtrField< ::y3d::ProjectInfo >*
      mutable_projects();
  const ::google::protobuf::RepeatedPtrField< ::y3d::ProjectInfo >&
      projects() const;

  // map<string, .y3d.WorkerApp> apps = 5;
  int apps_size() const;
  void clear_apps();
  static const int kAppsFieldNumber = 5;
  const ::google::protobuf::Map< ::std::string, ::y3d::WorkerApp >&
      apps() const;
  ::google::protobuf::Map< ::std::string, ::y3d::WorkerApp >*
      mutable_apps();

  // string working_folder = 1;
  void clear_working_folder();
  static const int kWorkingFolderFieldNumber = 1;
  const ::std::string& working_folder() const;
  void set_working_folder(const ::std::string& value);
  #if LANG_CXX11
  void set_working_folder(::std::string&& value);
  #endif
  void set_working_folder(const char* value);
  void set_working_folder(const char* value, size_t size);
  ::std::string* mutable_working_folder();
  ::std::string* release_working_folder();
  void set_allocated_working_folder(::std::string* working_folder);

  // .y3d.ProjectInfo default_info = 2;
  bool has_default_info() const;
  void clear_default_info();
  static const int kDefaultInfoFieldNumber = 2;
  const ::y3d::ProjectInfo& default_info() const;
  ::y3d::ProjectInfo* mutable_default_info();
  ::y3d::ProjectInfo* release_default_info();
  void set_allocated_default_info(::y3d::ProjectInfo* default_info);

  // .y3d.PSetting default_setting = 3;
  bool has_default_setting() const;
  void clear_default_setting();
  static const int kDefaultSettingFieldNumber = 3;
  const ::y3d::PSetting& default_setting() const;
  ::y3d::PSetting* mutable_default_setting();
  ::y3d::PSetting* release_default_setting();
  void set_allocated_default_setting(::y3d::PSetting* default_setting);

  // .y3d.YMasterServer master_server = 6;
  bool has_master_server() const;
  void clear_master_server();
  static const int kMasterServerFieldNumber = 6;
  const ::y3d::YMasterServer& master_server() const;
  ::y3d::YMasterServer* mutable_master_server();
  ::y3d::YMasterServer* release_master_server();
  void set_allocated_master_server(::y3d::YMasterServer* master_server);

  // @@protoc_insertion_point(class_scope:y3d.YSystem)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::y3d::ProjectInfo > projects_;
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::y3d::WorkerApp,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 >
      YSystem_AppsEntry;
  ::google::protobuf::internal::MapField<
      ::std::string, ::y3d::WorkerApp,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > apps_;
  ::google::protobuf::internal::ArenaStringPtr working_folder_;
  ::y3d::ProjectInfo* default_info_;
  ::y3d::PSetting* default_setting_;
  ::y3d::YMasterServer* master_server_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO NewProjectParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.NewProjectParam) */ {
 public:
  NewProjectParam();
  virtual ~NewProjectParam();

  NewProjectParam(const NewProjectParam& from);

  inline NewProjectParam& operator=(const NewProjectParam& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewProjectParam& default_instance();

  static inline const NewProjectParam* internal_default_instance() {
    return reinterpret_cast<const NewProjectParam*>(
               &_NewProjectParam_default_instance_);
  }

  void Swap(NewProjectParam* other);

  // implements Message ----------------------------------------------

  inline NewProjectParam* New() const PROTOBUF_FINAL { return New(NULL); }

  NewProjectParam* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NewProjectParam& from);
  void MergeFrom(const NewProjectParam& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NewProjectParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string fname = 1;
  void clear_fname();
  static const int kFnameFieldNumber = 1;
  const ::std::string& fname() const;
  void set_fname(const ::std::string& value);
  #if LANG_CXX11
  void set_fname(::std::string&& value);
  #endif
  void set_fname(const char* value);
  void set_fname(const char* value, size_t size);
  ::std::string* mutable_fname();
  ::std::string* release_fname();
  void set_allocated_fname(::std::string* fname);

  // string folder = 2;
  void clear_folder();
  static const int kFolderFieldNumber = 2;
  const ::std::string& folder() const;
  void set_folder(const ::std::string& value);
  #if LANG_CXX11
  void set_folder(::std::string&& value);
  #endif
  void set_folder(const char* value);
  void set_folder(const char* value, size_t size);
  ::std::string* mutable_folder();
  ::std::string* release_folder();
  void set_allocated_folder(::std::string* folder);

  // string project_path = 3;
  void clear_project_path();
  static const int kProjectPathFieldNumber = 3;
  const ::std::string& project_path() const;
  void set_project_path(const ::std::string& value);
  #if LANG_CXX11
  void set_project_path(::std::string&& value);
  #endif
  void set_project_path(const char* value);
  void set_project_path(const char* value, size_t size);
  ::std::string* mutable_project_path();
  ::std::string* release_project_path();
  void set_allocated_project_path(::std::string* project_path);

  // @@protoc_insertion_point(class_scope:y3d.NewProjectParam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr fname_;
  ::google::protobuf::internal::ArenaStringPtr folder_;
  ::google::protobuf::internal::ArenaStringPtr project_path_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO ResponseNProject : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.ResponseNProject) */ {
 public:
  ResponseNProject();
  virtual ~ResponseNProject();

  ResponseNProject(const ResponseNProject& from);

  inline ResponseNProject& operator=(const ResponseNProject& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseNProject& default_instance();

  static inline const ResponseNProject* internal_default_instance() {
    return reinterpret_cast<const ResponseNProject*>(
               &_ResponseNProject_default_instance_);
  }

  void Swap(ResponseNProject* other);

  // implements Message ----------------------------------------------

  inline ResponseNProject* New() const PROTOBUF_FINAL { return New(NULL); }

  ResponseNProject* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResponseNProject& from);
  void MergeFrom(const ResponseNProject& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResponseNProject* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string err = 4;
  void clear_err();
  static const int kErrFieldNumber = 4;
  const ::std::string& err() const;
  void set_err(const ::std::string& value);
  #if LANG_CXX11
  void set_err(::std::string&& value);
  #endif
  void set_err(const char* value);
  void set_err(const char* value, size_t size);
  ::std::string* mutable_err();
  ::std::string* release_err();
  void set_allocated_err(::std::string* err);

  // .y3d.ProjectInfo pInfo = 1;
  bool has_pinfo() const;
  void clear_pinfo();
  static const int kPInfoFieldNumber = 1;
  const ::y3d::ProjectInfo& pinfo() const;
  ::y3d::ProjectInfo* mutable_pinfo();
  ::y3d::ProjectInfo* release_pinfo();
  void set_allocated_pinfo(::y3d::ProjectInfo* pinfo);

  // .y3d.YAreaList yal = 2;
  bool has_yal() const;
  void clear_yal();
  static const int kYalFieldNumber = 2;
  const ::y3d::YAreaList& yal() const;
  ::y3d::YAreaList* mutable_yal();
  ::y3d::YAreaList* release_yal();
  void set_allocated_yal(::y3d::YAreaList* yal);

  // @@protoc_insertion_point(class_scope:y3d.ResponseNProject)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr err_;
  ::y3d::ProjectInfo* pinfo_;
  ::y3d::YAreaList* yal_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YJobAction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YJobAction) */ {
 public:
  YJobAction();
  virtual ~YJobAction();

  YJobAction(const YJobAction& from);

  inline YJobAction& operator=(const YJobAction& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YJobAction& default_instance();

  enum ActionCase {
    kUnwrap = 1,
    kPack = 2,
    kLowpoly = 3,
    kBakeNormal = 4,
    ACTION_NOT_SET = 0,
  };

  static inline const YJobAction* internal_default_instance() {
    return reinterpret_cast<const YJobAction*>(
               &_YJobAction_default_instance_);
  }

  void Swap(YJobAction* other);

  // implements Message ----------------------------------------------

  inline YJobAction* New() const PROTOBUF_FINAL { return New(NULL); }

  YJobAction* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YJobAction& from);
  void MergeFrom(const YJobAction& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YJobAction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .y3d.EUnwrap unwrap = 1;
  bool has_unwrap() const;
  void clear_unwrap();
  static const int kUnwrapFieldNumber = 1;
  const ::y3d::EUnwrap& unwrap() const;
  ::y3d::EUnwrap* mutable_unwrap();
  ::y3d::EUnwrap* release_unwrap();
  void set_allocated_unwrap(::y3d::EUnwrap* unwrap);

  // .y3d.EPacking pack = 2;
  bool has_pack() const;
  void clear_pack();
  static const int kPackFieldNumber = 2;
  const ::y3d::EPacking& pack() const;
  ::y3d::EPacking* mutable_pack();
  ::y3d::EPacking* release_pack();
  void set_allocated_pack(::y3d::EPacking* pack);

  // .y3d.ELowpoly lowpoly = 3;
  bool has_lowpoly() const;
  void clear_lowpoly();
  static const int kLowpolyFieldNumber = 3;
  const ::y3d::ELowpoly& lowpoly() const;
  ::y3d::ELowpoly* mutable_lowpoly();
  ::y3d::ELowpoly* release_lowpoly();
  void set_allocated_lowpoly(::y3d::ELowpoly* lowpoly);

  // .y3d.ENormal bake_normal = 4;
  bool has_bake_normal() const;
  void clear_bake_normal();
  static const int kBakeNormalFieldNumber = 4;
  const ::y3d::ENormal& bake_normal() const;
  ::y3d::ENormal* mutable_bake_normal();
  ::y3d::ENormal* release_bake_normal();
  void set_allocated_bake_normal(::y3d::ENormal* bake_normal);

  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:y3d.YJobAction)
 private:
  void set_has_unwrap();
  void set_has_pack();
  void set_has_lowpoly();
  void set_has_bake_normal();

  inline bool has_action() const;
  void clear_action();
  inline void clear_has_action();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ActionUnion {
    ActionUnion() {}
    ::y3d::EUnwrap* unwrap_;
    ::y3d::EPacking* pack_;
    ::y3d::ELowpoly* lowpoly_;
    ::y3d::ENormal* bake_normal_;
  } action_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YItemMesh : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YItemMesh) */ {
 public:
  YItemMesh();
  virtual ~YItemMesh();

  YItemMesh(const YItemMesh& from);

  inline YItemMesh& operator=(const YItemMesh& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YItemMesh& default_instance();

  static inline const YItemMesh* internal_default_instance() {
    return reinterpret_cast<const YItemMesh*>(
               &_YItemMesh_default_instance_);
  }

  void Swap(YItemMesh* other);

  // implements Message ----------------------------------------------

  inline YItemMesh* New() const PROTOBUF_FINAL { return New(NULL); }

  YItemMesh* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YItemMesh& from);
  void MergeFrom(const YItemMesh& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YItemMesh* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .y3d.YMesh meshes = 4;
  int meshes_size() const;
  void clear_meshes();
  static const int kMeshesFieldNumber = 4;
  const ::y3d::YMesh& meshes(int index) const;
  ::y3d::YMesh* mutable_meshes(int index);
  ::y3d::YMesh* add_meshes();
  ::google::protobuf::RepeatedPtrField< ::y3d::YMesh >*
      mutable_meshes();
  const ::google::protobuf::RepeatedPtrField< ::y3d::YMesh >&
      meshes() const;

  // .y3d.YMat bake_mat = 1;
  bool has_bake_mat() const;
  void clear_bake_mat();
  static const int kBakeMatFieldNumber = 1;
  const ::y3d::YMat& bake_mat() const;
  ::y3d::YMat* mutable_bake_mat();
  ::y3d::YMat* release_bake_mat();
  void set_allocated_bake_mat(::y3d::YMat* bake_mat);

  // .y3d.YBaseMap map = 2;
  bool has_map() const;
  void clear_map();
  static const int kMapFieldNumber = 2;
  const ::y3d::YBaseMap& map() const;
  ::y3d::YBaseMap* mutable_map();
  ::y3d::YBaseMap* release_map();
  void set_allocated_map(::y3d::YBaseMap* map);

  // .y3d.YMesh mesh = 3;
  bool has_mesh() const;
  void clear_mesh();
  static const int kMeshFieldNumber = 3;
  const ::y3d::YMesh& mesh() const;
  ::y3d::YMesh* mutable_mesh();
  ::y3d::YMesh* release_mesh();
  void set_allocated_mesh(::y3d::YMesh* mesh);

  // @@protoc_insertion_point(class_scope:y3d.YItemMesh)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::y3d::YMesh > meshes_;
  ::y3d::YMat* bake_mat_;
  ::y3d::YBaseMap* map_;
  ::y3d::YMesh* mesh_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO TestObject : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.TestObject) */ {
 public:
  TestObject();
  virtual ~TestObject();

  TestObject(const TestObject& from);

  inline TestObject& operator=(const TestObject& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TestObject& default_instance();

  static inline const TestObject* internal_default_instance() {
    return reinterpret_cast<const TestObject*>(
               &_TestObject_default_instance_);
  }

  void Swap(TestObject* other);

  // implements Message ----------------------------------------------

  inline TestObject* New() const PROTOBUF_FINAL { return New(NULL); }

  TestObject* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TestObject& from);
  void MergeFrom(const TestObject& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TestObject* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string tname = 3;
  void clear_tname();
  static const int kTnameFieldNumber = 3;
  const ::std::string& tname() const;
  void set_tname(const ::std::string& value);
  #if LANG_CXX11
  void set_tname(::std::string&& value);
  #endif
  void set_tname(const char* value);
  void set_tname(const char* value, size_t size);
  ::std::string* mutable_tname();
  ::std::string* release_tname();
  void set_allocated_tname(::std::string* tname);

  // string oname = 4;
  void clear_oname();
  static const int kOnameFieldNumber = 4;
  const ::std::string& oname() const;
  void set_oname(const ::std::string& value);
  #if LANG_CXX11
  void set_oname(::std::string&& value);
  #endif
  void set_oname(const char* value);
  void set_oname(const char* value, size_t size);
  ::std::string* mutable_oname();
  ::std::string* release_oname();
  void set_allocated_oname(::std::string* oname);

  // string save_path = 9;
  void clear_save_path();
  static const int kSavePathFieldNumber = 9;
  const ::std::string& save_path() const;
  void set_save_path(const ::std::string& value);
  #if LANG_CXX11
  void set_save_path(::std::string&& value);
  #endif
  void set_save_path(const char* value);
  void set_save_path(const char* value, size_t size);
  ::std::string* mutable_save_path();
  ::std::string* release_save_path();
  void set_allocated_save_path(::std::string* save_path);

  // .y3d.YMat original_mat = 2;
  bool has_original_mat() const;
  void clear_original_mat();
  static const int kOriginalMatFieldNumber = 2;
  const ::y3d::YMat& original_mat() const;
  ::y3d::YMat* mutable_original_mat();
  ::y3d::YMat* release_original_mat();
  void set_allocated_original_mat(::y3d::YMat* original_mat);

  // .y3d.YItemMesh out = 10;
  bool has_out() const;
  void clear_out();
  static const int kOutFieldNumber = 10;
  const ::y3d::YItemMesh& out() const;
  ::y3d::YItemMesh* mutable_out();
  ::y3d::YItemMesh* release_out();
  void set_allocated_out(::y3d::YItemMesh* out);

  // bool active = 1;
  void clear_active();
  static const int kActiveFieldNumber = 1;
  bool active() const;
  void set_active(bool value);

  // @@protoc_insertion_point(class_scope:y3d.TestObject)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr tname_;
  ::google::protobuf::internal::ArenaStringPtr oname_;
  ::google::protobuf::internal::ArenaStringPtr save_path_;
  ::y3d::YMat* original_mat_;
  ::y3d::YItemMesh* out_;
  bool active_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YJob : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YJob) */ {
 public:
  YJob();
  virtual ~YJob();

  YJob(const YJob& from);

  inline YJob& operator=(const YJob& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YJob& default_instance();

  static inline const YJob* internal_default_instance() {
    return reinterpret_cast<const YJob*>(
               &_YJob_default_instance_);
  }

  void Swap(YJob* other);

  // implements Message ----------------------------------------------

  inline YJob* New() const PROTOBUF_FINAL { return New(NULL); }

  YJob* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YJob& from);
  void MergeFrom(const YJob& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YJob* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .y3d.YJobAction act = 2;
  int act_size() const;
  void clear_act();
  static const int kActFieldNumber = 2;
  const ::y3d::YJobAction& act(int index) const;
  ::y3d::YJobAction* mutable_act(int index);
  ::y3d::YJobAction* add_act();
  ::google::protobuf::RepeatedPtrField< ::y3d::YJobAction >*
      mutable_act();
  const ::google::protobuf::RepeatedPtrField< ::y3d::YJobAction >&
      act() const;

  // repeated .y3d.YObject objs = 4;
  int objs_size() const;
  void clear_objs();
  static const int kObjsFieldNumber = 4;
  const ::y3d::YObject& objs(int index) const;
  ::y3d::YObject* mutable_objs(int index);
  ::y3d::YObject* add_objs();
  ::google::protobuf::RepeatedPtrField< ::y3d::YObject >*
      mutable_objs();
  const ::google::protobuf::RepeatedPtrField< ::y3d::YObject >&
      objs() const;

  // repeated .y3d.TestObject tests = 7;
  int tests_size() const;
  void clear_tests();
  static const int kTestsFieldNumber = 7;
  const ::y3d::TestObject& tests(int index) const;
  ::y3d::TestObject* mutable_tests(int index);
  ::y3d::TestObject* add_tests();
  ::google::protobuf::RepeatedPtrField< ::y3d::TestObject >*
      mutable_tests();
  const ::google::protobuf::RepeatedPtrField< ::y3d::TestObject >&
      tests() const;

  // string jname = 1;
  void clear_jname();
  static const int kJnameFieldNumber = 1;
  const ::std::string& jname() const;
  void set_jname(const ::std::string& value);
  #if LANG_CXX11
  void set_jname(::std::string&& value);
  #endif
  void set_jname(const char* value);
  void set_jname(const char* value, size_t size);
  ::std::string* mutable_jname();
  ::std::string* release_jname();
  void set_allocated_jname(::std::string* jname);

  // .y3d.YObject obj = 3;
  bool has_obj() const;
  void clear_obj();
  static const int kObjFieldNumber = 3;
  const ::y3d::YObject& obj() const;
  ::y3d::YObject* mutable_obj();
  ::y3d::YObject* release_obj();
  void set_allocated_obj(::y3d::YObject* obj);

  // .y3d.YItemMesh out = 5;
  bool has_out() const;
  void clear_out();
  static const int kOutFieldNumber = 5;
  const ::y3d::YItemMesh& out() const;
  ::y3d::YItemMesh* mutable_out();
  ::y3d::YItemMesh* release_out();
  void set_allocated_out(::y3d::YItemMesh* out);

  // @@protoc_insertion_point(class_scope:y3d.YJob)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::y3d::YJobAction > act_;
  ::google::protobuf::RepeatedPtrField< ::y3d::YObject > objs_;
  ::google::protobuf::RepeatedPtrField< ::y3d::TestObject > tests_;
  ::google::protobuf::internal::ArenaStringPtr jname_;
  ::y3d::YObject* obj_;
  ::y3d::YItemMesh* out_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YJobList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YJobList) */ {
 public:
  YJobList();
  virtual ~YJobList();

  YJobList(const YJobList& from);

  inline YJobList& operator=(const YJobList& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YJobList& default_instance();

  static inline const YJobList* internal_default_instance() {
    return reinterpret_cast<const YJobList*>(
               &_YJobList_default_instance_);
  }

  void Swap(YJobList* other);

  // implements Message ----------------------------------------------

  inline YJobList* New() const PROTOBUF_FINAL { return New(NULL); }

  YJobList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YJobList& from);
  void MergeFrom(const YJobList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YJobList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .y3d.YJob jobs = 1;
  int jobs_size() const;
  void clear_jobs();
  static const int kJobsFieldNumber = 1;
  const ::y3d::YJob& jobs(int index) const;
  ::y3d::YJob* mutable_jobs(int index);
  ::y3d::YJob* add_jobs();
  ::google::protobuf::RepeatedPtrField< ::y3d::YJob >*
      mutable_jobs();
  const ::google::protobuf::RepeatedPtrField< ::y3d::YJob >&
      jobs() const;

  // @@protoc_insertion_point(class_scope:y3d.YJobList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::y3d::YJob > jobs_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YWorker : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YWorker) */ {
 public:
  YWorker();
  virtual ~YWorker();

  YWorker(const YWorker& from);

  inline YWorker& operator=(const YWorker& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YWorker& default_instance();

  static inline const YWorker* internal_default_instance() {
    return reinterpret_cast<const YWorker*>(
               &_YWorker_default_instance_);
  }

  void Swap(YWorker* other);

  // implements Message ----------------------------------------------

  inline YWorker* New() const PROTOBUF_FINAL { return New(NULL); }

  YWorker* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YWorker& from);
  void MergeFrom(const YWorker& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YWorker* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef YWorker_ServingStatus ServingStatus;
  static const ServingStatus UNKNOWN =
    YWorker_ServingStatus_UNKNOWN;
  static const ServingStatus SERVING =
    YWorker_ServingStatus_SERVING;
  static const ServingStatus NOT_SERVING =
    YWorker_ServingStatus_NOT_SERVING;
  static const ServingStatus NOT_CONNECT_MASTER =
    YWorker_ServingStatus_NOT_CONNECT_MASTER;
  static const ServingStatus NO_PROJECT =
    YWorker_ServingStatus_NO_PROJECT;
  static inline bool ServingStatus_IsValid(int value) {
    return YWorker_ServingStatus_IsValid(value);
  }
  static const ServingStatus ServingStatus_MIN =
    YWorker_ServingStatus_ServingStatus_MIN;
  static const ServingStatus ServingStatus_MAX =
    YWorker_ServingStatus_ServingStatus_MAX;
  static const int ServingStatus_ARRAYSIZE =
    YWorker_ServingStatus_ServingStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ServingStatus_descriptor() {
    return YWorker_ServingStatus_descriptor();
  }
  static inline const ::std::string& ServingStatus_Name(ServingStatus value) {
    return YWorker_ServingStatus_Name(value);
  }
  static inline bool ServingStatus_Parse(const ::std::string& name,
      ServingStatus* value) {
    return YWorker_ServingStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string wname = 2;
  void clear_wname();
  static const int kWnameFieldNumber = 2;
  const ::std::string& wname() const;
  void set_wname(const ::std::string& value);
  #if LANG_CXX11
  void set_wname(::std::string&& value);
  #endif
  void set_wname(const char* value);
  void set_wname(const char* value, size_t size);
  ::std::string* mutable_wname();
  ::std::string* release_wname();
  void set_allocated_wname(::std::string* wname);

  // string ip_address = 3;
  void clear_ip_address();
  static const int kIpAddressFieldNumber = 3;
  const ::std::string& ip_address() const;
  void set_ip_address(const ::std::string& value);
  #if LANG_CXX11
  void set_ip_address(::std::string&& value);
  #endif
  void set_ip_address(const char* value);
  void set_ip_address(const char* value, size_t size);
  ::std::string* mutable_ip_address();
  ::std::string* release_ip_address();
  void set_allocated_ip_address(::std::string* ip_address);

  // int32 wid = 1;
  void clear_wid();
  static const int kWidFieldNumber = 1;
  ::google::protobuf::int32 wid() const;
  void set_wid(::google::protobuf::int32 value);

  // int32 process_id = 4;
  void clear_process_id();
  static const int kProcessIdFieldNumber = 4;
  ::google::protobuf::int32 process_id() const;
  void set_process_id(::google::protobuf::int32 value);

  // .y3d.YWorker.ServingStatus status = 5;
  void clear_status();
  static const int kStatusFieldNumber = 5;
  ::y3d::YWorker_ServingStatus status() const;
  void set_status(::y3d::YWorker_ServingStatus value);

  // @@protoc_insertion_point(class_scope:y3d.YWorker)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr wname_;
  ::google::protobuf::internal::ArenaStringPtr ip_address_;
  ::google::protobuf::int32 wid_;
  ::google::protobuf::int32 process_id_;
  int status_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YSubWorker : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YSubWorker) */ {
 public:
  YSubWorker();
  virtual ~YSubWorker();

  YSubWorker(const YSubWorker& from);

  inline YSubWorker& operator=(const YSubWorker& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YSubWorker& default_instance();

  static inline const YSubWorker* internal_default_instance() {
    return reinterpret_cast<const YSubWorker*>(
               &_YSubWorker_default_instance_);
  }

  void Swap(YSubWorker* other);

  // implements Message ----------------------------------------------

  inline YSubWorker* New() const PROTOBUF_FINAL { return New(NULL); }

  YSubWorker* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YSubWorker& from);
  void MergeFrom(const YSubWorker& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YSubWorker* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sname = 2;
  void clear_sname();
  static const int kSnameFieldNumber = 2;
  const ::std::string& sname() const;
  void set_sname(const ::std::string& value);
  #if LANG_CXX11
  void set_sname(::std::string&& value);
  #endif
  void set_sname(const char* value);
  void set_sname(const char* value, size_t size);
  ::std::string* mutable_sname();
  ::std::string* release_sname();
  void set_allocated_sname(::std::string* sname);

  // string asset_folder = 3;
  void clear_asset_folder();
  static const int kAssetFolderFieldNumber = 3;
  const ::std::string& asset_folder() const;
  void set_asset_folder(const ::std::string& value);
  #if LANG_CXX11
  void set_asset_folder(::std::string&& value);
  #endif
  void set_asset_folder(const char* value);
  void set_asset_folder(const char* value, size_t size);
  ::std::string* mutable_asset_folder();
  ::std::string* release_asset_folder();
  void set_allocated_asset_folder(::std::string* asset_folder);

  // .y3d.YWorker worker = 4;
  bool has_worker() const;
  void clear_worker();
  static const int kWorkerFieldNumber = 4;
  const ::y3d::YWorker& worker() const;
  ::y3d::YWorker* mutable_worker();
  ::y3d::YWorker* release_worker();
  void set_allocated_worker(::y3d::YWorker* worker);

  // int32 sid = 1;
  void clear_sid();
  static const int kSidFieldNumber = 1;
  ::google::protobuf::int32 sid() const;
  void set_sid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:y3d.YSubWorker)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr sname_;
  ::google::protobuf::internal::ArenaStringPtr asset_folder_;
  ::y3d::YWorker* worker_;
  ::google::protobuf::int32 sid_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YMainWorker : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YMainWorker) */ {
 public:
  YMainWorker();
  virtual ~YMainWorker();

  YMainWorker(const YMainWorker& from);

  inline YMainWorker& operator=(const YMainWorker& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YMainWorker& default_instance();

  static inline const YMainWorker* internal_default_instance() {
    return reinterpret_cast<const YMainWorker*>(
               &_YMainWorker_default_instance_);
  }

  void Swap(YMainWorker* other);

  // implements Message ----------------------------------------------

  inline YMainWorker* New() const PROTOBUF_FINAL { return New(NULL); }

  YMainWorker* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YMainWorker& from);
  void MergeFrom(const YMainWorker& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YMainWorker* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .y3d.YSubWorker workers = 2;
  int workers_size() const;
  void clear_workers();
  static const int kWorkersFieldNumber = 2;
  const ::y3d::YSubWorker& workers(int index) const;
  ::y3d::YSubWorker* mutable_workers(int index);
  ::y3d::YSubWorker* add_workers();
  ::google::protobuf::RepeatedPtrField< ::y3d::YSubWorker >*
      mutable_workers();
  const ::google::protobuf::RepeatedPtrField< ::y3d::YSubWorker >&
      workers() const;

  // string working_project = 3;
  void clear_working_project();
  static const int kWorkingProjectFieldNumber = 3;
  const ::std::string& working_project() const;
  void set_working_project(const ::std::string& value);
  #if LANG_CXX11
  void set_working_project(::std::string&& value);
  #endif
  void set_working_project(const char* value);
  void set_working_project(const char* value, size_t size);
  ::std::string* mutable_working_project();
  ::std::string* release_working_project();
  void set_allocated_working_project(::std::string* working_project);

  // .y3d.YSubWorker main_worker = 1;
  bool has_main_worker() const;
  void clear_main_worker();
  static const int kMainWorkerFieldNumber = 1;
  const ::y3d::YSubWorker& main_worker() const;
  ::y3d::YSubWorker* mutable_main_worker();
  ::y3d::YSubWorker* release_main_worker();
  void set_allocated_main_worker(::y3d::YSubWorker* main_worker);

  // @@protoc_insertion_point(class_scope:y3d.YMainWorker)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::y3d::YSubWorker > workers_;
  ::google::protobuf::internal::ArenaStringPtr working_project_;
  ::y3d::YSubWorker* main_worker_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YWorkerList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YWorkerList) */ {
 public:
  YWorkerList();
  virtual ~YWorkerList();

  YWorkerList(const YWorkerList& from);

  inline YWorkerList& operator=(const YWorkerList& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YWorkerList& default_instance();

  static inline const YWorkerList* internal_default_instance() {
    return reinterpret_cast<const YWorkerList*>(
               &_YWorkerList_default_instance_);
  }

  void Swap(YWorkerList* other);

  // implements Message ----------------------------------------------

  inline YWorkerList* New() const PROTOBUF_FINAL { return New(NULL); }

  YWorkerList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YWorkerList& from);
  void MergeFrom(const YWorkerList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YWorkerList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .y3d.YWorker workers = 1;
  int workers_size() const;
  void clear_workers();
  static const int kWorkersFieldNumber = 1;
  const ::y3d::YWorker& workers(int index) const;
  ::y3d::YWorker* mutable_workers(int index);
  ::y3d::YWorker* add_workers();
  ::google::protobuf::RepeatedPtrField< ::y3d::YWorker >*
      mutable_workers();
  const ::google::protobuf::RepeatedPtrField< ::y3d::YWorker >&
      workers() const;

  // @@protoc_insertion_point(class_scope:y3d.YWorkerList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::y3d::YWorker > workers_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YWorkerRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YWorkerRequest) */ {
 public:
  YWorkerRequest();
  virtual ~YWorkerRequest();

  YWorkerRequest(const YWorkerRequest& from);

  inline YWorkerRequest& operator=(const YWorkerRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YWorkerRequest& default_instance();

  static inline const YWorkerRequest* internal_default_instance() {
    return reinterpret_cast<const YWorkerRequest*>(
               &_YWorkerRequest_default_instance_);
  }

  void Swap(YWorkerRequest* other);

  // implements Message ----------------------------------------------

  inline YWorkerRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  YWorkerRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YWorkerRequest& from);
  void MergeFrom(const YWorkerRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YWorkerRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .y3d.WorkerApp app = 3;
  bool has_app() const;
  void clear_app();
  static const int kAppFieldNumber = 3;
  const ::y3d::WorkerApp& app() const;
  ::y3d::WorkerApp* mutable_app();
  ::y3d::WorkerApp* release_app();
  void set_allocated_app(::y3d::WorkerApp* app);

  // bool call_in_app = 1;
  void clear_call_in_app();
  static const int kCallInAppFieldNumber = 1;
  bool call_in_app() const;
  void set_call_in_app(bool value);

  // bool slient = 2;
  void clear_slient();
  static const int kSlientFieldNumber = 2;
  bool slient() const;
  void set_slient(bool value);

  // @@protoc_insertion_point(class_scope:y3d.YWorkerRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::y3d::WorkerApp* app_;
  bool call_in_app_;
  bool slient_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO WorkerApp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.WorkerApp) */ {
 public:
  WorkerApp();
  virtual ~WorkerApp();

  WorkerApp(const WorkerApp& from);

  inline WorkerApp& operator=(const WorkerApp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WorkerApp& default_instance();

  static inline const WorkerApp* internal_default_instance() {
    return reinterpret_cast<const WorkerApp*>(
               &_WorkerApp_default_instance_);
  }

  void Swap(WorkerApp* other);

  // implements Message ----------------------------------------------

  inline WorkerApp* New() const PROTOBUF_FINAL { return New(NULL); }

  WorkerApp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WorkerApp& from);
  void MergeFrom(const WorkerApp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WorkerApp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string wname = 1;
  void clear_wname();
  static const int kWnameFieldNumber = 1;
  const ::std::string& wname() const;
  void set_wname(const ::std::string& value);
  #if LANG_CXX11
  void set_wname(::std::string&& value);
  #endif
  void set_wname(const char* value);
  void set_wname(const char* value, size_t size);
  ::std::string* mutable_wname();
  ::std::string* release_wname();
  void set_allocated_wname(::std::string* wname);

  // string path_run = 2;
  void clear_path_run();
  static const int kPathRunFieldNumber = 2;
  const ::std::string& path_run() const;
  void set_path_run(const ::std::string& value);
  #if LANG_CXX11
  void set_path_run(::std::string&& value);
  #endif
  void set_path_run(const char* value);
  void set_path_run(const char* value, size_t size);
  ::std::string* mutable_path_run();
  ::std::string* release_path_run();
  void set_allocated_path_run(::std::string* path_run);

  // string extra = 3;
  void clear_extra();
  static const int kExtraFieldNumber = 3;
  const ::std::string& extra() const;
  void set_extra(const ::std::string& value);
  #if LANG_CXX11
  void set_extra(::std::string&& value);
  #endif
  void set_extra(const char* value);
  void set_extra(const char* value, size_t size);
  ::std::string* mutable_extra();
  ::std::string* release_extra();
  void set_allocated_extra(::std::string* extra);

  // @@protoc_insertion_point(class_scope:y3d.WorkerApp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr wname_;
  ::google::protobuf::internal::ArenaStringPtr path_run_;
  ::google::protobuf::internal::ArenaStringPtr extra_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YWorkerResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YWorkerResponse) */ {
 public:
  YWorkerResponse();
  virtual ~YWorkerResponse();

  YWorkerResponse(const YWorkerResponse& from);

  inline YWorkerResponse& operator=(const YWorkerResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YWorkerResponse& default_instance();

  static inline const YWorkerResponse* internal_default_instance() {
    return reinterpret_cast<const YWorkerResponse*>(
               &_YWorkerResponse_default_instance_);
  }

  void Swap(YWorkerResponse* other);

  // implements Message ----------------------------------------------

  inline YWorkerResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  YWorkerResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YWorkerResponse& from);
  void MergeFrom(const YWorkerResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YWorkerResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 4;
  void clear_message();
  static const int kMessageFieldNumber = 4;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // .y3d.YWorkerList wlist = 1;
  bool has_wlist() const;
  void clear_wlist();
  static const int kWlistFieldNumber = 1;
  const ::y3d::YWorkerList& wlist() const;
  ::y3d::YWorkerList* mutable_wlist();
  ::y3d::YWorkerList* release_wlist();
  void set_allocated_wlist(::y3d::YWorkerList* wlist);

  // .y3d.YWorker worker = 2;
  bool has_worker() const;
  void clear_worker();
  static const int kWorkerFieldNumber = 2;
  const ::y3d::YWorker& worker() const;
  ::y3d::YWorker* mutable_worker();
  ::y3d::YWorker* release_worker();
  void set_allocated_worker(::y3d::YWorker* worker);

  // bool error = 3;
  void clear_error();
  static const int kErrorFieldNumber = 3;
  bool error() const;
  void set_error(bool value);

  // @@protoc_insertion_point(class_scope:y3d.YWorkerResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::y3d::YWorkerList* wlist_;
  ::y3d::YWorker* worker_;
  bool error_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YMasterServer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YMasterServer) */ {
 public:
  YMasterServer();
  virtual ~YMasterServer();

  YMasterServer(const YMasterServer& from);

  inline YMasterServer& operator=(const YMasterServer& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YMasterServer& default_instance();

  static inline const YMasterServer* internal_default_instance() {
    return reinterpret_cast<const YMasterServer*>(
               &_YMasterServer_default_instance_);
  }

  void Swap(YMasterServer* other);

  // implements Message ----------------------------------------------

  inline YMasterServer* New() const PROTOBUF_FINAL { return New(NULL); }

  YMasterServer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YMasterServer& from);
  void MergeFrom(const YMasterServer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YMasterServer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .y3d.YMainWorker main_workers = 4;
  int main_workers_size() const;
  void clear_main_workers();
  static const int kMainWorkersFieldNumber = 4;
  const ::y3d::YMainWorker& main_workers(int index) const;
  ::y3d::YMainWorker* mutable_main_workers(int index);
  ::y3d::YMainWorker* add_main_workers();
  ::google::protobuf::RepeatedPtrField< ::y3d::YMainWorker >*
      mutable_main_workers();
  const ::google::protobuf::RepeatedPtrField< ::y3d::YMainWorker >&
      main_workers() const;

  // string mname = 1;
  void clear_mname();
  static const int kMnameFieldNumber = 1;
  const ::std::string& mname() const;
  void set_mname(const ::std::string& value);
  #if LANG_CXX11
  void set_mname(::std::string&& value);
  #endif
  void set_mname(const char* value);
  void set_mname(const char* value, size_t size);
  ::std::string* mutable_mname();
  ::std::string* release_mname();
  void set_allocated_mname(::std::string* mname);

  // string address = 2;
  void clear_address();
  static const int kAddressFieldNumber = 2;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // string shared_folder = 3;
  void clear_shared_folder();
  static const int kSharedFolderFieldNumber = 3;
  const ::std::string& shared_folder() const;
  void set_shared_folder(const ::std::string& value);
  #if LANG_CXX11
  void set_shared_folder(::std::string&& value);
  #endif
  void set_shared_folder(const char* value);
  void set_shared_folder(const char* value, size_t size);
  ::std::string* mutable_shared_folder();
  ::std::string* release_shared_folder();
  void set_allocated_shared_folder(::std::string* shared_folder);

  // int32 port = 5;
  void clear_port();
  static const int kPortFieldNumber = 5;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:y3d.YMasterServer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::y3d::YMainWorker > main_workers_;
  ::google::protobuf::internal::ArenaStringPtr mname_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::internal::ArenaStringPtr shared_folder_;
  ::google::protobuf::int32 port_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_y3d_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// YPoint3

// float x = 1;
inline void YPoint3::clear_x() {
  x_ = 0;
}
inline float YPoint3::x() const {
  // @@protoc_insertion_point(field_get:y3d.YPoint3.x)
  return x_;
}
inline void YPoint3::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:y3d.YPoint3.x)
}

// float y = 2;
inline void YPoint3::clear_y() {
  y_ = 0;
}
inline float YPoint3::y() const {
  // @@protoc_insertion_point(field_get:y3d.YPoint3.y)
  return y_;
}
inline void YPoint3::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:y3d.YPoint3.y)
}

// float z = 3;
inline void YPoint3::clear_z() {
  z_ = 0;
}
inline float YPoint3::z() const {
  // @@protoc_insertion_point(field_get:y3d.YPoint3.z)
  return z_;
}
inline void YPoint3::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:y3d.YPoint3.z)
}

// -------------------------------------------------------------------

// YBox3

// .y3d.YPoint3 pmin = 1;
inline bool YBox3::has_pmin() const {
  return this != internal_default_instance() && pmin_ != NULL;
}
inline void YBox3::clear_pmin() {
  if (GetArenaNoVirtual() == NULL && pmin_ != NULL) delete pmin_;
  pmin_ = NULL;
}
inline const ::y3d::YPoint3& YBox3::pmin() const {
  // @@protoc_insertion_point(field_get:y3d.YBox3.pmin)
  return pmin_ != NULL ? *pmin_
                         : *::y3d::YPoint3::internal_default_instance();
}
inline ::y3d::YPoint3* YBox3::mutable_pmin() {
  
  if (pmin_ == NULL) {
    pmin_ = new ::y3d::YPoint3;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YBox3.pmin)
  return pmin_;
}
inline ::y3d::YPoint3* YBox3::release_pmin() {
  // @@protoc_insertion_point(field_release:y3d.YBox3.pmin)
  
  ::y3d::YPoint3* temp = pmin_;
  pmin_ = NULL;
  return temp;
}
inline void YBox3::set_allocated_pmin(::y3d::YPoint3* pmin) {
  delete pmin_;
  pmin_ = pmin;
  if (pmin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YBox3.pmin)
}

// .y3d.YPoint3 pmax = 2;
inline bool YBox3::has_pmax() const {
  return this != internal_default_instance() && pmax_ != NULL;
}
inline void YBox3::clear_pmax() {
  if (GetArenaNoVirtual() == NULL && pmax_ != NULL) delete pmax_;
  pmax_ = NULL;
}
inline const ::y3d::YPoint3& YBox3::pmax() const {
  // @@protoc_insertion_point(field_get:y3d.YBox3.pmax)
  return pmax_ != NULL ? *pmax_
                         : *::y3d::YPoint3::internal_default_instance();
}
inline ::y3d::YPoint3* YBox3::mutable_pmax() {
  
  if (pmax_ == NULL) {
    pmax_ = new ::y3d::YPoint3;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YBox3.pmax)
  return pmax_;
}
inline ::y3d::YPoint3* YBox3::release_pmax() {
  // @@protoc_insertion_point(field_release:y3d.YBox3.pmax)
  
  ::y3d::YPoint3* temp = pmax_;
  pmax_ = NULL;
  return temp;
}
inline void YBox3::set_allocated_pmax(::y3d::YPoint3* pmax) {
  delete pmax_;
  pmax_ = pmax;
  if (pmax) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YBox3.pmax)
}

// -------------------------------------------------------------------

// YResource

// string rid = 1;
inline void YResource::clear_rid() {
  rid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YResource::rid() const {
  // @@protoc_insertion_point(field_get:y3d.YResource.rid)
  return rid_.GetNoArena();
}
inline void YResource::set_rid(const ::std::string& value) {
  
  rid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YResource.rid)
}
#if LANG_CXX11
inline void YResource::set_rid(::std::string&& value) {
  
  rid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.YResource.rid)
}
#endif
inline void YResource::set_rid(const char* value) {
  
  rid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YResource.rid)
}
inline void YResource::set_rid(const char* value, size_t size) {
  
  rid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YResource.rid)
}
inline ::std::string* YResource::mutable_rid() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YResource.rid)
  return rid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YResource::release_rid() {
  // @@protoc_insertion_point(field_release:y3d.YResource.rid)
  
  return rid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YResource::set_allocated_rid(::std::string* rid) {
  if (rid != NULL) {
    
  } else {
    
  }
  rid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rid);
  // @@protoc_insertion_point(field_set_allocated:y3d.YResource.rid)
}

// .y3d.YResource.ResourceType rtype = 2;
inline void YResource::clear_rtype() {
  rtype_ = 0;
}
inline ::y3d::YResource_ResourceType YResource::rtype() const {
  // @@protoc_insertion_point(field_get:y3d.YResource.rtype)
  return static_cast< ::y3d::YResource_ResourceType >(rtype_);
}
inline void YResource::set_rtype(::y3d::YResource_ResourceType value) {
  
  rtype_ = value;
  // @@protoc_insertion_point(field_set:y3d.YResource.rtype)
}

// string link = 3;
inline void YResource::clear_link() {
  link_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YResource::link() const {
  // @@protoc_insertion_point(field_get:y3d.YResource.link)
  return link_.GetNoArena();
}
inline void YResource::set_link(const ::std::string& value) {
  
  link_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YResource.link)
}
#if LANG_CXX11
inline void YResource::set_link(::std::string&& value) {
  
  link_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.YResource.link)
}
#endif
inline void YResource::set_link(const char* value) {
  
  link_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YResource.link)
}
inline void YResource::set_link(const char* value, size_t size) {
  
  link_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YResource.link)
}
inline ::std::string* YResource::mutable_link() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YResource.link)
  return link_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YResource::release_link() {
  // @@protoc_insertion_point(field_release:y3d.YResource.link)
  
  return link_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YResource::set_allocated_link(::std::string* link) {
  if (link != NULL) {
    
  } else {
    
  }
  link_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), link);
  // @@protoc_insertion_point(field_set_allocated:y3d.YResource.link)
}

// -------------------------------------------------------------------

// YLight

// repeated float diffuse = 3;
inline int YLight::diffuse_size() const {
  return diffuse_.size();
}
inline void YLight::clear_diffuse() {
  diffuse_.Clear();
}
inline float YLight::diffuse(int index) const {
  // @@protoc_insertion_point(field_get:y3d.YLight.diffuse)
  return diffuse_.Get(index);
}
inline void YLight::set_diffuse(int index, float value) {
  diffuse_.Set(index, value);
  // @@protoc_insertion_point(field_set:y3d.YLight.diffuse)
}
inline void YLight::add_diffuse(float value) {
  diffuse_.Add(value);
  // @@protoc_insertion_point(field_add:y3d.YLight.diffuse)
}
inline const ::google::protobuf::RepeatedField< float >&
YLight::diffuse() const {
  // @@protoc_insertion_point(field_list:y3d.YLight.diffuse)
  return diffuse_;
}
inline ::google::protobuf::RepeatedField< float >*
YLight::mutable_diffuse() {
  // @@protoc_insertion_point(field_mutable_list:y3d.YLight.diffuse)
  return &diffuse_;
}

// repeated float specular = 4;
inline int YLight::specular_size() const {
  return specular_.size();
}
inline void YLight::clear_specular() {
  specular_.Clear();
}
inline float YLight::specular(int index) const {
  // @@protoc_insertion_point(field_get:y3d.YLight.specular)
  return specular_.Get(index);
}
inline void YLight::set_specular(int index, float value) {
  specular_.Set(index, value);
  // @@protoc_insertion_point(field_set:y3d.YLight.specular)
}
inline void YLight::add_specular(float value) {
  specular_.Add(value);
  // @@protoc_insertion_point(field_add:y3d.YLight.specular)
}
inline const ::google::protobuf::RepeatedField< float >&
YLight::specular() const {
  // @@protoc_insertion_point(field_list:y3d.YLight.specular)
  return specular_;
}
inline ::google::protobuf::RepeatedField< float >*
YLight::mutable_specular() {
  // @@protoc_insertion_point(field_mutable_list:y3d.YLight.specular)
  return &specular_;
}

// float intensity = 5;
inline void YLight::clear_intensity() {
  intensity_ = 0;
}
inline float YLight::intensity() const {
  // @@protoc_insertion_point(field_get:y3d.YLight.intensity)
  return intensity_;
}
inline void YLight::set_intensity(float value) {
  
  intensity_ = value;
  // @@protoc_insertion_point(field_set:y3d.YLight.intensity)
}

// float range = 6;
inline void YLight::clear_range() {
  range_ = 0;
}
inline float YLight::range() const {
  // @@protoc_insertion_point(field_get:y3d.YLight.range)
  return range_;
}
inline void YLight::set_range(float value) {
  
  range_ = value;
  // @@protoc_insertion_point(field_set:y3d.YLight.range)
}

// float angle = 7;
inline void YLight::clear_angle() {
  angle_ = 0;
}
inline float YLight::angle() const {
  // @@protoc_insertion_point(field_get:y3d.YLight.angle)
  return angle_;
}
inline void YLight::set_angle(float value) {
  
  angle_ = value;
  // @@protoc_insertion_point(field_set:y3d.YLight.angle)
}

// float exponent = 8;
inline void YLight::clear_exponent() {
  exponent_ = 0;
}
inline float YLight::exponent() const {
  // @@protoc_insertion_point(field_get:y3d.YLight.exponent)
  return exponent_;
}
inline void YLight::set_exponent(float value) {
  
  exponent_ = value;
  // @@protoc_insertion_point(field_set:y3d.YLight.exponent)
}

// repeated string excludedMeshesIds = 9;
inline int YLight::excludedmeshesids_size() const {
  return excludedmeshesids_.size();
}
inline void YLight::clear_excludedmeshesids() {
  excludedmeshesids_.Clear();
}
inline const ::std::string& YLight::excludedmeshesids(int index) const {
  // @@protoc_insertion_point(field_get:y3d.YLight.excludedMeshesIds)
  return excludedmeshesids_.Get(index);
}
inline ::std::string* YLight::mutable_excludedmeshesids(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.YLight.excludedMeshesIds)
  return excludedmeshesids_.Mutable(index);
}
inline void YLight::set_excludedmeshesids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:y3d.YLight.excludedMeshesIds)
  excludedmeshesids_.Mutable(index)->assign(value);
}
inline void YLight::set_excludedmeshesids(int index, const char* value) {
  excludedmeshesids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:y3d.YLight.excludedMeshesIds)
}
inline void YLight::set_excludedmeshesids(int index, const char* value, size_t size) {
  excludedmeshesids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:y3d.YLight.excludedMeshesIds)
}
inline ::std::string* YLight::add_excludedmeshesids() {
  // @@protoc_insertion_point(field_add_mutable:y3d.YLight.excludedMeshesIds)
  return excludedmeshesids_.Add();
}
inline void YLight::add_excludedmeshesids(const ::std::string& value) {
  excludedmeshesids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:y3d.YLight.excludedMeshesIds)
}
inline void YLight::add_excludedmeshesids(const char* value) {
  excludedmeshesids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:y3d.YLight.excludedMeshesIds)
}
inline void YLight::add_excludedmeshesids(const char* value, size_t size) {
  excludedmeshesids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:y3d.YLight.excludedMeshesIds)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
YLight::excludedmeshesids() const {
  // @@protoc_insertion_point(field_list:y3d.YLight.excludedMeshesIds)
  return excludedmeshesids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
YLight::mutable_excludedmeshesids() {
  // @@protoc_insertion_point(field_mutable_list:y3d.YLight.excludedMeshesIds)
  return &excludedmeshesids_;
}

// repeated string includedOnlyMeshesIds = 10;
inline int YLight::includedonlymeshesids_size() const {
  return includedonlymeshesids_.size();
}
inline void YLight::clear_includedonlymeshesids() {
  includedonlymeshesids_.Clear();
}
inline const ::std::string& YLight::includedonlymeshesids(int index) const {
  // @@protoc_insertion_point(field_get:y3d.YLight.includedOnlyMeshesIds)
  return includedonlymeshesids_.Get(index);
}
inline ::std::string* YLight::mutable_includedonlymeshesids(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.YLight.includedOnlyMeshesIds)
  return includedonlymeshesids_.Mutable(index);
}
inline void YLight::set_includedonlymeshesids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:y3d.YLight.includedOnlyMeshesIds)
  includedonlymeshesids_.Mutable(index)->assign(value);
}
inline void YLight::set_includedonlymeshesids(int index, const char* value) {
  includedonlymeshesids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:y3d.YLight.includedOnlyMeshesIds)
}
inline void YLight::set_includedonlymeshesids(int index, const char* value, size_t size) {
  includedonlymeshesids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:y3d.YLight.includedOnlyMeshesIds)
}
inline ::std::string* YLight::add_includedonlymeshesids() {
  // @@protoc_insertion_point(field_add_mutable:y3d.YLight.includedOnlyMeshesIds)
  return includedonlymeshesids_.Add();
}
inline void YLight::add_includedonlymeshesids(const ::std::string& value) {
  includedonlymeshesids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:y3d.YLight.includedOnlyMeshesIds)
}
inline void YLight::add_includedonlymeshesids(const char* value) {
  includedonlymeshesids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:y3d.YLight.includedOnlyMeshesIds)
}
inline void YLight::add_includedonlymeshesids(const char* value, size_t size) {
  includedonlymeshesids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:y3d.YLight.includedOnlyMeshesIds)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
YLight::includedonlymeshesids() const {
  // @@protoc_insertion_point(field_list:y3d.YLight.includedOnlyMeshesIds)
  return includedonlymeshesids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
YLight::mutable_includedonlymeshesids() {
  // @@protoc_insertion_point(field_mutable_list:y3d.YLight.includedOnlyMeshesIds)
  return &includedonlymeshesids_;
}

// -------------------------------------------------------------------

// YCamera

// repeated float rotation = 3;
inline int YCamera::rotation_size() const {
  return rotation_.size();
}
inline void YCamera::clear_rotation() {
  rotation_.Clear();
}
inline float YCamera::rotation(int index) const {
  // @@protoc_insertion_point(field_get:y3d.YCamera.rotation)
  return rotation_.Get(index);
}
inline void YCamera::set_rotation(int index, float value) {
  rotation_.Set(index, value);
  // @@protoc_insertion_point(field_set:y3d.YCamera.rotation)
}
inline void YCamera::add_rotation(float value) {
  rotation_.Add(value);
  // @@protoc_insertion_point(field_add:y3d.YCamera.rotation)
}
inline const ::google::protobuf::RepeatedField< float >&
YCamera::rotation() const {
  // @@protoc_insertion_point(field_list:y3d.YCamera.rotation)
  return rotation_;
}
inline ::google::protobuf::RepeatedField< float >*
YCamera::mutable_rotation() {
  // @@protoc_insertion_point(field_mutable_list:y3d.YCamera.rotation)
  return &rotation_;
}

// repeated float target = 4;
inline int YCamera::target_size() const {
  return target_.size();
}
inline void YCamera::clear_target() {
  target_.Clear();
}
inline float YCamera::target(int index) const {
  // @@protoc_insertion_point(field_get:y3d.YCamera.target)
  return target_.Get(index);
}
inline void YCamera::set_target(int index, float value) {
  target_.Set(index, value);
  // @@protoc_insertion_point(field_set:y3d.YCamera.target)
}
inline void YCamera::add_target(float value) {
  target_.Add(value);
  // @@protoc_insertion_point(field_add:y3d.YCamera.target)
}
inline const ::google::protobuf::RepeatedField< float >&
YCamera::target() const {
  // @@protoc_insertion_point(field_list:y3d.YCamera.target)
  return target_;
}
inline ::google::protobuf::RepeatedField< float >*
YCamera::mutable_target() {
  // @@protoc_insertion_point(field_mutable_list:y3d.YCamera.target)
  return &target_;
}

// float fov = 5;
inline void YCamera::clear_fov() {
  fov_ = 0;
}
inline float YCamera::fov() const {
  // @@protoc_insertion_point(field_get:y3d.YCamera.fov)
  return fov_;
}
inline void YCamera::set_fov(float value) {
  
  fov_ = value;
  // @@protoc_insertion_point(field_set:y3d.YCamera.fov)
}

// -------------------------------------------------------------------

// YMesh

// int32 num_faces = 1;
inline void YMesh::clear_num_faces() {
  num_faces_ = 0;
}
inline ::google::protobuf::int32 YMesh::num_faces() const {
  // @@protoc_insertion_point(field_get:y3d.YMesh.num_faces)
  return num_faces_;
}
inline void YMesh::set_num_faces(::google::protobuf::int32 value) {
  
  num_faces_ = value;
  // @@protoc_insertion_point(field_set:y3d.YMesh.num_faces)
}

// .y3d.YBox3 bbox = 2;
inline bool YMesh::has_bbox() const {
  return this != internal_default_instance() && bbox_ != NULL;
}
inline void YMesh::clear_bbox() {
  if (GetArenaNoVirtual() == NULL && bbox_ != NULL) delete bbox_;
  bbox_ = NULL;
}
inline const ::y3d::YBox3& YMesh::bbox() const {
  // @@protoc_insertion_point(field_get:y3d.YMesh.bbox)
  return bbox_ != NULL ? *bbox_
                         : *::y3d::YBox3::internal_default_instance();
}
inline ::y3d::YBox3* YMesh::mutable_bbox() {
  
  if (bbox_ == NULL) {
    bbox_ = new ::y3d::YBox3;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YMesh.bbox)
  return bbox_;
}
inline ::y3d::YBox3* YMesh::release_bbox() {
  // @@protoc_insertion_point(field_release:y3d.YMesh.bbox)
  
  ::y3d::YBox3* temp = bbox_;
  bbox_ = NULL;
  return temp;
}
inline void YMesh::set_allocated_bbox(::y3d::YBox3* bbox) {
  delete bbox_;
  bbox_ = bbox;
  if (bbox) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YMesh.bbox)
}

// .y3d.YResource res = 3;
inline bool YMesh::has_res() const {
  return this != internal_default_instance() && res_ != NULL;
}
inline void YMesh::clear_res() {
  if (GetArenaNoVirtual() == NULL && res_ != NULL) delete res_;
  res_ = NULL;
}
inline const ::y3d::YResource& YMesh::res() const {
  // @@protoc_insertion_point(field_get:y3d.YMesh.res)
  return res_ != NULL ? *res_
                         : *::y3d::YResource::internal_default_instance();
}
inline ::y3d::YResource* YMesh::mutable_res() {
  
  if (res_ == NULL) {
    res_ = new ::y3d::YResource;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YMesh.res)
  return res_;
}
inline ::y3d::YResource* YMesh::release_res() {
  // @@protoc_insertion_point(field_release:y3d.YMesh.res)
  
  ::y3d::YResource* temp = res_;
  res_ = NULL;
  return temp;
}
inline void YMesh::set_allocated_res(::y3d::YResource* res) {
  delete res_;
  res_ = res;
  if (res) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YMesh.res)
}

// .y3d.YMesh.XrefStatus xstatus = 5;
inline void YMesh::clear_xstatus() {
  xstatus_ = 0;
}
inline ::y3d::YMesh_XrefStatus YMesh::xstatus() const {
  // @@protoc_insertion_point(field_get:y3d.YMesh.xstatus)
  return static_cast< ::y3d::YMesh_XrefStatus >(xstatus_);
}
inline void YMesh::set_xstatus(::y3d::YMesh_XrefStatus value) {
  
  xstatus_ = value;
  // @@protoc_insertion_point(field_set:y3d.YMesh.xstatus)
}

// .y3d.YMesh.MeshType mtype = 6;
inline void YMesh::clear_mtype() {
  mtype_ = 0;
}
inline ::y3d::YMesh_MeshType YMesh::mtype() const {
  // @@protoc_insertion_point(field_get:y3d.YMesh.mtype)
  return static_cast< ::y3d::YMesh_MeshType >(mtype_);
}
inline void YMesh::set_mtype(::y3d::YMesh_MeshType value) {
  
  mtype_ = value;
  // @@protoc_insertion_point(field_set:y3d.YMesh.mtype)
}

// string vername = 7;
inline void YMesh::clear_vername() {
  vername_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YMesh::vername() const {
  // @@protoc_insertion_point(field_get:y3d.YMesh.vername)
  return vername_.GetNoArena();
}
inline void YMesh::set_vername(const ::std::string& value) {
  
  vername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YMesh.vername)
}
#if LANG_CXX11
inline void YMesh::set_vername(::std::string&& value) {
  
  vername_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.YMesh.vername)
}
#endif
inline void YMesh::set_vername(const char* value) {
  
  vername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YMesh.vername)
}
inline void YMesh::set_vername(const char* value, size_t size) {
  
  vername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YMesh.vername)
}
inline ::std::string* YMesh::mutable_vername() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YMesh.vername)
  return vername_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YMesh::release_vername() {
  // @@protoc_insertion_point(field_release:y3d.YMesh.vername)
  
  return vername_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YMesh::set_allocated_vername(::std::string* vername) {
  if (vername != NULL) {
    
  } else {
    
  }
  vername_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vername);
  // @@protoc_insertion_point(field_set_allocated:y3d.YMesh.vername)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// YObject

// string name = 1;
inline void YObject::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YObject::name() const {
  // @@protoc_insertion_point(field_get:y3d.YObject.name)
  return name_.GetNoArena();
}
inline void YObject::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YObject.name)
}
#if LANG_CXX11
inline void YObject::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.YObject.name)
}
#endif
inline void YObject::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YObject.name)
}
inline void YObject::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YObject.name)
}
inline ::std::string* YObject::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YObject.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YObject::release_name() {
  // @@protoc_insertion_point(field_release:y3d.YObject.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YObject::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:y3d.YObject.name)
}

// .y3d.YPoint3 pos = 3;
inline bool YObject::has_pos() const {
  return this != internal_default_instance() && pos_ != NULL;
}
inline void YObject::clear_pos() {
  if (GetArenaNoVirtual() == NULL && pos_ != NULL) delete pos_;
  pos_ = NULL;
}
inline const ::y3d::YPoint3& YObject::pos() const {
  // @@protoc_insertion_point(field_get:y3d.YObject.pos)
  return pos_ != NULL ? *pos_
                         : *::y3d::YPoint3::internal_default_instance();
}
inline ::y3d::YPoint3* YObject::mutable_pos() {
  
  if (pos_ == NULL) {
    pos_ = new ::y3d::YPoint3;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YObject.pos)
  return pos_;
}
inline ::y3d::YPoint3* YObject::release_pos() {
  // @@protoc_insertion_point(field_release:y3d.YObject.pos)
  
  ::y3d::YPoint3* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void YObject::set_allocated_pos(::y3d::YPoint3* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YObject.pos)
}

// map<string, .google.protobuf.Any> extra = 5;
inline int YObject::extra_size() const {
  return extra_.size();
}
inline void YObject::clear_extra() {
  extra_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::google::protobuf::Any >&
YObject::extra() const {
  // @@protoc_insertion_point(field_map:y3d.YObject.extra)
  return extra_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::google::protobuf::Any >*
YObject::mutable_extra() {
  // @@protoc_insertion_point(field_mutable_map:y3d.YObject.extra)
  return extra_.MutableMap();
}

// .y3d.ObjectType otype = 6;
inline void YObject::clear_otype() {
  otype_ = 0;
}
inline ::y3d::ObjectType YObject::otype() const {
  // @@protoc_insertion_point(field_get:y3d.YObject.otype)
  return static_cast< ::y3d::ObjectType >(otype_);
}
inline void YObject::set_otype(::y3d::ObjectType value) {
  
  otype_ = value;
  // @@protoc_insertion_point(field_set:y3d.YObject.otype)
}

// repeated string tags = 7;
inline int YObject::tags_size() const {
  return tags_.size();
}
inline void YObject::clear_tags() {
  tags_.Clear();
}
inline const ::std::string& YObject::tags(int index) const {
  // @@protoc_insertion_point(field_get:y3d.YObject.tags)
  return tags_.Get(index);
}
inline ::std::string* YObject::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.YObject.tags)
  return tags_.Mutable(index);
}
inline void YObject::set_tags(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:y3d.YObject.tags)
  tags_.Mutable(index)->assign(value);
}
inline void YObject::set_tags(int index, const char* value) {
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:y3d.YObject.tags)
}
inline void YObject::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:y3d.YObject.tags)
}
inline ::std::string* YObject::add_tags() {
  // @@protoc_insertion_point(field_add_mutable:y3d.YObject.tags)
  return tags_.Add();
}
inline void YObject::add_tags(const ::std::string& value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:y3d.YObject.tags)
}
inline void YObject::add_tags(const char* value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:y3d.YObject.tags)
}
inline void YObject::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:y3d.YObject.tags)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
YObject::tags() const {
  // @@protoc_insertion_point(field_list:y3d.YObject.tags)
  return tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
YObject::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:y3d.YObject.tags)
  return &tags_;
}

// int32 cate_id = 8;
inline void YObject::clear_cate_id() {
  cate_id_ = 0;
}
inline ::google::protobuf::int32 YObject::cate_id() const {
  // @@protoc_insertion_point(field_get:y3d.YObject.cate_id)
  return cate_id_;
}
inline void YObject::set_cate_id(::google::protobuf::int32 value) {
  
  cate_id_ = value;
  // @@protoc_insertion_point(field_set:y3d.YObject.cate_id)
}

// .y3d.YLight light = 10;
inline bool YObject::has_light() const {
  return data_case() == kLight;
}
inline void YObject::set_has_light() {
  _oneof_case_[0] = kLight;
}
inline void YObject::clear_light() {
  if (has_light()) {
    delete data_.light_;
    clear_has_data();
  }
}
inline  const ::y3d::YLight& YObject::light() const {
  // @@protoc_insertion_point(field_get:y3d.YObject.light)
  return has_light()
      ? *data_.light_
      : ::y3d::YLight::default_instance();
}
inline ::y3d::YLight* YObject::mutable_light() {
  if (!has_light()) {
    clear_data();
    set_has_light();
    data_.light_ = new ::y3d::YLight;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YObject.light)
  return data_.light_;
}
inline ::y3d::YLight* YObject::release_light() {
  // @@protoc_insertion_point(field_release:y3d.YObject.light)
  if (has_light()) {
    clear_has_data();
    ::y3d::YLight* temp = data_.light_;
    data_.light_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void YObject::set_allocated_light(::y3d::YLight* light) {
  clear_data();
  if (light) {
    set_has_light();
    data_.light_ = light;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YObject.light)
}

// .y3d.YCamera camera = 11;
inline bool YObject::has_camera() const {
  return data_case() == kCamera;
}
inline void YObject::set_has_camera() {
  _oneof_case_[0] = kCamera;
}
inline void YObject::clear_camera() {
  if (has_camera()) {
    delete data_.camera_;
    clear_has_data();
  }
}
inline  const ::y3d::YCamera& YObject::camera() const {
  // @@protoc_insertion_point(field_get:y3d.YObject.camera)
  return has_camera()
      ? *data_.camera_
      : ::y3d::YCamera::default_instance();
}
inline ::y3d::YCamera* YObject::mutable_camera() {
  if (!has_camera()) {
    clear_data();
    set_has_camera();
    data_.camera_ = new ::y3d::YCamera;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YObject.camera)
  return data_.camera_;
}
inline ::y3d::YCamera* YObject::release_camera() {
  // @@protoc_insertion_point(field_release:y3d.YObject.camera)
  if (has_camera()) {
    clear_has_data();
    ::y3d::YCamera* temp = data_.camera_;
    data_.camera_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void YObject::set_allocated_camera(::y3d::YCamera* camera) {
  clear_data();
  if (camera) {
    set_has_camera();
    data_.camera_ = camera;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YObject.camera)
}

// .y3d.YMesh mesh = 12;
inline bool YObject::has_mesh() const {
  return data_case() == kMesh;
}
inline void YObject::set_has_mesh() {
  _oneof_case_[0] = kMesh;
}
inline void YObject::clear_mesh() {
  if (has_mesh()) {
    delete data_.mesh_;
    clear_has_data();
  }
}
inline  const ::y3d::YMesh& YObject::mesh() const {
  // @@protoc_insertion_point(field_get:y3d.YObject.mesh)
  return has_mesh()
      ? *data_.mesh_
      : ::y3d::YMesh::default_instance();
}
inline ::y3d::YMesh* YObject::mutable_mesh() {
  if (!has_mesh()) {
    clear_data();
    set_has_mesh();
    data_.mesh_ = new ::y3d::YMesh;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YObject.mesh)
  return data_.mesh_;
}
inline ::y3d::YMesh* YObject::release_mesh() {
  // @@protoc_insertion_point(field_release:y3d.YObject.mesh)
  if (has_mesh()) {
    clear_has_data();
    ::y3d::YMesh* temp = data_.mesh_;
    data_.mesh_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void YObject::set_allocated_mesh(::y3d::YMesh* mesh) {
  clear_data();
  if (mesh) {
    set_has_mesh();
    data_.mesh_ = mesh;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YObject.mesh)
}

// .y3d.TestObject ver_obj = 13;
inline bool YObject::has_ver_obj() const {
  return this != internal_default_instance() && ver_obj_ != NULL;
}
inline void YObject::clear_ver_obj() {
  if (GetArenaNoVirtual() == NULL && ver_obj_ != NULL) delete ver_obj_;
  ver_obj_ = NULL;
}
inline const ::y3d::TestObject& YObject::ver_obj() const {
  // @@protoc_insertion_point(field_get:y3d.YObject.ver_obj)
  return ver_obj_ != NULL ? *ver_obj_
                         : *::y3d::TestObject::internal_default_instance();
}
inline ::y3d::TestObject* YObject::mutable_ver_obj() {
  
  if (ver_obj_ == NULL) {
    ver_obj_ = new ::y3d::TestObject;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YObject.ver_obj)
  return ver_obj_;
}
inline ::y3d::TestObject* YObject::release_ver_obj() {
  // @@protoc_insertion_point(field_release:y3d.YObject.ver_obj)
  
  ::y3d::TestObject* temp = ver_obj_;
  ver_obj_ = NULL;
  return temp;
}
inline void YObject::set_allocated_ver_obj(::y3d::TestObject* ver_obj) {
  delete ver_obj_;
  ver_obj_ = ver_obj;
  if (ver_obj) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YObject.ver_obj)
}

inline bool YObject::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void YObject::clear_has_data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline YObject::DataCase YObject::data_case() const {
  return YObject::DataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// YArea

// string name = 1;
inline void YArea::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YArea::name() const {
  // @@protoc_insertion_point(field_get:y3d.YArea.name)
  return name_.GetNoArena();
}
inline void YArea::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YArea.name)
}
#if LANG_CXX11
inline void YArea::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.YArea.name)
}
#endif
inline void YArea::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YArea.name)
}
inline void YArea::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YArea.name)
}
inline ::std::string* YArea::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YArea.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YArea::release_name() {
  // @@protoc_insertion_point(field_release:y3d.YArea.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YArea::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:y3d.YArea.name)
}

// repeated .y3d.YGroup groups = 2;
inline int YArea::groups_size() const {
  return groups_.size();
}
inline void YArea::clear_groups() {
  groups_.Clear();
}
inline const ::y3d::YGroup& YArea::groups(int index) const {
  // @@protoc_insertion_point(field_get:y3d.YArea.groups)
  return groups_.Get(index);
}
inline ::y3d::YGroup* YArea::mutable_groups(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.YArea.groups)
  return groups_.Mutable(index);
}
inline ::y3d::YGroup* YArea::add_groups() {
  // @@protoc_insertion_point(field_add:y3d.YArea.groups)
  return groups_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::y3d::YGroup >*
YArea::mutable_groups() {
  // @@protoc_insertion_point(field_mutable_list:y3d.YArea.groups)
  return &groups_;
}
inline const ::google::protobuf::RepeatedPtrField< ::y3d::YGroup >&
YArea::groups() const {
  // @@protoc_insertion_point(field_list:y3d.YArea.groups)
  return groups_;
}

// repeated .y3d.YObject objs = 3;
inline int YArea::objs_size() const {
  return objs_.size();
}
inline void YArea::clear_objs() {
  objs_.Clear();
}
inline const ::y3d::YObject& YArea::objs(int index) const {
  // @@protoc_insertion_point(field_get:y3d.YArea.objs)
  return objs_.Get(index);
}
inline ::y3d::YObject* YArea::mutable_objs(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.YArea.objs)
  return objs_.Mutable(index);
}
inline ::y3d::YObject* YArea::add_objs() {
  // @@protoc_insertion_point(field_add:y3d.YArea.objs)
  return objs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::y3d::YObject >*
YArea::mutable_objs() {
  // @@protoc_insertion_point(field_mutable_list:y3d.YArea.objs)
  return &objs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::y3d::YObject >&
YArea::objs() const {
  // @@protoc_insertion_point(field_list:y3d.YArea.objs)
  return objs_;
}

// map<string, .y3d.YGroupVer> gvers = 6;
inline int YArea::gvers_size() const {
  return gvers_.size();
}
inline void YArea::clear_gvers() {
  gvers_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::y3d::YGroupVer >&
YArea::gvers() const {
  // @@protoc_insertion_point(field_map:y3d.YArea.gvers)
  return gvers_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::y3d::YGroupVer >*
YArea::mutable_gvers() {
  // @@protoc_insertion_point(field_mutable_map:y3d.YArea.gvers)
  return gvers_.MutableMap();
}

// -------------------------------------------------------------------

// YAreaList

// repeated .y3d.YArea areas = 1;
inline int YAreaList::areas_size() const {
  return areas_.size();
}
inline void YAreaList::clear_areas() {
  areas_.Clear();
}
inline const ::y3d::YArea& YAreaList::areas(int index) const {
  // @@protoc_insertion_point(field_get:y3d.YAreaList.areas)
  return areas_.Get(index);
}
inline ::y3d::YArea* YAreaList::mutable_areas(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.YAreaList.areas)
  return areas_.Mutable(index);
}
inline ::y3d::YArea* YAreaList::add_areas() {
  // @@protoc_insertion_point(field_add:y3d.YAreaList.areas)
  return areas_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::y3d::YArea >*
YAreaList::mutable_areas() {
  // @@protoc_insertion_point(field_mutable_list:y3d.YAreaList.areas)
  return &areas_;
}
inline const ::google::protobuf::RepeatedPtrField< ::y3d::YArea >&
YAreaList::areas() const {
  // @@protoc_insertion_point(field_list:y3d.YAreaList.areas)
  return areas_;
}

// -------------------------------------------------------------------

// YLayer

// string name = 1;
inline void YLayer::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YLayer::name() const {
  // @@protoc_insertion_point(field_get:y3d.YLayer.name)
  return name_.GetNoArena();
}
inline void YLayer::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YLayer.name)
}
#if LANG_CXX11
inline void YLayer::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.YLayer.name)
}
#endif
inline void YLayer::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YLayer.name)
}
inline void YLayer::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YLayer.name)
}
inline ::std::string* YLayer::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YLayer.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YLayer::release_name() {
  // @@protoc_insertion_point(field_release:y3d.YLayer.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YLayer::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:y3d.YLayer.name)
}

// repeated .y3d.YGroup groups = 2;
inline int YLayer::groups_size() const {
  return groups_.size();
}
inline void YLayer::clear_groups() {
  groups_.Clear();
}
inline const ::y3d::YGroup& YLayer::groups(int index) const {
  // @@protoc_insertion_point(field_get:y3d.YLayer.groups)
  return groups_.Get(index);
}
inline ::y3d::YGroup* YLayer::mutable_groups(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.YLayer.groups)
  return groups_.Mutable(index);
}
inline ::y3d::YGroup* YLayer::add_groups() {
  // @@protoc_insertion_point(field_add:y3d.YLayer.groups)
  return groups_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::y3d::YGroup >*
YLayer::mutable_groups() {
  // @@protoc_insertion_point(field_mutable_list:y3d.YLayer.groups)
  return &groups_;
}
inline const ::google::protobuf::RepeatedPtrField< ::y3d::YGroup >&
YLayer::groups() const {
  // @@protoc_insertion_point(field_list:y3d.YLayer.groups)
  return groups_;
}

// -------------------------------------------------------------------

// YGroup

// string name = 1;
inline void YGroup::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YGroup::name() const {
  // @@protoc_insertion_point(field_get:y3d.YGroup.name)
  return name_.GetNoArena();
}
inline void YGroup::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YGroup.name)
}
#if LANG_CXX11
inline void YGroup::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.YGroup.name)
}
#endif
inline void YGroup::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YGroup.name)
}
inline void YGroup::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YGroup.name)
}
inline ::std::string* YGroup::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YGroup.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YGroup::release_name() {
  // @@protoc_insertion_point(field_release:y3d.YGroup.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YGroup::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:y3d.YGroup.name)
}

// repeated .y3d.YObject objs = 2;
inline int YGroup::objs_size() const {
  return objs_.size();
}
inline void YGroup::clear_objs() {
  objs_.Clear();
}
inline const ::y3d::YObject& YGroup::objs(int index) const {
  // @@protoc_insertion_point(field_get:y3d.YGroup.objs)
  return objs_.Get(index);
}
inline ::y3d::YObject* YGroup::mutable_objs(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.YGroup.objs)
  return objs_.Mutable(index);
}
inline ::y3d::YObject* YGroup::add_objs() {
  // @@protoc_insertion_point(field_add:y3d.YGroup.objs)
  return objs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::y3d::YObject >*
YGroup::mutable_objs() {
  // @@protoc_insertion_point(field_mutable_list:y3d.YGroup.objs)
  return &objs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::y3d::YObject >&
YGroup::objs() const {
  // @@protoc_insertion_point(field_list:y3d.YGroup.objs)
  return objs_;
}

// repeated .y3d.YGroup children = 3;
inline int YGroup::children_size() const {
  return children_.size();
}
inline void YGroup::clear_children() {
  children_.Clear();
}
inline const ::y3d::YGroup& YGroup::children(int index) const {
  // @@protoc_insertion_point(field_get:y3d.YGroup.children)
  return children_.Get(index);
}
inline ::y3d::YGroup* YGroup::mutable_children(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.YGroup.children)
  return children_.Mutable(index);
}
inline ::y3d::YGroup* YGroup::add_children() {
  // @@protoc_insertion_point(field_add:y3d.YGroup.children)
  return children_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::y3d::YGroup >*
YGroup::mutable_children() {
  // @@protoc_insertion_point(field_mutable_list:y3d.YGroup.children)
  return &children_;
}
inline const ::google::protobuf::RepeatedPtrField< ::y3d::YGroup >&
YGroup::children() const {
  // @@protoc_insertion_point(field_list:y3d.YGroup.children)
  return children_;
}

// .y3d.GVerType gv_type = 4;
inline void YGroup::clear_gv_type() {
  gv_type_ = 0;
}
inline ::y3d::GVerType YGroup::gv_type() const {
  // @@protoc_insertion_point(field_get:y3d.YGroup.gv_type)
  return static_cast< ::y3d::GVerType >(gv_type_);
}
inline void YGroup::set_gv_type(::y3d::GVerType value) {
  
  gv_type_ = value;
  // @@protoc_insertion_point(field_set:y3d.YGroup.gv_type)
}

// repeated string xref = 5;
inline int YGroup::xref_size() const {
  return xref_.size();
}
inline void YGroup::clear_xref() {
  xref_.Clear();
}
inline const ::std::string& YGroup::xref(int index) const {
  // @@protoc_insertion_point(field_get:y3d.YGroup.xref)
  return xref_.Get(index);
}
inline ::std::string* YGroup::mutable_xref(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.YGroup.xref)
  return xref_.Mutable(index);
}
inline void YGroup::set_xref(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:y3d.YGroup.xref)
  xref_.Mutable(index)->assign(value);
}
inline void YGroup::set_xref(int index, const char* value) {
  xref_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:y3d.YGroup.xref)
}
inline void YGroup::set_xref(int index, const char* value, size_t size) {
  xref_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:y3d.YGroup.xref)
}
inline ::std::string* YGroup::add_xref() {
  // @@protoc_insertion_point(field_add_mutable:y3d.YGroup.xref)
  return xref_.Add();
}
inline void YGroup::add_xref(const ::std::string& value) {
  xref_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:y3d.YGroup.xref)
}
inline void YGroup::add_xref(const char* value) {
  xref_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:y3d.YGroup.xref)
}
inline void YGroup::add_xref(const char* value, size_t size) {
  xref_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:y3d.YGroup.xref)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
YGroup::xref() const {
  // @@protoc_insertion_point(field_list:y3d.YGroup.xref)
  return xref_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
YGroup::mutable_xref() {
  // @@protoc_insertion_point(field_mutable_list:y3d.YGroup.xref)
  return &xref_;
}

// -------------------------------------------------------------------

// YGroupVer

// string vname = 1;
inline void YGroupVer::clear_vname() {
  vname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YGroupVer::vname() const {
  // @@protoc_insertion_point(field_get:y3d.YGroupVer.vname)
  return vname_.GetNoArena();
}
inline void YGroupVer::set_vname(const ::std::string& value) {
  
  vname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YGroupVer.vname)
}
#if LANG_CXX11
inline void YGroupVer::set_vname(::std::string&& value) {
  
  vname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.YGroupVer.vname)
}
#endif
inline void YGroupVer::set_vname(const char* value) {
  
  vname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YGroupVer.vname)
}
inline void YGroupVer::set_vname(const char* value, size_t size) {
  
  vname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YGroupVer.vname)
}
inline ::std::string* YGroupVer::mutable_vname() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YGroupVer.vname)
  return vname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YGroupVer::release_vname() {
  // @@protoc_insertion_point(field_release:y3d.YGroupVer.vname)
  
  return vname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YGroupVer::set_allocated_vname(::std::string* vname) {
  if (vname != NULL) {
    
  } else {
    
  }
  vname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vname);
  // @@protoc_insertion_point(field_set_allocated:y3d.YGroupVer.vname)
}

// .y3d.YGroup groupData = 2;
inline bool YGroupVer::has_groupdata() const {
  return this != internal_default_instance() && groupdata_ != NULL;
}
inline void YGroupVer::clear_groupdata() {
  if (GetArenaNoVirtual() == NULL && groupdata_ != NULL) delete groupdata_;
  groupdata_ = NULL;
}
inline const ::y3d::YGroup& YGroupVer::groupdata() const {
  // @@protoc_insertion_point(field_get:y3d.YGroupVer.groupData)
  return groupdata_ != NULL ? *groupdata_
                         : *::y3d::YGroup::internal_default_instance();
}
inline ::y3d::YGroup* YGroupVer::mutable_groupdata() {
  
  if (groupdata_ == NULL) {
    groupdata_ = new ::y3d::YGroup;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YGroupVer.groupData)
  return groupdata_;
}
inline ::y3d::YGroup* YGroupVer::release_groupdata() {
  // @@protoc_insertion_point(field_release:y3d.YGroupVer.groupData)
  
  ::y3d::YGroup* temp = groupdata_;
  groupdata_ = NULL;
  return temp;
}
inline void YGroupVer::set_allocated_groupdata(::y3d::YGroup* groupdata) {
  delete groupdata_;
  groupdata_ = groupdata;
  if (groupdata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YGroupVer.groupData)
}

// int32 step = 3;
inline void YGroupVer::clear_step() {
  step_ = 0;
}
inline ::google::protobuf::int32 YGroupVer::step() const {
  // @@protoc_insertion_point(field_get:y3d.YGroupVer.step)
  return step_;
}
inline void YGroupVer::set_step(::google::protobuf::int32 value) {
  
  step_ = value;
  // @@protoc_insertion_point(field_set:y3d.YGroupVer.step)
}

// -------------------------------------------------------------------

// FilterView

// .y3d.ObjectType otype = 1;
inline void FilterView::clear_otype() {
  otype_ = 0;
}
inline ::y3d::ObjectType FilterView::otype() const {
  // @@protoc_insertion_point(field_get:y3d.FilterView.otype)
  return static_cast< ::y3d::ObjectType >(otype_);
}
inline void FilterView::set_otype(::y3d::ObjectType value) {
  
  otype_ = value;
  // @@protoc_insertion_point(field_set:y3d.FilterView.otype)
}

// int32 face_range = 2;
inline void FilterView::clear_face_range() {
  face_range_ = 0;
}
inline ::google::protobuf::int32 FilterView::face_range() const {
  // @@protoc_insertion_point(field_get:y3d.FilterView.face_range)
  return face_range_;
}
inline void FilterView::set_face_range(::google::protobuf::int32 value) {
  
  face_range_ = value;
  // @@protoc_insertion_point(field_set:y3d.FilterView.face_range)
}

// string search = 3;
inline void FilterView::clear_search() {
  search_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FilterView::search() const {
  // @@protoc_insertion_point(field_get:y3d.FilterView.search)
  return search_.GetNoArena();
}
inline void FilterView::set_search(const ::std::string& value) {
  
  search_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.FilterView.search)
}
#if LANG_CXX11
inline void FilterView::set_search(::std::string&& value) {
  
  search_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.FilterView.search)
}
#endif
inline void FilterView::set_search(const char* value) {
  
  search_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.FilterView.search)
}
inline void FilterView::set_search(const char* value, size_t size) {
  
  search_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.FilterView.search)
}
inline ::std::string* FilterView::mutable_search() {
  
  // @@protoc_insertion_point(field_mutable:y3d.FilterView.search)
  return search_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FilterView::release_search() {
  // @@protoc_insertion_point(field_release:y3d.FilterView.search)
  
  return search_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FilterView::set_allocated_search(::std::string* search) {
  if (search != NULL) {
    
  } else {
    
  }
  search_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), search);
  // @@protoc_insertion_point(field_set_allocated:y3d.FilterView.search)
}

// int32 aid = 4;
inline void FilterView::clear_aid() {
  aid_ = 0;
}
inline ::google::protobuf::int32 FilterView::aid() const {
  // @@protoc_insertion_point(field_get:y3d.FilterView.aid)
  return aid_;
}
inline void FilterView::set_aid(::google::protobuf::int32 value) {
  
  aid_ = value;
  // @@protoc_insertion_point(field_set:y3d.FilterView.aid)
}

// -------------------------------------------------------------------

// FRangeItem

// int32 f_start = 1;
inline void FRangeItem::clear_f_start() {
  f_start_ = 0;
}
inline ::google::protobuf::int32 FRangeItem::f_start() const {
  // @@protoc_insertion_point(field_get:y3d.FRangeItem.f_start)
  return f_start_;
}
inline void FRangeItem::set_f_start(::google::protobuf::int32 value) {
  
  f_start_ = value;
  // @@protoc_insertion_point(field_set:y3d.FRangeItem.f_start)
}

// int32 f_end = 2;
inline void FRangeItem::clear_f_end() {
  f_end_ = 0;
}
inline ::google::protobuf::int32 FRangeItem::f_end() const {
  // @@protoc_insertion_point(field_get:y3d.FRangeItem.f_end)
  return f_end_;
}
inline void FRangeItem::set_f_end(::google::protobuf::int32 value) {
  
  f_end_ = value;
  // @@protoc_insertion_point(field_set:y3d.FRangeItem.f_end)
}

// .y3d.YColor fr_color = 3;
inline bool FRangeItem::has_fr_color() const {
  return this != internal_default_instance() && fr_color_ != NULL;
}
inline void FRangeItem::clear_fr_color() {
  if (GetArenaNoVirtual() == NULL && fr_color_ != NULL) delete fr_color_;
  fr_color_ = NULL;
}
inline const ::y3d::YColor& FRangeItem::fr_color() const {
  // @@protoc_insertion_point(field_get:y3d.FRangeItem.fr_color)
  return fr_color_ != NULL ? *fr_color_
                         : *::y3d::YColor::internal_default_instance();
}
inline ::y3d::YColor* FRangeItem::mutable_fr_color() {
  
  if (fr_color_ == NULL) {
    fr_color_ = new ::y3d::YColor;
  }
  // @@protoc_insertion_point(field_mutable:y3d.FRangeItem.fr_color)
  return fr_color_;
}
inline ::y3d::YColor* FRangeItem::release_fr_color() {
  // @@protoc_insertion_point(field_release:y3d.FRangeItem.fr_color)
  
  ::y3d::YColor* temp = fr_color_;
  fr_color_ = NULL;
  return temp;
}
inline void FRangeItem::set_allocated_fr_color(::y3d::YColor* fr_color) {
  delete fr_color_;
  fr_color_ = fr_color;
  if (fr_color) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.FRangeItem.fr_color)
}

// float ratio = 4;
inline void FRangeItem::clear_ratio() {
  ratio_ = 0;
}
inline float FRangeItem::ratio() const {
  // @@protoc_insertion_point(field_get:y3d.FRangeItem.ratio)
  return ratio_;
}
inline void FRangeItem::set_ratio(float value) {
  
  ratio_ = value;
  // @@protoc_insertion_point(field_set:y3d.FRangeItem.ratio)
}

// bool has_xref = 5;
inline void FRangeItem::clear_has_xref() {
  has_xref_ = false;
}
inline bool FRangeItem::has_xref() const {
  // @@protoc_insertion_point(field_get:y3d.FRangeItem.has_xref)
  return has_xref_;
}
inline void FRangeItem::set_has_xref(bool value) {
  
  has_xref_ = value;
  // @@protoc_insertion_point(field_set:y3d.FRangeItem.has_xref)
}

// -------------------------------------------------------------------

// OptimizeOptions

// bool use_range = 1;
inline void OptimizeOptions::clear_use_range() {
  use_range_ = false;
}
inline bool OptimizeOptions::use_range() const {
  // @@protoc_insertion_point(field_get:y3d.OptimizeOptions.use_range)
  return use_range_;
}
inline void OptimizeOptions::set_use_range(bool value) {
  
  use_range_ = value;
  // @@protoc_insertion_point(field_set:y3d.OptimizeOptions.use_range)
}

// repeated .y3d.FRangeItem fr = 2;
inline int OptimizeOptions::fr_size() const {
  return fr_.size();
}
inline void OptimizeOptions::clear_fr() {
  fr_.Clear();
}
inline const ::y3d::FRangeItem& OptimizeOptions::fr(int index) const {
  // @@protoc_insertion_point(field_get:y3d.OptimizeOptions.fr)
  return fr_.Get(index);
}
inline ::y3d::FRangeItem* OptimizeOptions::mutable_fr(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.OptimizeOptions.fr)
  return fr_.Mutable(index);
}
inline ::y3d::FRangeItem* OptimizeOptions::add_fr() {
  // @@protoc_insertion_point(field_add:y3d.OptimizeOptions.fr)
  return fr_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::y3d::FRangeItem >*
OptimizeOptions::mutable_fr() {
  // @@protoc_insertion_point(field_mutable_list:y3d.OptimizeOptions.fr)
  return &fr_;
}
inline const ::google::protobuf::RepeatedPtrField< ::y3d::FRangeItem >&
OptimizeOptions::fr() const {
  // @@protoc_insertion_point(field_list:y3d.OptimizeOptions.fr)
  return fr_;
}

// int32 min_hpoly = 3;
inline void OptimizeOptions::clear_min_hpoly() {
  min_hpoly_ = 0;
}
inline ::google::protobuf::int32 OptimizeOptions::min_hpoly() const {
  // @@protoc_insertion_point(field_get:y3d.OptimizeOptions.min_hpoly)
  return min_hpoly_;
}
inline void OptimizeOptions::set_min_hpoly(::google::protobuf::int32 value) {
  
  min_hpoly_ = value;
  // @@protoc_insertion_point(field_set:y3d.OptimizeOptions.min_hpoly)
}

// int32 out_range_count = 4;
inline void OptimizeOptions::clear_out_range_count() {
  out_range_count_ = 0;
}
inline ::google::protobuf::int32 OptimizeOptions::out_range_count() const {
  // @@protoc_insertion_point(field_get:y3d.OptimizeOptions.out_range_count)
  return out_range_count_;
}
inline void OptimizeOptions::set_out_range_count(::google::protobuf::int32 value) {
  
  out_range_count_ = value;
  // @@protoc_insertion_point(field_set:y3d.OptimizeOptions.out_range_count)
}

// -------------------------------------------------------------------

// ResultReply

// bool error = 1;
inline void ResultReply::clear_error() {
  error_ = false;
}
inline bool ResultReply::error() const {
  // @@protoc_insertion_point(field_get:y3d.ResultReply.error)
  return error_;
}
inline void ResultReply::set_error(bool value) {
  
  error_ = value;
  // @@protoc_insertion_point(field_set:y3d.ResultReply.error)
}

// string message = 2;
inline void ResultReply::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResultReply::message() const {
  // @@protoc_insertion_point(field_get:y3d.ResultReply.message)
  return message_.GetNoArena();
}
inline void ResultReply::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.ResultReply.message)
}
#if LANG_CXX11
inline void ResultReply::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.ResultReply.message)
}
#endif
inline void ResultReply::set_message(const char* value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.ResultReply.message)
}
inline void ResultReply::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.ResultReply.message)
}
inline ::std::string* ResultReply::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:y3d.ResultReply.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResultReply::release_message() {
  // @@protoc_insertion_point(field_release:y3d.ResultReply.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResultReply::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:y3d.ResultReply.message)
}

// -------------------------------------------------------------------

// EmptyParam

// -------------------------------------------------------------------

// RenameParam

// bool use_select = 1;
inline void RenameParam::clear_use_select() {
  use_select_ = false;
}
inline bool RenameParam::use_select() const {
  // @@protoc_insertion_point(field_get:y3d.RenameParam.use_select)
  return use_select_;
}
inline void RenameParam::set_use_select(bool value) {
  
  use_select_ = value;
  // @@protoc_insertion_point(field_set:y3d.RenameParam.use_select)
}

// -------------------------------------------------------------------

// Make4TestParam

// string oname = 1;
inline void Make4TestParam::clear_oname() {
  oname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Make4TestParam::oname() const {
  // @@protoc_insertion_point(field_get:y3d.Make4TestParam.oname)
  return oname_.GetNoArena();
}
inline void Make4TestParam::set_oname(const ::std::string& value) {
  
  oname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.Make4TestParam.oname)
}
#if LANG_CXX11
inline void Make4TestParam::set_oname(::std::string&& value) {
  
  oname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.Make4TestParam.oname)
}
#endif
inline void Make4TestParam::set_oname(const char* value) {
  
  oname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.Make4TestParam.oname)
}
inline void Make4TestParam::set_oname(const char* value, size_t size) {
  
  oname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.Make4TestParam.oname)
}
inline ::std::string* Make4TestParam::mutable_oname() {
  
  // @@protoc_insertion_point(field_mutable:y3d.Make4TestParam.oname)
  return oname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Make4TestParam::release_oname() {
  // @@protoc_insertion_point(field_release:y3d.Make4TestParam.oname)
  
  return oname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Make4TestParam::set_allocated_oname(::std::string* oname) {
  if (oname != NULL) {
    
  } else {
    
  }
  oname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), oname);
  // @@protoc_insertion_point(field_set_allocated:y3d.Make4TestParam.oname)
}

// repeated .y3d.ELowpoly lowpoly = 2;
inline int Make4TestParam::lowpoly_size() const {
  return lowpoly_.size();
}
inline void Make4TestParam::clear_lowpoly() {
  lowpoly_.Clear();
}
inline const ::y3d::ELowpoly& Make4TestParam::lowpoly(int index) const {
  // @@protoc_insertion_point(field_get:y3d.Make4TestParam.lowpoly)
  return lowpoly_.Get(index);
}
inline ::y3d::ELowpoly* Make4TestParam::mutable_lowpoly(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.Make4TestParam.lowpoly)
  return lowpoly_.Mutable(index);
}
inline ::y3d::ELowpoly* Make4TestParam::add_lowpoly() {
  // @@protoc_insertion_point(field_add:y3d.Make4TestParam.lowpoly)
  return lowpoly_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::y3d::ELowpoly >*
Make4TestParam::mutable_lowpoly() {
  // @@protoc_insertion_point(field_mutable_list:y3d.Make4TestParam.lowpoly)
  return &lowpoly_;
}
inline const ::google::protobuf::RepeatedPtrField< ::y3d::ELowpoly >&
Make4TestParam::lowpoly() const {
  // @@protoc_insertion_point(field_list:y3d.Make4TestParam.lowpoly)
  return lowpoly_;
}

// -------------------------------------------------------------------

// TestOParam

// int32 id = 1;
inline void TestOParam::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 TestOParam::id() const {
  // @@protoc_insertion_point(field_get:y3d.TestOParam.id)
  return id_;
}
inline void TestOParam::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:y3d.TestOParam.id)
}

// string oname = 2;
inline void TestOParam::clear_oname() {
  oname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TestOParam::oname() const {
  // @@protoc_insertion_point(field_get:y3d.TestOParam.oname)
  return oname_.GetNoArena();
}
inline void TestOParam::set_oname(const ::std::string& value) {
  
  oname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.TestOParam.oname)
}
#if LANG_CXX11
inline void TestOParam::set_oname(::std::string&& value) {
  
  oname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.TestOParam.oname)
}
#endif
inline void TestOParam::set_oname(const char* value) {
  
  oname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.TestOParam.oname)
}
inline void TestOParam::set_oname(const char* value, size_t size) {
  
  oname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.TestOParam.oname)
}
inline ::std::string* TestOParam::mutable_oname() {
  
  // @@protoc_insertion_point(field_mutable:y3d.TestOParam.oname)
  return oname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TestOParam::release_oname() {
  // @@protoc_insertion_point(field_release:y3d.TestOParam.oname)
  
  return oname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TestOParam::set_allocated_oname(::std::string* oname) {
  if (oname != NULL) {
    
  } else {
    
  }
  oname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), oname);
  // @@protoc_insertion_point(field_set_allocated:y3d.TestOParam.oname)
}

// float low_ratio = 3;
inline void TestOParam::clear_low_ratio() {
  low_ratio_ = 0;
}
inline float TestOParam::low_ratio() const {
  // @@protoc_insertion_point(field_get:y3d.TestOParam.low_ratio)
  return low_ratio_;
}
inline void TestOParam::set_low_ratio(float value) {
  
  low_ratio_ = value;
  // @@protoc_insertion_point(field_set:y3d.TestOParam.low_ratio)
}

// -------------------------------------------------------------------

// OptimizeParam

// float ratio = 1;
inline void OptimizeParam::clear_ratio() {
  ratio_ = 0;
}
inline float OptimizeParam::ratio() const {
  // @@protoc_insertion_point(field_get:y3d.OptimizeParam.ratio)
  return ratio_;
}
inline void OptimizeParam::set_ratio(float value) {
  
  ratio_ = value;
  // @@protoc_insertion_point(field_set:y3d.OptimizeParam.ratio)
}

// -------------------------------------------------------------------

// BatchOptimizeParam

// float ratio = 1;
inline void BatchOptimizeParam::clear_ratio() {
  ratio_ = 0;
}
inline float BatchOptimizeParam::ratio() const {
  // @@protoc_insertion_point(field_get:y3d.BatchOptimizeParam.ratio)
  return ratio_;
}
inline void BatchOptimizeParam::set_ratio(float value) {
  
  ratio_ = value;
  // @@protoc_insertion_point(field_set:y3d.BatchOptimizeParam.ratio)
}

// string folder = 2;
inline void BatchOptimizeParam::clear_folder() {
  folder_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BatchOptimizeParam::folder() const {
  // @@protoc_insertion_point(field_get:y3d.BatchOptimizeParam.folder)
  return folder_.GetNoArena();
}
inline void BatchOptimizeParam::set_folder(const ::std::string& value) {
  
  folder_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.BatchOptimizeParam.folder)
}
#if LANG_CXX11
inline void BatchOptimizeParam::set_folder(::std::string&& value) {
  
  folder_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.BatchOptimizeParam.folder)
}
#endif
inline void BatchOptimizeParam::set_folder(const char* value) {
  
  folder_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.BatchOptimizeParam.folder)
}
inline void BatchOptimizeParam::set_folder(const char* value, size_t size) {
  
  folder_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.BatchOptimizeParam.folder)
}
inline ::std::string* BatchOptimizeParam::mutable_folder() {
  
  // @@protoc_insertion_point(field_mutable:y3d.BatchOptimizeParam.folder)
  return folder_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BatchOptimizeParam::release_folder() {
  // @@protoc_insertion_point(field_release:y3d.BatchOptimizeParam.folder)
  
  return folder_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BatchOptimizeParam::set_allocated_folder(::std::string* folder) {
  if (folder != NULL) {
    
  } else {
    
  }
  folder_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), folder);
  // @@protoc_insertion_point(field_set_allocated:y3d.BatchOptimizeParam.folder)
}

// string filename = 3;
inline void BatchOptimizeParam::clear_filename() {
  filename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BatchOptimizeParam::filename() const {
  // @@protoc_insertion_point(field_get:y3d.BatchOptimizeParam.filename)
  return filename_.GetNoArena();
}
inline void BatchOptimizeParam::set_filename(const ::std::string& value) {
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.BatchOptimizeParam.filename)
}
#if LANG_CXX11
inline void BatchOptimizeParam::set_filename(::std::string&& value) {
  
  filename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.BatchOptimizeParam.filename)
}
#endif
inline void BatchOptimizeParam::set_filename(const char* value) {
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.BatchOptimizeParam.filename)
}
inline void BatchOptimizeParam::set_filename(const char* value, size_t size) {
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.BatchOptimizeParam.filename)
}
inline ::std::string* BatchOptimizeParam::mutable_filename() {
  
  // @@protoc_insertion_point(field_mutable:y3d.BatchOptimizeParam.filename)
  return filename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BatchOptimizeParam::release_filename() {
  // @@protoc_insertion_point(field_release:y3d.BatchOptimizeParam.filename)
  
  return filename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BatchOptimizeParam::set_allocated_filename(::std::string* filename) {
  if (filename != NULL) {
    
  } else {
    
  }
  filename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:y3d.BatchOptimizeParam.filename)
}

// -------------------------------------------------------------------

// StringParam

// string str = 1;
inline void StringParam::clear_str() {
  str_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StringParam::str() const {
  // @@protoc_insertion_point(field_get:y3d.StringParam.str)
  return str_.GetNoArena();
}
inline void StringParam::set_str(const ::std::string& value) {
  
  str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.StringParam.str)
}
#if LANG_CXX11
inline void StringParam::set_str(::std::string&& value) {
  
  str_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.StringParam.str)
}
#endif
inline void StringParam::set_str(const char* value) {
  
  str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.StringParam.str)
}
inline void StringParam::set_str(const char* value, size_t size) {
  
  str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.StringParam.str)
}
inline ::std::string* StringParam::mutable_str() {
  
  // @@protoc_insertion_point(field_mutable:y3d.StringParam.str)
  return str_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StringParam::release_str() {
  // @@protoc_insertion_point(field_release:y3d.StringParam.str)
  
  return str_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StringParam::set_allocated_str(::std::string* str) {
  if (str != NULL) {
    
  } else {
    
  }
  str_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), str);
  // @@protoc_insertion_point(field_set_allocated:y3d.StringParam.str)
}

// -------------------------------------------------------------------

// IntParam

// int32 int_value = 1;
inline void IntParam::clear_int_value() {
  int_value_ = 0;
}
inline ::google::protobuf::int32 IntParam::int_value() const {
  // @@protoc_insertion_point(field_get:y3d.IntParam.int_value)
  return int_value_;
}
inline void IntParam::set_int_value(::google::protobuf::int32 value) {
  
  int_value_ = value;
  // @@protoc_insertion_point(field_set:y3d.IntParam.int_value)
}

// -------------------------------------------------------------------

// TestParam

// string test_name = 1;
inline void TestParam::clear_test_name() {
  test_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TestParam::test_name() const {
  // @@protoc_insertion_point(field_get:y3d.TestParam.test_name)
  return test_name_.GetNoArena();
}
inline void TestParam::set_test_name(const ::std::string& value) {
  
  test_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.TestParam.test_name)
}
#if LANG_CXX11
inline void TestParam::set_test_name(::std::string&& value) {
  
  test_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.TestParam.test_name)
}
#endif
inline void TestParam::set_test_name(const char* value) {
  
  test_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.TestParam.test_name)
}
inline void TestParam::set_test_name(const char* value, size_t size) {
  
  test_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.TestParam.test_name)
}
inline ::std::string* TestParam::mutable_test_name() {
  
  // @@protoc_insertion_point(field_mutable:y3d.TestParam.test_name)
  return test_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TestParam::release_test_name() {
  // @@protoc_insertion_point(field_release:y3d.TestParam.test_name)
  
  return test_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TestParam::set_allocated_test_name(::std::string* test_name) {
  if (test_name != NULL) {
    
  } else {
    
  }
  test_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), test_name);
  // @@protoc_insertion_point(field_set_allocated:y3d.TestParam.test_name)
}

// .google.protobuf.Any anything = 2;
inline bool TestParam::has_anything() const {
  return this != internal_default_instance() && anything_ != NULL;
}
inline void TestParam::clear_anything() {
  if (GetArenaNoVirtual() == NULL && anything_ != NULL) delete anything_;
  anything_ = NULL;
}
inline const ::google::protobuf::Any& TestParam::anything() const {
  // @@protoc_insertion_point(field_get:y3d.TestParam.anything)
  return anything_ != NULL ? *anything_
                         : *::google::protobuf::Any::internal_default_instance();
}
inline ::google::protobuf::Any* TestParam::mutable_anything() {
  
  if (anything_ == NULL) {
    anything_ = new ::google::protobuf::Any;
  }
  // @@protoc_insertion_point(field_mutable:y3d.TestParam.anything)
  return anything_;
}
inline ::google::protobuf::Any* TestParam::release_anything() {
  // @@protoc_insertion_point(field_release:y3d.TestParam.anything)
  
  ::google::protobuf::Any* temp = anything_;
  anything_ = NULL;
  return temp;
}
inline void TestParam::set_allocated_anything(::google::protobuf::Any* anything) {
  delete anything_;
  anything_ = anything;
  if (anything) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.TestParam.anything)
}

// -------------------------------------------------------------------

// WorkerParam

// int32 wid = 1;
inline bool WorkerParam::has_wid() const {
  return wtype_case() == kWid;
}
inline void WorkerParam::set_has_wid() {
  _oneof_case_[0] = kWid;
}
inline void WorkerParam::clear_wid() {
  if (has_wid()) {
    wtype_.wid_ = 0;
    clear_has_wtype();
  }
}
inline ::google::protobuf::int32 WorkerParam::wid() const {
  // @@protoc_insertion_point(field_get:y3d.WorkerParam.wid)
  if (has_wid()) {
    return wtype_.wid_;
  }
  return 0;
}
inline void WorkerParam::set_wid(::google::protobuf::int32 value) {
  if (!has_wid()) {
    clear_wtype();
    set_has_wid();
  }
  wtype_.wid_ = value;
  // @@protoc_insertion_point(field_set:y3d.WorkerParam.wid)
}

// string wname = 2;
inline bool WorkerParam::has_wname() const {
  return wtype_case() == kWname;
}
inline void WorkerParam::set_has_wname() {
  _oneof_case_[0] = kWname;
}
inline void WorkerParam::clear_wname() {
  if (has_wname()) {
    wtype_.wname_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_wtype();
  }
}
inline const ::std::string& WorkerParam::wname() const {
  // @@protoc_insertion_point(field_get:y3d.WorkerParam.wname)
  if (has_wname()) {
    return wtype_.wname_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void WorkerParam::set_wname(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:y3d.WorkerParam.wname)
  if (!has_wname()) {
    clear_wtype();
    set_has_wname();
    wtype_.wname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  wtype_.wname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.WorkerParam.wname)
}
#if LANG_CXX11
inline void WorkerParam::set_wname(::std::string&& value) {
  // @@protoc_insertion_point(field_set:y3d.WorkerParam.wname)
  if (!has_wname()) {
    clear_wtype();
    set_has_wname();
    wtype_.wname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  wtype_.wname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.WorkerParam.wname)
}
#endif
inline void WorkerParam::set_wname(const char* value) {
  if (!has_wname()) {
    clear_wtype();
    set_has_wname();
    wtype_.wname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  wtype_.wname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.WorkerParam.wname)
}
inline void WorkerParam::set_wname(const char* value, size_t size) {
  if (!has_wname()) {
    clear_wtype();
    set_has_wname();
    wtype_.wname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  wtype_.wname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.WorkerParam.wname)
}
inline ::std::string* WorkerParam::mutable_wname() {
  if (!has_wname()) {
    clear_wtype();
    set_has_wname();
    wtype_.wname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:y3d.WorkerParam.wname)
  return wtype_.wname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WorkerParam::release_wname() {
  // @@protoc_insertion_point(field_release:y3d.WorkerParam.wname)
  if (has_wname()) {
    clear_has_wtype();
    return wtype_.wname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void WorkerParam::set_allocated_wname(::std::string* wname) {
  if (!has_wname()) {
    wtype_.wname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_wtype();
  if (wname != NULL) {
    set_has_wname();
    wtype_.wname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        wname);
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.WorkerParam.wname)
}

// .y3d.YWorker worker = 3;
inline bool WorkerParam::has_worker() const {
  return wtype_case() == kWorker;
}
inline void WorkerParam::set_has_worker() {
  _oneof_case_[0] = kWorker;
}
inline void WorkerParam::clear_worker() {
  if (has_worker()) {
    delete wtype_.worker_;
    clear_has_wtype();
  }
}
inline  const ::y3d::YWorker& WorkerParam::worker() const {
  // @@protoc_insertion_point(field_get:y3d.WorkerParam.worker)
  return has_worker()
      ? *wtype_.worker_
      : ::y3d::YWorker::default_instance();
}
inline ::y3d::YWorker* WorkerParam::mutable_worker() {
  if (!has_worker()) {
    clear_wtype();
    set_has_worker();
    wtype_.worker_ = new ::y3d::YWorker;
  }
  // @@protoc_insertion_point(field_mutable:y3d.WorkerParam.worker)
  return wtype_.worker_;
}
inline ::y3d::YWorker* WorkerParam::release_worker() {
  // @@protoc_insertion_point(field_release:y3d.WorkerParam.worker)
  if (has_worker()) {
    clear_has_wtype();
    ::y3d::YWorker* temp = wtype_.worker_;
    wtype_.worker_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void WorkerParam::set_allocated_worker(::y3d::YWorker* worker) {
  clear_wtype();
  if (worker) {
    set_has_worker();
    wtype_.worker_ = worker;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.WorkerParam.worker)
}

inline bool WorkerParam::has_wtype() const {
  return wtype_case() != WTYPE_NOT_SET;
}
inline void WorkerParam::clear_has_wtype() {
  _oneof_case_[0] = WTYPE_NOT_SET;
}
inline WorkerParam::WtypeCase WorkerParam::wtype_case() const {
  return WorkerParam::WtypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AllWorkerParam

// int32 status = 1;
inline void AllWorkerParam::clear_status() {
  status_ = 0;
}
inline ::google::protobuf::int32 AllWorkerParam::status() const {
  // @@protoc_insertion_point(field_get:y3d.AllWorkerParam.status)
  return status_;
}
inline void AllWorkerParam::set_status(::google::protobuf::int32 value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:y3d.AllWorkerParam.status)
}

// -------------------------------------------------------------------

// YEvent

// .y3d.ENone noevent = 1;
inline bool YEvent::has_noevent() const {
  return event_case() == kNoevent;
}
inline void YEvent::set_has_noevent() {
  _oneof_case_[0] = kNoevent;
}
inline void YEvent::clear_noevent() {
  if (has_noevent()) {
    delete event_.noevent_;
    clear_has_event();
  }
}
inline  const ::y3d::ENone& YEvent::noevent() const {
  // @@protoc_insertion_point(field_get:y3d.YEvent.noevent)
  return has_noevent()
      ? *event_.noevent_
      : ::y3d::ENone::default_instance();
}
inline ::y3d::ENone* YEvent::mutable_noevent() {
  if (!has_noevent()) {
    clear_event();
    set_has_noevent();
    event_.noevent_ = new ::y3d::ENone;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YEvent.noevent)
  return event_.noevent_;
}
inline ::y3d::ENone* YEvent::release_noevent() {
  // @@protoc_insertion_point(field_release:y3d.YEvent.noevent)
  if (has_noevent()) {
    clear_has_event();
    ::y3d::ENone* temp = event_.noevent_;
    event_.noevent_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void YEvent::set_allocated_noevent(::y3d::ENone* noevent) {
  clear_event();
  if (noevent) {
    set_has_noevent();
    event_.noevent_ = noevent;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YEvent.noevent)
}

// .y3d.ESelect select = 2;
inline bool YEvent::has_select() const {
  return event_case() == kSelect;
}
inline void YEvent::set_has_select() {
  _oneof_case_[0] = kSelect;
}
inline void YEvent::clear_select() {
  if (has_select()) {
    delete event_.select_;
    clear_has_event();
  }
}
inline  const ::y3d::ESelect& YEvent::select() const {
  // @@protoc_insertion_point(field_get:y3d.YEvent.select)
  return has_select()
      ? *event_.select_
      : ::y3d::ESelect::default_instance();
}
inline ::y3d::ESelect* YEvent::mutable_select() {
  if (!has_select()) {
    clear_event();
    set_has_select();
    event_.select_ = new ::y3d::ESelect;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YEvent.select)
  return event_.select_;
}
inline ::y3d::ESelect* YEvent::release_select() {
  // @@protoc_insertion_point(field_release:y3d.YEvent.select)
  if (has_select()) {
    clear_has_event();
    ::y3d::ESelect* temp = event_.select_;
    event_.select_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void YEvent::set_allocated_select(::y3d::ESelect* select) {
  clear_event();
  if (select) {
    set_has_select();
    event_.select_ = select;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YEvent.select)
}

// .y3d.EMove move = 3;
inline bool YEvent::has_move() const {
  return event_case() == kMove;
}
inline void YEvent::set_has_move() {
  _oneof_case_[0] = kMove;
}
inline void YEvent::clear_move() {
  if (has_move()) {
    delete event_.move_;
    clear_has_event();
  }
}
inline  const ::y3d::EMove& YEvent::move() const {
  // @@protoc_insertion_point(field_get:y3d.YEvent.move)
  return has_move()
      ? *event_.move_
      : ::y3d::EMove::default_instance();
}
inline ::y3d::EMove* YEvent::mutable_move() {
  if (!has_move()) {
    clear_event();
    set_has_move();
    event_.move_ = new ::y3d::EMove;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YEvent.move)
  return event_.move_;
}
inline ::y3d::EMove* YEvent::release_move() {
  // @@protoc_insertion_point(field_release:y3d.YEvent.move)
  if (has_move()) {
    clear_has_event();
    ::y3d::EMove* temp = event_.move_;
    event_.move_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void YEvent::set_allocated_move(::y3d::EMove* move) {
  clear_event();
  if (move) {
    set_has_move();
    event_.move_ = move;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YEvent.move)
}

// .y3d.ERotate rotate = 4;
inline bool YEvent::has_rotate() const {
  return event_case() == kRotate;
}
inline void YEvent::set_has_rotate() {
  _oneof_case_[0] = kRotate;
}
inline void YEvent::clear_rotate() {
  if (has_rotate()) {
    delete event_.rotate_;
    clear_has_event();
  }
}
inline  const ::y3d::ERotate& YEvent::rotate() const {
  // @@protoc_insertion_point(field_get:y3d.YEvent.rotate)
  return has_rotate()
      ? *event_.rotate_
      : ::y3d::ERotate::default_instance();
}
inline ::y3d::ERotate* YEvent::mutable_rotate() {
  if (!has_rotate()) {
    clear_event();
    set_has_rotate();
    event_.rotate_ = new ::y3d::ERotate;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YEvent.rotate)
  return event_.rotate_;
}
inline ::y3d::ERotate* YEvent::release_rotate() {
  // @@protoc_insertion_point(field_release:y3d.YEvent.rotate)
  if (has_rotate()) {
    clear_has_event();
    ::y3d::ERotate* temp = event_.rotate_;
    event_.rotate_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void YEvent::set_allocated_rotate(::y3d::ERotate* rotate) {
  clear_event();
  if (rotate) {
    set_has_rotate();
    event_.rotate_ = rotate;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YEvent.rotate)
}

// .y3d.EDelete del = 5;
inline bool YEvent::has_del() const {
  return event_case() == kDel;
}
inline void YEvent::set_has_del() {
  _oneof_case_[0] = kDel;
}
inline void YEvent::clear_del() {
  if (has_del()) {
    delete event_.del_;
    clear_has_event();
  }
}
inline  const ::y3d::EDelete& YEvent::del() const {
  // @@protoc_insertion_point(field_get:y3d.YEvent.del)
  return has_del()
      ? *event_.del_
      : ::y3d::EDelete::default_instance();
}
inline ::y3d::EDelete* YEvent::mutable_del() {
  if (!has_del()) {
    clear_event();
    set_has_del();
    event_.del_ = new ::y3d::EDelete;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YEvent.del)
  return event_.del_;
}
inline ::y3d::EDelete* YEvent::release_del() {
  // @@protoc_insertion_point(field_release:y3d.YEvent.del)
  if (has_del()) {
    clear_has_event();
    ::y3d::EDelete* temp = event_.del_;
    event_.del_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void YEvent::set_allocated_del(::y3d::EDelete* del) {
  clear_event();
  if (del) {
    set_has_del();
    event_.del_ = del;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YEvent.del)
}

// .y3d.ESelectMany select_many = 6;
inline bool YEvent::has_select_many() const {
  return event_case() == kSelectMany;
}
inline void YEvent::set_has_select_many() {
  _oneof_case_[0] = kSelectMany;
}
inline void YEvent::clear_select_many() {
  if (has_select_many()) {
    delete event_.select_many_;
    clear_has_event();
  }
}
inline  const ::y3d::ESelectMany& YEvent::select_many() const {
  // @@protoc_insertion_point(field_get:y3d.YEvent.select_many)
  return has_select_many()
      ? *event_.select_many_
      : ::y3d::ESelectMany::default_instance();
}
inline ::y3d::ESelectMany* YEvent::mutable_select_many() {
  if (!has_select_many()) {
    clear_event();
    set_has_select_many();
    event_.select_many_ = new ::y3d::ESelectMany;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YEvent.select_many)
  return event_.select_many_;
}
inline ::y3d::ESelectMany* YEvent::release_select_many() {
  // @@protoc_insertion_point(field_release:y3d.YEvent.select_many)
  if (has_select_many()) {
    clear_has_event();
    ::y3d::ESelectMany* temp = event_.select_many_;
    event_.select_many_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void YEvent::set_allocated_select_many(::y3d::ESelectMany* select_many) {
  clear_event();
  if (select_many) {
    set_has_select_many();
    event_.select_many_ = select_many;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YEvent.select_many)
}

// .y3d.EIsolate isolate = 7;
inline bool YEvent::has_isolate() const {
  return event_case() == kIsolate;
}
inline void YEvent::set_has_isolate() {
  _oneof_case_[0] = kIsolate;
}
inline void YEvent::clear_isolate() {
  if (has_isolate()) {
    delete event_.isolate_;
    clear_has_event();
  }
}
inline  const ::y3d::EIsolate& YEvent::isolate() const {
  // @@protoc_insertion_point(field_get:y3d.YEvent.isolate)
  return has_isolate()
      ? *event_.isolate_
      : ::y3d::EIsolate::default_instance();
}
inline ::y3d::EIsolate* YEvent::mutable_isolate() {
  if (!has_isolate()) {
    clear_event();
    set_has_isolate();
    event_.isolate_ = new ::y3d::EIsolate;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YEvent.isolate)
  return event_.isolate_;
}
inline ::y3d::EIsolate* YEvent::release_isolate() {
  // @@protoc_insertion_point(field_release:y3d.YEvent.isolate)
  if (has_isolate()) {
    clear_has_event();
    ::y3d::EIsolate* temp = event_.isolate_;
    event_.isolate_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void YEvent::set_allocated_isolate(::y3d::EIsolate* isolate) {
  clear_event();
  if (isolate) {
    set_has_isolate();
    event_.isolate_ = isolate;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YEvent.isolate)
}

inline bool YEvent::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void YEvent::clear_has_event() {
  _oneof_case_[0] = EVENT_NOT_SET;
}
inline YEvent::EventCase YEvent::event_case() const {
  return YEvent::EventCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ENone

// -------------------------------------------------------------------

// ESelect

// string name = 1;
inline void ESelect::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ESelect::name() const {
  // @@protoc_insertion_point(field_get:y3d.ESelect.name)
  return name_.GetNoArena();
}
inline void ESelect::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.ESelect.name)
}
#if LANG_CXX11
inline void ESelect::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.ESelect.name)
}
#endif
inline void ESelect::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.ESelect.name)
}
inline void ESelect::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.ESelect.name)
}
inline ::std::string* ESelect::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:y3d.ESelect.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ESelect::release_name() {
  // @@protoc_insertion_point(field_release:y3d.ESelect.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ESelect::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:y3d.ESelect.name)
}

// bool isolate = 2;
inline void ESelect::clear_isolate() {
  isolate_ = false;
}
inline bool ESelect::isolate() const {
  // @@protoc_insertion_point(field_get:y3d.ESelect.isolate)
  return isolate_;
}
inline void ESelect::set_isolate(bool value) {
  
  isolate_ = value;
  // @@protoc_insertion_point(field_set:y3d.ESelect.isolate)
}

// -------------------------------------------------------------------

// ESelectMany

// repeated string name = 1;
inline int ESelectMany::name_size() const {
  return name_.size();
}
inline void ESelectMany::clear_name() {
  name_.Clear();
}
inline const ::std::string& ESelectMany::name(int index) const {
  // @@protoc_insertion_point(field_get:y3d.ESelectMany.name)
  return name_.Get(index);
}
inline ::std::string* ESelectMany::mutable_name(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.ESelectMany.name)
  return name_.Mutable(index);
}
inline void ESelectMany::set_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:y3d.ESelectMany.name)
  name_.Mutable(index)->assign(value);
}
inline void ESelectMany::set_name(int index, const char* value) {
  name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:y3d.ESelectMany.name)
}
inline void ESelectMany::set_name(int index, const char* value, size_t size) {
  name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:y3d.ESelectMany.name)
}
inline ::std::string* ESelectMany::add_name() {
  // @@protoc_insertion_point(field_add_mutable:y3d.ESelectMany.name)
  return name_.Add();
}
inline void ESelectMany::add_name(const ::std::string& value) {
  name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:y3d.ESelectMany.name)
}
inline void ESelectMany::add_name(const char* value) {
  name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:y3d.ESelectMany.name)
}
inline void ESelectMany::add_name(const char* value, size_t size) {
  name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:y3d.ESelectMany.name)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ESelectMany::name() const {
  // @@protoc_insertion_point(field_list:y3d.ESelectMany.name)
  return name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ESelectMany::mutable_name() {
  // @@protoc_insertion_point(field_mutable_list:y3d.ESelectMany.name)
  return &name_;
}

// bool isolate = 2;
inline void ESelectMany::clear_isolate() {
  isolate_ = false;
}
inline bool ESelectMany::isolate() const {
  // @@protoc_insertion_point(field_get:y3d.ESelectMany.isolate)
  return isolate_;
}
inline void ESelectMany::set_isolate(bool value) {
  
  isolate_ = value;
  // @@protoc_insertion_point(field_set:y3d.ESelectMany.isolate)
}

// -------------------------------------------------------------------

// EMove

// repeated float point = 1;
inline int EMove::point_size() const {
  return point_.size();
}
inline void EMove::clear_point() {
  point_.Clear();
}
inline float EMove::point(int index) const {
  // @@protoc_insertion_point(field_get:y3d.EMove.point)
  return point_.Get(index);
}
inline void EMove::set_point(int index, float value) {
  point_.Set(index, value);
  // @@protoc_insertion_point(field_set:y3d.EMove.point)
}
inline void EMove::add_point(float value) {
  point_.Add(value);
  // @@protoc_insertion_point(field_add:y3d.EMove.point)
}
inline const ::google::protobuf::RepeatedField< float >&
EMove::point() const {
  // @@protoc_insertion_point(field_list:y3d.EMove.point)
  return point_;
}
inline ::google::protobuf::RepeatedField< float >*
EMove::mutable_point() {
  // @@protoc_insertion_point(field_mutable_list:y3d.EMove.point)
  return &point_;
}

// -------------------------------------------------------------------

// ERotate

// repeated float rotate = 1;
inline int ERotate::rotate_size() const {
  return rotate_.size();
}
inline void ERotate::clear_rotate() {
  rotate_.Clear();
}
inline float ERotate::rotate(int index) const {
  // @@protoc_insertion_point(field_get:y3d.ERotate.rotate)
  return rotate_.Get(index);
}
inline void ERotate::set_rotate(int index, float value) {
  rotate_.Set(index, value);
  // @@protoc_insertion_point(field_set:y3d.ERotate.rotate)
}
inline void ERotate::add_rotate(float value) {
  rotate_.Add(value);
  // @@protoc_insertion_point(field_add:y3d.ERotate.rotate)
}
inline const ::google::protobuf::RepeatedField< float >&
ERotate::rotate() const {
  // @@protoc_insertion_point(field_list:y3d.ERotate.rotate)
  return rotate_;
}
inline ::google::protobuf::RepeatedField< float >*
ERotate::mutable_rotate() {
  // @@protoc_insertion_point(field_mutable_list:y3d.ERotate.rotate)
  return &rotate_;
}

// -------------------------------------------------------------------

// EDelete

// string name = 1;
inline void EDelete::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EDelete::name() const {
  // @@protoc_insertion_point(field_get:y3d.EDelete.name)
  return name_.GetNoArena();
}
inline void EDelete::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.EDelete.name)
}
#if LANG_CXX11
inline void EDelete::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.EDelete.name)
}
#endif
inline void EDelete::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.EDelete.name)
}
inline void EDelete::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.EDelete.name)
}
inline ::std::string* EDelete::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:y3d.EDelete.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EDelete::release_name() {
  // @@protoc_insertion_point(field_release:y3d.EDelete.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EDelete::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:y3d.EDelete.name)
}

// -------------------------------------------------------------------

// EIsolate

// string name = 1;
inline void EIsolate::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EIsolate::name() const {
  // @@protoc_insertion_point(field_get:y3d.EIsolate.name)
  return name_.GetNoArena();
}
inline void EIsolate::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.EIsolate.name)
}
#if LANG_CXX11
inline void EIsolate::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.EIsolate.name)
}
#endif
inline void EIsolate::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.EIsolate.name)
}
inline void EIsolate::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.EIsolate.name)
}
inline ::std::string* EIsolate::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:y3d.EIsolate.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EIsolate::release_name() {
  // @@protoc_insertion_point(field_release:y3d.EIsolate.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EIsolate::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:y3d.EIsolate.name)
}

// bool endIsolate = 2;
inline void EIsolate::clear_endisolate() {
  endisolate_ = false;
}
inline bool EIsolate::endisolate() const {
  // @@protoc_insertion_point(field_get:y3d.EIsolate.endIsolate)
  return endisolate_;
}
inline void EIsolate::set_endisolate(bool value) {
  
  endisolate_ = value;
  // @@protoc_insertion_point(field_set:y3d.EIsolate.endIsolate)
}

// -------------------------------------------------------------------

// ResponseEvent

// bool error = 1;
inline void ResponseEvent::clear_error() {
  error_ = false;
}
inline bool ResponseEvent::error() const {
  // @@protoc_insertion_point(field_get:y3d.ResponseEvent.error)
  return error_;
}
inline void ResponseEvent::set_error(bool value) {
  
  error_ = value;
  // @@protoc_insertion_point(field_set:y3d.ResponseEvent.error)
}

// string msg = 2;
inline void ResponseEvent::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseEvent::msg() const {
  // @@protoc_insertion_point(field_get:y3d.ResponseEvent.msg)
  return msg_.GetNoArena();
}
inline void ResponseEvent::set_msg(const ::std::string& value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.ResponseEvent.msg)
}
#if LANG_CXX11
inline void ResponseEvent::set_msg(::std::string&& value) {
  
  msg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.ResponseEvent.msg)
}
#endif
inline void ResponseEvent::set_msg(const char* value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.ResponseEvent.msg)
}
inline void ResponseEvent::set_msg(const char* value, size_t size) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.ResponseEvent.msg)
}
inline ::std::string* ResponseEvent::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:y3d.ResponseEvent.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseEvent::release_msg() {
  // @@protoc_insertion_point(field_release:y3d.ResponseEvent.msg)
  
  return msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseEvent::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:y3d.ResponseEvent.msg)
}

// -------------------------------------------------------------------

// EUnwrap

// string oname = 1;
inline void EUnwrap::clear_oname() {
  oname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EUnwrap::oname() const {
  // @@protoc_insertion_point(field_get:y3d.EUnwrap.oname)
  return oname_.GetNoArena();
}
inline void EUnwrap::set_oname(const ::std::string& value) {
  
  oname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.EUnwrap.oname)
}
#if LANG_CXX11
inline void EUnwrap::set_oname(::std::string&& value) {
  
  oname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.EUnwrap.oname)
}
#endif
inline void EUnwrap::set_oname(const char* value) {
  
  oname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.EUnwrap.oname)
}
inline void EUnwrap::set_oname(const char* value, size_t size) {
  
  oname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.EUnwrap.oname)
}
inline ::std::string* EUnwrap::mutable_oname() {
  
  // @@protoc_insertion_point(field_mutable:y3d.EUnwrap.oname)
  return oname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EUnwrap::release_oname() {
  // @@protoc_insertion_point(field_release:y3d.EUnwrap.oname)
  
  return oname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EUnwrap::set_allocated_oname(::std::string* oname) {
  if (oname != NULL) {
    
  } else {
    
  }
  oname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), oname);
  // @@protoc_insertion_point(field_set_allocated:y3d.EUnwrap.oname)
}

// int32 channel = 2;
inline void EUnwrap::clear_channel() {
  channel_ = 0;
}
inline ::google::protobuf::int32 EUnwrap::channel() const {
  // @@protoc_insertion_point(field_get:y3d.EUnwrap.channel)
  return channel_;
}
inline void EUnwrap::set_channel(::google::protobuf::int32 value) {
  
  channel_ = value;
  // @@protoc_insertion_point(field_set:y3d.EUnwrap.channel)
}

// .y3d.MaxUnwrap max3d = 3;
inline bool EUnwrap::has_max3d() const {
  return setting_case() == kMax3D;
}
inline void EUnwrap::set_has_max3d() {
  _oneof_case_[0] = kMax3D;
}
inline void EUnwrap::clear_max3d() {
  if (has_max3d()) {
    delete setting_.max3d_;
    clear_has_setting();
  }
}
inline  const ::y3d::MaxUnwrap& EUnwrap::max3d() const {
  // @@protoc_insertion_point(field_get:y3d.EUnwrap.max3d)
  return has_max3d()
      ? *setting_.max3d_
      : ::y3d::MaxUnwrap::default_instance();
}
inline ::y3d::MaxUnwrap* EUnwrap::mutable_max3d() {
  if (!has_max3d()) {
    clear_setting();
    set_has_max3d();
    setting_.max3d_ = new ::y3d::MaxUnwrap;
  }
  // @@protoc_insertion_point(field_mutable:y3d.EUnwrap.max3d)
  return setting_.max3d_;
}
inline ::y3d::MaxUnwrap* EUnwrap::release_max3d() {
  // @@protoc_insertion_point(field_release:y3d.EUnwrap.max3d)
  if (has_max3d()) {
    clear_has_setting();
    ::y3d::MaxUnwrap* temp = setting_.max3d_;
    setting_.max3d_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void EUnwrap::set_allocated_max3d(::y3d::MaxUnwrap* max3d) {
  clear_setting();
  if (max3d) {
    set_has_max3d();
    setting_.max3d_ = max3d;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.EUnwrap.max3d)
}

// .y3d.BlenderUnwrap blender = 4;
inline bool EUnwrap::has_blender() const {
  return setting_case() == kBlender;
}
inline void EUnwrap::set_has_blender() {
  _oneof_case_[0] = kBlender;
}
inline void EUnwrap::clear_blender() {
  if (has_blender()) {
    delete setting_.blender_;
    clear_has_setting();
  }
}
inline  const ::y3d::BlenderUnwrap& EUnwrap::blender() const {
  // @@protoc_insertion_point(field_get:y3d.EUnwrap.blender)
  return has_blender()
      ? *setting_.blender_
      : ::y3d::BlenderUnwrap::default_instance();
}
inline ::y3d::BlenderUnwrap* EUnwrap::mutable_blender() {
  if (!has_blender()) {
    clear_setting();
    set_has_blender();
    setting_.blender_ = new ::y3d::BlenderUnwrap;
  }
  // @@protoc_insertion_point(field_mutable:y3d.EUnwrap.blender)
  return setting_.blender_;
}
inline ::y3d::BlenderUnwrap* EUnwrap::release_blender() {
  // @@protoc_insertion_point(field_release:y3d.EUnwrap.blender)
  if (has_blender()) {
    clear_has_setting();
    ::y3d::BlenderUnwrap* temp = setting_.blender_;
    setting_.blender_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void EUnwrap::set_allocated_blender(::y3d::BlenderUnwrap* blender) {
  clear_setting();
  if (blender) {
    set_has_blender();
    setting_.blender_ = blender;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.EUnwrap.blender)
}

inline bool EUnwrap::has_setting() const {
  return setting_case() != SETTING_NOT_SET;
}
inline void EUnwrap::clear_has_setting() {
  _oneof_case_[0] = SETTING_NOT_SET;
}
inline EUnwrap::SettingCase EUnwrap::setting_case() const {
  return EUnwrap::SettingCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// BlenderUnwrap

// -------------------------------------------------------------------

// MaxUnwrap

// float angle = 1;
inline void MaxUnwrap::clear_angle() {
  angle_ = 0;
}
inline float MaxUnwrap::angle() const {
  // @@protoc_insertion_point(field_get:y3d.MaxUnwrap.angle)
  return angle_;
}
inline void MaxUnwrap::set_angle(float value) {
  
  angle_ = value;
  // @@protoc_insertion_point(field_set:y3d.MaxUnwrap.angle)
}

// float spacing = 2;
inline void MaxUnwrap::clear_spacing() {
  spacing_ = 0;
}
inline float MaxUnwrap::spacing() const {
  // @@protoc_insertion_point(field_get:y3d.MaxUnwrap.spacing)
  return spacing_;
}
inline void MaxUnwrap::set_spacing(float value) {
  
  spacing_ = value;
  // @@protoc_insertion_point(field_set:y3d.MaxUnwrap.spacing)
}

// -------------------------------------------------------------------

// EPacking

// string oname = 1;
inline void EPacking::clear_oname() {
  oname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EPacking::oname() const {
  // @@protoc_insertion_point(field_get:y3d.EPacking.oname)
  return oname_.GetNoArena();
}
inline void EPacking::set_oname(const ::std::string& value) {
  
  oname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.EPacking.oname)
}
#if LANG_CXX11
inline void EPacking::set_oname(::std::string&& value) {
  
  oname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.EPacking.oname)
}
#endif
inline void EPacking::set_oname(const char* value) {
  
  oname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.EPacking.oname)
}
inline void EPacking::set_oname(const char* value, size_t size) {
  
  oname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.EPacking.oname)
}
inline ::std::string* EPacking::mutable_oname() {
  
  // @@protoc_insertion_point(field_mutable:y3d.EPacking.oname)
  return oname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EPacking::release_oname() {
  // @@protoc_insertion_point(field_release:y3d.EPacking.oname)
  
  return oname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EPacking::set_allocated_oname(::std::string* oname) {
  if (oname != NULL) {
    
  } else {
    
  }
  oname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), oname);
  // @@protoc_insertion_point(field_set_allocated:y3d.EPacking.oname)
}

// string uvname = 2;
inline void EPacking::clear_uvname() {
  uvname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EPacking::uvname() const {
  // @@protoc_insertion_point(field_get:y3d.EPacking.uvname)
  return uvname_.GetNoArena();
}
inline void EPacking::set_uvname(const ::std::string& value) {
  
  uvname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.EPacking.uvname)
}
#if LANG_CXX11
inline void EPacking::set_uvname(::std::string&& value) {
  
  uvname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.EPacking.uvname)
}
#endif
inline void EPacking::set_uvname(const char* value) {
  
  uvname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.EPacking.uvname)
}
inline void EPacking::set_uvname(const char* value, size_t size) {
  
  uvname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.EPacking.uvname)
}
inline ::std::string* EPacking::mutable_uvname() {
  
  // @@protoc_insertion_point(field_mutable:y3d.EPacking.uvname)
  return uvname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EPacking::release_uvname() {
  // @@protoc_insertion_point(field_release:y3d.EPacking.uvname)
  
  return uvname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EPacking::set_allocated_uvname(::std::string* uvname) {
  if (uvname != NULL) {
    
  } else {
    
  }
  uvname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uvname);
  // @@protoc_insertion_point(field_set_allocated:y3d.EPacking.uvname)
}

// int32 tile_Size = 3;
inline void EPacking::clear_tile_size() {
  tile_size_ = 0;
}
inline ::google::protobuf::int32 EPacking::tile_size() const {
  // @@protoc_insertion_point(field_get:y3d.EPacking.tile_Size)
  return tile_size_;
}
inline void EPacking::set_tile_size(::google::protobuf::int32 value) {
  
  tile_size_ = value;
  // @@protoc_insertion_point(field_set:y3d.EPacking.tile_Size)
}

// .y3d.Pack3DMax packmax = 4;
inline bool EPacking::has_packmax() const {
  return pack_case() == kPackmax;
}
inline void EPacking::set_has_packmax() {
  _oneof_case_[0] = kPackmax;
}
inline void EPacking::clear_packmax() {
  if (has_packmax()) {
    delete pack_.packmax_;
    clear_has_pack();
  }
}
inline  const ::y3d::Pack3DMax& EPacking::packmax() const {
  // @@protoc_insertion_point(field_get:y3d.EPacking.packmax)
  return has_packmax()
      ? *pack_.packmax_
      : ::y3d::Pack3DMax::default_instance();
}
inline ::y3d::Pack3DMax* EPacking::mutable_packmax() {
  if (!has_packmax()) {
    clear_pack();
    set_has_packmax();
    pack_.packmax_ = new ::y3d::Pack3DMax;
  }
  // @@protoc_insertion_point(field_mutable:y3d.EPacking.packmax)
  return pack_.packmax_;
}
inline ::y3d::Pack3DMax* EPacking::release_packmax() {
  // @@protoc_insertion_point(field_release:y3d.EPacking.packmax)
  if (has_packmax()) {
    clear_has_pack();
    ::y3d::Pack3DMax* temp = pack_.packmax_;
    pack_.packmax_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void EPacking::set_allocated_packmax(::y3d::Pack3DMax* packmax) {
  clear_pack();
  if (packmax) {
    set_has_packmax();
    pack_.packmax_ = packmax;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.EPacking.packmax)
}

// .y3d.PackRect packrect = 5;
inline bool EPacking::has_packrect() const {
  return pack_case() == kPackrect;
}
inline void EPacking::set_has_packrect() {
  _oneof_case_[0] = kPackrect;
}
inline void EPacking::clear_packrect() {
  if (has_packrect()) {
    delete pack_.packrect_;
    clear_has_pack();
  }
}
inline  const ::y3d::PackRect& EPacking::packrect() const {
  // @@protoc_insertion_point(field_get:y3d.EPacking.packrect)
  return has_packrect()
      ? *pack_.packrect_
      : ::y3d::PackRect::default_instance();
}
inline ::y3d::PackRect* EPacking::mutable_packrect() {
  if (!has_packrect()) {
    clear_pack();
    set_has_packrect();
    pack_.packrect_ = new ::y3d::PackRect;
  }
  // @@protoc_insertion_point(field_mutable:y3d.EPacking.packrect)
  return pack_.packrect_;
}
inline ::y3d::PackRect* EPacking::release_packrect() {
  // @@protoc_insertion_point(field_release:y3d.EPacking.packrect)
  if (has_packrect()) {
    clear_has_pack();
    ::y3d::PackRect* temp = pack_.packrect_;
    pack_.packrect_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void EPacking::set_allocated_packrect(::y3d::PackRect* packrect) {
  clear_pack();
  if (packrect) {
    set_has_packrect();
    pack_.packrect_ = packrect;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.EPacking.packrect)
}

inline bool EPacking::has_pack() const {
  return pack_case() != PACK_NOT_SET;
}
inline void EPacking::clear_has_pack() {
  _oneof_case_[0] = PACK_NOT_SET;
}
inline EPacking::PackCase EPacking::pack_case() const {
  return EPacking::PackCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PackRect

// int32 density = 1;
inline void PackRect::clear_density() {
  density_ = 0;
}
inline ::google::protobuf::int32 PackRect::density() const {
  // @@protoc_insertion_point(field_get:y3d.PackRect.density)
  return density_;
}
inline void PackRect::set_density(::google::protobuf::int32 value) {
  
  density_ = value;
  // @@protoc_insertion_point(field_set:y3d.PackRect.density)
}

// float padding = 2;
inline void PackRect::clear_padding() {
  padding_ = 0;
}
inline float PackRect::padding() const {
  // @@protoc_insertion_point(field_get:y3d.PackRect.padding)
  return padding_;
}
inline void PackRect::set_padding(float value) {
  
  padding_ = value;
  // @@protoc_insertion_point(field_set:y3d.PackRect.padding)
}

// -------------------------------------------------------------------

// Pack3DMax

// int32 numTile = 1;
inline void Pack3DMax::clear_numtile() {
  numtile_ = 0;
}
inline ::google::protobuf::int32 Pack3DMax::numtile() const {
  // @@protoc_insertion_point(field_get:y3d.Pack3DMax.numTile)
  return numtile_;
}
inline void Pack3DMax::set_numtile(::google::protobuf::int32 value) {
  
  numtile_ = value;
  // @@protoc_insertion_point(field_set:y3d.Pack3DMax.numTile)
}

// bool normalize = 2;
inline void Pack3DMax::clear_normalize() {
  normalize_ = false;
}
inline bool Pack3DMax::normalize() const {
  // @@protoc_insertion_point(field_get:y3d.Pack3DMax.normalize)
  return normalize_;
}
inline void Pack3DMax::set_normalize(bool value) {
  
  normalize_ = value;
  // @@protoc_insertion_point(field_set:y3d.Pack3DMax.normalize)
}

// bool rotate_clusters = 3;
inline void Pack3DMax::clear_rotate_clusters() {
  rotate_clusters_ = false;
}
inline bool Pack3DMax::rotate_clusters() const {
  // @@protoc_insertion_point(field_get:y3d.Pack3DMax.rotate_clusters)
  return rotate_clusters_;
}
inline void Pack3DMax::set_rotate_clusters(bool value) {
  
  rotate_clusters_ = value;
  // @@protoc_insertion_point(field_set:y3d.Pack3DMax.rotate_clusters)
}

// bool fill_holes = 4;
inline void Pack3DMax::clear_fill_holes() {
  fill_holes_ = false;
}
inline bool Pack3DMax::fill_holes() const {
  // @@protoc_insertion_point(field_get:y3d.Pack3DMax.fill_holes)
  return fill_holes_;
}
inline void Pack3DMax::set_fill_holes(bool value) {
  
  fill_holes_ = value;
  // @@protoc_insertion_point(field_set:y3d.Pack3DMax.fill_holes)
}

// bool padding = 5;
inline void Pack3DMax::clear_padding() {
  padding_ = false;
}
inline bool Pack3DMax::padding() const {
  // @@protoc_insertion_point(field_get:y3d.Pack3DMax.padding)
  return padding_;
}
inline void Pack3DMax::set_padding(bool value) {
  
  padding_ = value;
  // @@protoc_insertion_point(field_set:y3d.Pack3DMax.padding)
}

// -------------------------------------------------------------------

// ELowpoly

// string oname = 1;
inline void ELowpoly::clear_oname() {
  oname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ELowpoly::oname() const {
  // @@protoc_insertion_point(field_get:y3d.ELowpoly.oname)
  return oname_.GetNoArena();
}
inline void ELowpoly::set_oname(const ::std::string& value) {
  
  oname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.ELowpoly.oname)
}
#if LANG_CXX11
inline void ELowpoly::set_oname(::std::string&& value) {
  
  oname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.ELowpoly.oname)
}
#endif
inline void ELowpoly::set_oname(const char* value) {
  
  oname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.ELowpoly.oname)
}
inline void ELowpoly::set_oname(const char* value, size_t size) {
  
  oname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.ELowpoly.oname)
}
inline ::std::string* ELowpoly::mutable_oname() {
  
  // @@protoc_insertion_point(field_mutable:y3d.ELowpoly.oname)
  return oname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ELowpoly::release_oname() {
  // @@protoc_insertion_point(field_release:y3d.ELowpoly.oname)
  
  return oname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ELowpoly::set_allocated_oname(::std::string* oname) {
  if (oname != NULL) {
    
  } else {
    
  }
  oname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), oname);
  // @@protoc_insertion_point(field_set_allocated:y3d.ELowpoly.oname)
}

// .y3d.LPoly3DMax lp_3dmax = 2;
inline bool ELowpoly::has_lp_3dmax() const {
  return lowtype_case() == kLp3Dmax;
}
inline void ELowpoly::set_has_lp_3dmax() {
  _oneof_case_[0] = kLp3Dmax;
}
inline void ELowpoly::clear_lp_3dmax() {
  if (has_lp_3dmax()) {
    delete lowtype_.lp_3dmax_;
    clear_has_lowtype();
  }
}
inline  const ::y3d::LPoly3DMax& ELowpoly::lp_3dmax() const {
  // @@protoc_insertion_point(field_get:y3d.ELowpoly.lp_3dmax)
  return has_lp_3dmax()
      ? *lowtype_.lp_3dmax_
      : ::y3d::LPoly3DMax::default_instance();
}
inline ::y3d::LPoly3DMax* ELowpoly::mutable_lp_3dmax() {
  if (!has_lp_3dmax()) {
    clear_lowtype();
    set_has_lp_3dmax();
    lowtype_.lp_3dmax_ = new ::y3d::LPoly3DMax;
  }
  // @@protoc_insertion_point(field_mutable:y3d.ELowpoly.lp_3dmax)
  return lowtype_.lp_3dmax_;
}
inline ::y3d::LPoly3DMax* ELowpoly::release_lp_3dmax() {
  // @@protoc_insertion_point(field_release:y3d.ELowpoly.lp_3dmax)
  if (has_lp_3dmax()) {
    clear_has_lowtype();
    ::y3d::LPoly3DMax* temp = lowtype_.lp_3dmax_;
    lowtype_.lp_3dmax_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ELowpoly::set_allocated_lp_3dmax(::y3d::LPoly3DMax* lp_3dmax) {
  clear_lowtype();
  if (lp_3dmax) {
    set_has_lp_3dmax();
    lowtype_.lp_3dmax_ = lp_3dmax;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.ELowpoly.lp_3dmax)
}

// .y3d.LPolyBlender lp_blender = 3;
inline bool ELowpoly::has_lp_blender() const {
  return lowtype_case() == kLpBlender;
}
inline void ELowpoly::set_has_lp_blender() {
  _oneof_case_[0] = kLpBlender;
}
inline void ELowpoly::clear_lp_blender() {
  if (has_lp_blender()) {
    delete lowtype_.lp_blender_;
    clear_has_lowtype();
  }
}
inline  const ::y3d::LPolyBlender& ELowpoly::lp_blender() const {
  // @@protoc_insertion_point(field_get:y3d.ELowpoly.lp_blender)
  return has_lp_blender()
      ? *lowtype_.lp_blender_
      : ::y3d::LPolyBlender::default_instance();
}
inline ::y3d::LPolyBlender* ELowpoly::mutable_lp_blender() {
  if (!has_lp_blender()) {
    clear_lowtype();
    set_has_lp_blender();
    lowtype_.lp_blender_ = new ::y3d::LPolyBlender;
  }
  // @@protoc_insertion_point(field_mutable:y3d.ELowpoly.lp_blender)
  return lowtype_.lp_blender_;
}
inline ::y3d::LPolyBlender* ELowpoly::release_lp_blender() {
  // @@protoc_insertion_point(field_release:y3d.ELowpoly.lp_blender)
  if (has_lp_blender()) {
    clear_has_lowtype();
    ::y3d::LPolyBlender* temp = lowtype_.lp_blender_;
    lowtype_.lp_blender_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ELowpoly::set_allocated_lp_blender(::y3d::LPolyBlender* lp_blender) {
  clear_lowtype();
  if (lp_blender) {
    set_has_lp_blender();
    lowtype_.lp_blender_ = lp_blender;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.ELowpoly.lp_blender)
}

// .y3d.LPolyMeshlab lp_meshlab = 4;
inline bool ELowpoly::has_lp_meshlab() const {
  return lowtype_case() == kLpMeshlab;
}
inline void ELowpoly::set_has_lp_meshlab() {
  _oneof_case_[0] = kLpMeshlab;
}
inline void ELowpoly::clear_lp_meshlab() {
  if (has_lp_meshlab()) {
    delete lowtype_.lp_meshlab_;
    clear_has_lowtype();
  }
}
inline  const ::y3d::LPolyMeshlab& ELowpoly::lp_meshlab() const {
  // @@protoc_insertion_point(field_get:y3d.ELowpoly.lp_meshlab)
  return has_lp_meshlab()
      ? *lowtype_.lp_meshlab_
      : ::y3d::LPolyMeshlab::default_instance();
}
inline ::y3d::LPolyMeshlab* ELowpoly::mutable_lp_meshlab() {
  if (!has_lp_meshlab()) {
    clear_lowtype();
    set_has_lp_meshlab();
    lowtype_.lp_meshlab_ = new ::y3d::LPolyMeshlab;
  }
  // @@protoc_insertion_point(field_mutable:y3d.ELowpoly.lp_meshlab)
  return lowtype_.lp_meshlab_;
}
inline ::y3d::LPolyMeshlab* ELowpoly::release_lp_meshlab() {
  // @@protoc_insertion_point(field_release:y3d.ELowpoly.lp_meshlab)
  if (has_lp_meshlab()) {
    clear_has_lowtype();
    ::y3d::LPolyMeshlab* temp = lowtype_.lp_meshlab_;
    lowtype_.lp_meshlab_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ELowpoly::set_allocated_lp_meshlab(::y3d::LPolyMeshlab* lp_meshlab) {
  clear_lowtype();
  if (lp_meshlab) {
    set_has_lp_meshlab();
    lowtype_.lp_meshlab_ = lp_meshlab;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.ELowpoly.lp_meshlab)
}

inline bool ELowpoly::has_lowtype() const {
  return lowtype_case() != LOWTYPE_NOT_SET;
}
inline void ELowpoly::clear_has_lowtype() {
  _oneof_case_[0] = LOWTYPE_NOT_SET;
}
inline ELowpoly::LowtypeCase ELowpoly::lowtype_case() const {
  return ELowpoly::LowtypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LPoly3DMax

// float vertex_percent = 1;
inline void LPoly3DMax::clear_vertex_percent() {
  vertex_percent_ = 0;
}
inline float LPoly3DMax::vertex_percent() const {
  // @@protoc_insertion_point(field_get:y3d.LPoly3DMax.vertex_percent)
  return vertex_percent_;
}
inline void LPoly3DMax::set_vertex_percent(float value) {
  
  vertex_percent_ = value;
  // @@protoc_insertion_point(field_set:y3d.LPoly3DMax.vertex_percent)
}

// int32 vertex_count = 2;
inline void LPoly3DMax::clear_vertex_count() {
  vertex_count_ = 0;
}
inline ::google::protobuf::int32 LPoly3DMax::vertex_count() const {
  // @@protoc_insertion_point(field_get:y3d.LPoly3DMax.vertex_count)
  return vertex_count_;
}
inline void LPoly3DMax::set_vertex_count(::google::protobuf::int32 value) {
  
  vertex_count_ = value;
  // @@protoc_insertion_point(field_set:y3d.LPoly3DMax.vertex_count)
}

// .y3d.LPoly3DMax.OpMode optimization_mode = 3;
inline void LPoly3DMax::clear_optimization_mode() {
  optimization_mode_ = 0;
}
inline ::y3d::LPoly3DMax_OpMode LPoly3DMax::optimization_mode() const {
  // @@protoc_insertion_point(field_get:y3d.LPoly3DMax.optimization_mode)
  return static_cast< ::y3d::LPoly3DMax_OpMode >(optimization_mode_);
}
inline void LPoly3DMax::set_optimization_mode(::y3d::LPoly3DMax_OpMode value) {
  
  optimization_mode_ = value;
  // @@protoc_insertion_point(field_set:y3d.LPoly3DMax.optimization_mode)
}

// .y3d.LPoly3DMax.NormalMode normals = 4;
inline void LPoly3DMax::clear_normals() {
  normals_ = 0;
}
inline ::y3d::LPoly3DMax_NormalMode LPoly3DMax::normals() const {
  // @@protoc_insertion_point(field_get:y3d.LPoly3DMax.normals)
  return static_cast< ::y3d::LPoly3DMax_NormalMode >(normals_);
}
inline void LPoly3DMax::set_normals(::y3d::LPoly3DMax_NormalMode value) {
  
  normals_ = value;
  // @@protoc_insertion_point(field_set:y3d.LPoly3DMax.normals)
}

// bool favor_compact_faces = 5;
inline void LPoly3DMax::clear_favor_compact_faces() {
  favor_compact_faces_ = false;
}
inline bool LPoly3DMax::favor_compact_faces() const {
  // @@protoc_insertion_point(field_get:y3d.LPoly3DMax.favor_compact_faces)
  return favor_compact_faces_;
}
inline void LPoly3DMax::set_favor_compact_faces(bool value) {
  
  favor_compact_faces_ = value;
  // @@protoc_insertion_point(field_set:y3d.LPoly3DMax.favor_compact_faces)
}

// bool prevent_flipped_normals = 6;
inline void LPoly3DMax::clear_prevent_flipped_normals() {
  prevent_flipped_normals_ = false;
}
inline bool LPoly3DMax::prevent_flipped_normals() const {
  // @@protoc_insertion_point(field_get:y3d.LPoly3DMax.prevent_flipped_normals)
  return prevent_flipped_normals_;
}
inline void LPoly3DMax::set_prevent_flipped_normals(bool value) {
  
  prevent_flipped_normals_ = value;
  // @@protoc_insertion_point(field_set:y3d.LPoly3DMax.prevent_flipped_normals)
}

// bool lock_vertex_position = 7;
inline void LPoly3DMax::clear_lock_vertex_position() {
  lock_vertex_position_ = false;
}
inline bool LPoly3DMax::lock_vertex_position() const {
  // @@protoc_insertion_point(field_get:y3d.LPoly3DMax.lock_vertex_position)
  return lock_vertex_position_;
}
inline void LPoly3DMax::set_lock_vertex_position(bool value) {
  
  lock_vertex_position_ = value;
  // @@protoc_insertion_point(field_set:y3d.LPoly3DMax.lock_vertex_position)
}

// -------------------------------------------------------------------

// LPolyBlender

// float ratio = 1;
inline void LPolyBlender::clear_ratio() {
  ratio_ = 0;
}
inline float LPolyBlender::ratio() const {
  // @@protoc_insertion_point(field_get:y3d.LPolyBlender.ratio)
  return ratio_;
}
inline void LPolyBlender::set_ratio(float value) {
  
  ratio_ = value;
  // @@protoc_insertion_point(field_set:y3d.LPolyBlender.ratio)
}

// -------------------------------------------------------------------

// LPolyMeshlab

// -------------------------------------------------------------------

// ENormal

// string oname = 1;
inline void ENormal::clear_oname() {
  oname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ENormal::oname() const {
  // @@protoc_insertion_point(field_get:y3d.ENormal.oname)
  return oname_.GetNoArena();
}
inline void ENormal::set_oname(const ::std::string& value) {
  
  oname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.ENormal.oname)
}
#if LANG_CXX11
inline void ENormal::set_oname(::std::string&& value) {
  
  oname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.ENormal.oname)
}
#endif
inline void ENormal::set_oname(const char* value) {
  
  oname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.ENormal.oname)
}
inline void ENormal::set_oname(const char* value, size_t size) {
  
  oname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.ENormal.oname)
}
inline ::std::string* ENormal::mutable_oname() {
  
  // @@protoc_insertion_point(field_mutable:y3d.ENormal.oname)
  return oname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ENormal::release_oname() {
  // @@protoc_insertion_point(field_release:y3d.ENormal.oname)
  
  return oname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ENormal::set_allocated_oname(::std::string* oname) {
  if (oname != NULL) {
    
  } else {
    
  }
  oname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), oname);
  // @@protoc_insertion_point(field_set_allocated:y3d.ENormal.oname)
}

// string lowpoly = 2;
inline void ENormal::clear_lowpoly() {
  lowpoly_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ENormal::lowpoly() const {
  // @@protoc_insertion_point(field_get:y3d.ENormal.lowpoly)
  return lowpoly_.GetNoArena();
}
inline void ENormal::set_lowpoly(const ::std::string& value) {
  
  lowpoly_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.ENormal.lowpoly)
}
#if LANG_CXX11
inline void ENormal::set_lowpoly(::std::string&& value) {
  
  lowpoly_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.ENormal.lowpoly)
}
#endif
inline void ENormal::set_lowpoly(const char* value) {
  
  lowpoly_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.ENormal.lowpoly)
}
inline void ENormal::set_lowpoly(const char* value, size_t size) {
  
  lowpoly_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.ENormal.lowpoly)
}
inline ::std::string* ENormal::mutable_lowpoly() {
  
  // @@protoc_insertion_point(field_mutable:y3d.ENormal.lowpoly)
  return lowpoly_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ENormal::release_lowpoly() {
  // @@protoc_insertion_point(field_release:y3d.ENormal.lowpoly)
  
  return lowpoly_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ENormal::set_allocated_lowpoly(::std::string* lowpoly) {
  if (lowpoly != NULL) {
    
  } else {
    
  }
  lowpoly_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lowpoly);
  // @@protoc_insertion_point(field_set_allocated:y3d.ENormal.lowpoly)
}

// string highpoly = 3;
inline void ENormal::clear_highpoly() {
  highpoly_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ENormal::highpoly() const {
  // @@protoc_insertion_point(field_get:y3d.ENormal.highpoly)
  return highpoly_.GetNoArena();
}
inline void ENormal::set_highpoly(const ::std::string& value) {
  
  highpoly_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.ENormal.highpoly)
}
#if LANG_CXX11
inline void ENormal::set_highpoly(::std::string&& value) {
  
  highpoly_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.ENormal.highpoly)
}
#endif
inline void ENormal::set_highpoly(const char* value) {
  
  highpoly_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.ENormal.highpoly)
}
inline void ENormal::set_highpoly(const char* value, size_t size) {
  
  highpoly_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.ENormal.highpoly)
}
inline ::std::string* ENormal::mutable_highpoly() {
  
  // @@protoc_insertion_point(field_mutable:y3d.ENormal.highpoly)
  return highpoly_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ENormal::release_highpoly() {
  // @@protoc_insertion_point(field_release:y3d.ENormal.highpoly)
  
  return highpoly_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ENormal::set_allocated_highpoly(::std::string* highpoly) {
  if (highpoly != NULL) {
    
  } else {
    
  }
  highpoly_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), highpoly);
  // @@protoc_insertion_point(field_set_allocated:y3d.ENormal.highpoly)
}

// uint32 tex_size = 4;
inline void ENormal::clear_tex_size() {
  tex_size_ = 0u;
}
inline ::google::protobuf::uint32 ENormal::tex_size() const {
  // @@protoc_insertion_point(field_get:y3d.ENormal.tex_size)
  return tex_size_;
}
inline void ENormal::set_tex_size(::google::protobuf::uint32 value) {
  
  tex_size_ = value;
  // @@protoc_insertion_point(field_set:y3d.ENormal.tex_size)
}

// string out_tex = 5;
inline void ENormal::clear_out_tex() {
  out_tex_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ENormal::out_tex() const {
  // @@protoc_insertion_point(field_get:y3d.ENormal.out_tex)
  return out_tex_.GetNoArena();
}
inline void ENormal::set_out_tex(const ::std::string& value) {
  
  out_tex_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.ENormal.out_tex)
}
#if LANG_CXX11
inline void ENormal::set_out_tex(::std::string&& value) {
  
  out_tex_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.ENormal.out_tex)
}
#endif
inline void ENormal::set_out_tex(const char* value) {
  
  out_tex_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.ENormal.out_tex)
}
inline void ENormal::set_out_tex(const char* value, size_t size) {
  
  out_tex_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.ENormal.out_tex)
}
inline ::std::string* ENormal::mutable_out_tex() {
  
  // @@protoc_insertion_point(field_mutable:y3d.ENormal.out_tex)
  return out_tex_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ENormal::release_out_tex() {
  // @@protoc_insertion_point(field_release:y3d.ENormal.out_tex)
  
  return out_tex_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ENormal::set_allocated_out_tex(::std::string* out_tex) {
  if (out_tex != NULL) {
    
  } else {
    
  }
  out_tex_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), out_tex);
  // @@protoc_insertion_point(field_set_allocated:y3d.ENormal.out_tex)
}

// .y3d.Normal3DMax normal_3dmax = 6;
inline bool ENormal::has_normal_3dmax() const {
  return ntype_case() == kNormal3Dmax;
}
inline void ENormal::set_has_normal_3dmax() {
  _oneof_case_[0] = kNormal3Dmax;
}
inline void ENormal::clear_normal_3dmax() {
  if (has_normal_3dmax()) {
    delete ntype_.normal_3dmax_;
    clear_has_ntype();
  }
}
inline  const ::y3d::Normal3DMax& ENormal::normal_3dmax() const {
  // @@protoc_insertion_point(field_get:y3d.ENormal.normal_3dmax)
  return has_normal_3dmax()
      ? *ntype_.normal_3dmax_
      : ::y3d::Normal3DMax::default_instance();
}
inline ::y3d::Normal3DMax* ENormal::mutable_normal_3dmax() {
  if (!has_normal_3dmax()) {
    clear_ntype();
    set_has_normal_3dmax();
    ntype_.normal_3dmax_ = new ::y3d::Normal3DMax;
  }
  // @@protoc_insertion_point(field_mutable:y3d.ENormal.normal_3dmax)
  return ntype_.normal_3dmax_;
}
inline ::y3d::Normal3DMax* ENormal::release_normal_3dmax() {
  // @@protoc_insertion_point(field_release:y3d.ENormal.normal_3dmax)
  if (has_normal_3dmax()) {
    clear_has_ntype();
    ::y3d::Normal3DMax* temp = ntype_.normal_3dmax_;
    ntype_.normal_3dmax_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ENormal::set_allocated_normal_3dmax(::y3d::Normal3DMax* normal_3dmax) {
  clear_ntype();
  if (normal_3dmax) {
    set_has_normal_3dmax();
    ntype_.normal_3dmax_ = normal_3dmax;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.ENormal.normal_3dmax)
}

// .xnormal.Settings normal_xnormal = 7;
inline bool ENormal::has_normal_xnormal() const {
  return ntype_case() == kNormalXnormal;
}
inline void ENormal::set_has_normal_xnormal() {
  _oneof_case_[0] = kNormalXnormal;
}
inline void ENormal::clear_normal_xnormal() {
  if (has_normal_xnormal()) {
    delete ntype_.normal_xnormal_;
    clear_has_ntype();
  }
}
inline  const ::xnormal::Settings& ENormal::normal_xnormal() const {
  // @@protoc_insertion_point(field_get:y3d.ENormal.normal_xnormal)
  return has_normal_xnormal()
      ? *ntype_.normal_xnormal_
      : ::xnormal::Settings::default_instance();
}
inline ::xnormal::Settings* ENormal::mutable_normal_xnormal() {
  if (!has_normal_xnormal()) {
    clear_ntype();
    set_has_normal_xnormal();
    ntype_.normal_xnormal_ = new ::xnormal::Settings;
  }
  // @@protoc_insertion_point(field_mutable:y3d.ENormal.normal_xnormal)
  return ntype_.normal_xnormal_;
}
inline ::xnormal::Settings* ENormal::release_normal_xnormal() {
  // @@protoc_insertion_point(field_release:y3d.ENormal.normal_xnormal)
  if (has_normal_xnormal()) {
    clear_has_ntype();
    ::xnormal::Settings* temp = ntype_.normal_xnormal_;
    ntype_.normal_xnormal_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ENormal::set_allocated_normal_xnormal(::xnormal::Settings* normal_xnormal) {
  clear_ntype();
  if (normal_xnormal) {
    set_has_normal_xnormal();
    ntype_.normal_xnormal_ = normal_xnormal;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.ENormal.normal_xnormal)
}

inline bool ENormal::has_ntype() const {
  return ntype_case() != NTYPE_NOT_SET;
}
inline void ENormal::clear_has_ntype() {
  _oneof_case_[0] = NTYPE_NOT_SET;
}
inline ENormal::NtypeCase ENormal::ntype_case() const {
  return ENormal::NtypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Normal3DMax

// -------------------------------------------------------------------

// ProjectInfo

// string pname = 1;
inline void ProjectInfo::clear_pname() {
  pname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProjectInfo::pname() const {
  // @@protoc_insertion_point(field_get:y3d.ProjectInfo.pname)
  return pname_.GetNoArena();
}
inline void ProjectInfo::set_pname(const ::std::string& value) {
  
  pname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.ProjectInfo.pname)
}
#if LANG_CXX11
inline void ProjectInfo::set_pname(::std::string&& value) {
  
  pname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.ProjectInfo.pname)
}
#endif
inline void ProjectInfo::set_pname(const char* value) {
  
  pname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.ProjectInfo.pname)
}
inline void ProjectInfo::set_pname(const char* value, size_t size) {
  
  pname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.ProjectInfo.pname)
}
inline ::std::string* ProjectInfo::mutable_pname() {
  
  // @@protoc_insertion_point(field_mutable:y3d.ProjectInfo.pname)
  return pname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProjectInfo::release_pname() {
  // @@protoc_insertion_point(field_release:y3d.ProjectInfo.pname)
  
  return pname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProjectInfo::set_allocated_pname(::std::string* pname) {
  if (pname != NULL) {
    
  } else {
    
  }
  pname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pname);
  // @@protoc_insertion_point(field_set_allocated:y3d.ProjectInfo.pname)
}

// string project_path = 2;
inline void ProjectInfo::clear_project_path() {
  project_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProjectInfo::project_path() const {
  // @@protoc_insertion_point(field_get:y3d.ProjectInfo.project_path)
  return project_path_.GetNoArena();
}
inline void ProjectInfo::set_project_path(const ::std::string& value) {
  
  project_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.ProjectInfo.project_path)
}
#if LANG_CXX11
inline void ProjectInfo::set_project_path(::std::string&& value) {
  
  project_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.ProjectInfo.project_path)
}
#endif
inline void ProjectInfo::set_project_path(const char* value) {
  
  project_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.ProjectInfo.project_path)
}
inline void ProjectInfo::set_project_path(const char* value, size_t size) {
  
  project_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.ProjectInfo.project_path)
}
inline ::std::string* ProjectInfo::mutable_project_path() {
  
  // @@protoc_insertion_point(field_mutable:y3d.ProjectInfo.project_path)
  return project_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProjectInfo::release_project_path() {
  // @@protoc_insertion_point(field_release:y3d.ProjectInfo.project_path)
  
  return project_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProjectInfo::set_allocated_project_path(::std::string* project_path) {
  if (project_path != NULL) {
    
  } else {
    
  }
  project_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), project_path);
  // @@protoc_insertion_point(field_set_allocated:y3d.ProjectInfo.project_path)
}

// .google.protobuf.Timestamp ts = 3;
inline bool ProjectInfo::has_ts() const {
  return this != internal_default_instance() && ts_ != NULL;
}
inline void ProjectInfo::clear_ts() {
  if (GetArenaNoVirtual() == NULL && ts_ != NULL) delete ts_;
  ts_ = NULL;
}
inline const ::google::protobuf::Timestamp& ProjectInfo::ts() const {
  // @@protoc_insertion_point(field_get:y3d.ProjectInfo.ts)
  return ts_ != NULL ? *ts_
                         : *::google::protobuf::Timestamp::internal_default_instance();
}
inline ::google::protobuf::Timestamp* ProjectInfo::mutable_ts() {
  
  if (ts_ == NULL) {
    ts_ = new ::google::protobuf::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:y3d.ProjectInfo.ts)
  return ts_;
}
inline ::google::protobuf::Timestamp* ProjectInfo::release_ts() {
  // @@protoc_insertion_point(field_release:y3d.ProjectInfo.ts)
  
  ::google::protobuf::Timestamp* temp = ts_;
  ts_ = NULL;
  return temp;
}
inline void ProjectInfo::set_allocated_ts(::google::protobuf::Timestamp* ts) {
  delete ts_;
  if (ts != NULL && ts->GetArena() != NULL) {
    ::google::protobuf::Timestamp* new_ts = new ::google::protobuf::Timestamp;
    new_ts->CopyFrom(*ts);
    ts = new_ts;
  }
  ts_ = ts;
  if (ts) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.ProjectInfo.ts)
}

// .y3d.OptimizeOptions optimize_ops = 5;
inline bool ProjectInfo::has_optimize_ops() const {
  return this != internal_default_instance() && optimize_ops_ != NULL;
}
inline void ProjectInfo::clear_optimize_ops() {
  if (GetArenaNoVirtual() == NULL && optimize_ops_ != NULL) delete optimize_ops_;
  optimize_ops_ = NULL;
}
inline const ::y3d::OptimizeOptions& ProjectInfo::optimize_ops() const {
  // @@protoc_insertion_point(field_get:y3d.ProjectInfo.optimize_ops)
  return optimize_ops_ != NULL ? *optimize_ops_
                         : *::y3d::OptimizeOptions::internal_default_instance();
}
inline ::y3d::OptimizeOptions* ProjectInfo::mutable_optimize_ops() {
  
  if (optimize_ops_ == NULL) {
    optimize_ops_ = new ::y3d::OptimizeOptions;
  }
  // @@protoc_insertion_point(field_mutable:y3d.ProjectInfo.optimize_ops)
  return optimize_ops_;
}
inline ::y3d::OptimizeOptions* ProjectInfo::release_optimize_ops() {
  // @@protoc_insertion_point(field_release:y3d.ProjectInfo.optimize_ops)
  
  ::y3d::OptimizeOptions* temp = optimize_ops_;
  optimize_ops_ = NULL;
  return temp;
}
inline void ProjectInfo::set_allocated_optimize_ops(::y3d::OptimizeOptions* optimize_ops) {
  delete optimize_ops_;
  optimize_ops_ = optimize_ops;
  if (optimize_ops) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.ProjectInfo.optimize_ops)
}

// repeated .y3d.FilterView fview = 6;
inline int ProjectInfo::fview_size() const {
  return fview_.size();
}
inline void ProjectInfo::clear_fview() {
  fview_.Clear();
}
inline const ::y3d::FilterView& ProjectInfo::fview(int index) const {
  // @@protoc_insertion_point(field_get:y3d.ProjectInfo.fview)
  return fview_.Get(index);
}
inline ::y3d::FilterView* ProjectInfo::mutable_fview(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.ProjectInfo.fview)
  return fview_.Mutable(index);
}
inline ::y3d::FilterView* ProjectInfo::add_fview() {
  // @@protoc_insertion_point(field_add:y3d.ProjectInfo.fview)
  return fview_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::y3d::FilterView >*
ProjectInfo::mutable_fview() {
  // @@protoc_insertion_point(field_mutable_list:y3d.ProjectInfo.fview)
  return &fview_;
}
inline const ::google::protobuf::RepeatedPtrField< ::y3d::FilterView >&
ProjectInfo::fview() const {
  // @@protoc_insertion_point(field_list:y3d.ProjectInfo.fview)
  return fview_;
}

// float optimize_ratio = 7;
inline void ProjectInfo::clear_optimize_ratio() {
  optimize_ratio_ = 0;
}
inline float ProjectInfo::optimize_ratio() const {
  // @@protoc_insertion_point(field_get:y3d.ProjectInfo.optimize_ratio)
  return optimize_ratio_;
}
inline void ProjectInfo::set_optimize_ratio(float value) {
  
  optimize_ratio_ = value;
  // @@protoc_insertion_point(field_set:y3d.ProjectInfo.optimize_ratio)
}

// string original_path = 8;
inline void ProjectInfo::clear_original_path() {
  original_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProjectInfo::original_path() const {
  // @@protoc_insertion_point(field_get:y3d.ProjectInfo.original_path)
  return original_path_.GetNoArena();
}
inline void ProjectInfo::set_original_path(const ::std::string& value) {
  
  original_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.ProjectInfo.original_path)
}
#if LANG_CXX11
inline void ProjectInfo::set_original_path(::std::string&& value) {
  
  original_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.ProjectInfo.original_path)
}
#endif
inline void ProjectInfo::set_original_path(const char* value) {
  
  original_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.ProjectInfo.original_path)
}
inline void ProjectInfo::set_original_path(const char* value, size_t size) {
  
  original_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.ProjectInfo.original_path)
}
inline ::std::string* ProjectInfo::mutable_original_path() {
  
  // @@protoc_insertion_point(field_mutable:y3d.ProjectInfo.original_path)
  return original_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProjectInfo::release_original_path() {
  // @@protoc_insertion_point(field_release:y3d.ProjectInfo.original_path)
  
  return original_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProjectInfo::set_allocated_original_path(::std::string* original_path) {
  if (original_path != NULL) {
    
  } else {
    
  }
  original_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), original_path);
  // @@protoc_insertion_point(field_set_allocated:y3d.ProjectInfo.original_path)
}

// repeated .y3d.YWorker workers = 9;
inline int ProjectInfo::workers_size() const {
  return workers_.size();
}
inline void ProjectInfo::clear_workers() {
  workers_.Clear();
}
inline const ::y3d::YWorker& ProjectInfo::workers(int index) const {
  // @@protoc_insertion_point(field_get:y3d.ProjectInfo.workers)
  return workers_.Get(index);
}
inline ::y3d::YWorker* ProjectInfo::mutable_workers(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.ProjectInfo.workers)
  return workers_.Mutable(index);
}
inline ::y3d::YWorker* ProjectInfo::add_workers() {
  // @@protoc_insertion_point(field_add:y3d.ProjectInfo.workers)
  return workers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::y3d::YWorker >*
ProjectInfo::mutable_workers() {
  // @@protoc_insertion_point(field_mutable_list:y3d.ProjectInfo.workers)
  return &workers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::y3d::YWorker >&
ProjectInfo::workers() const {
  // @@protoc_insertion_point(field_list:y3d.ProjectInfo.workers)
  return workers_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SettingData

// string aset_name = 1;
inline void SettingData::clear_aset_name() {
  aset_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SettingData::aset_name() const {
  // @@protoc_insertion_point(field_get:y3d.SettingData.aset_name)
  return aset_name_.GetNoArena();
}
inline void SettingData::set_aset_name(const ::std::string& value) {
  
  aset_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.SettingData.aset_name)
}
#if LANG_CXX11
inline void SettingData::set_aset_name(::std::string&& value) {
  
  aset_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.SettingData.aset_name)
}
#endif
inline void SettingData::set_aset_name(const char* value) {
  
  aset_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.SettingData.aset_name)
}
inline void SettingData::set_aset_name(const char* value, size_t size) {
  
  aset_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.SettingData.aset_name)
}
inline ::std::string* SettingData::mutable_aset_name() {
  
  // @@protoc_insertion_point(field_mutable:y3d.SettingData.aset_name)
  return aset_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SettingData::release_aset_name() {
  // @@protoc_insertion_point(field_release:y3d.SettingData.aset_name)
  
  return aset_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SettingData::set_allocated_aset_name(::std::string* aset_name) {
  if (aset_name != NULL) {
    
  } else {
    
  }
  aset_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), aset_name);
  // @@protoc_insertion_point(field_set_allocated:y3d.SettingData.aset_name)
}

// map<string, .google.protobuf.Any> data = 2;
inline int SettingData::data_size() const {
  return data_.size();
}
inline void SettingData::clear_data() {
  data_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::google::protobuf::Any >&
SettingData::data() const {
  // @@protoc_insertion_point(field_map:y3d.SettingData.data)
  return data_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::google::protobuf::Any >*
SettingData::mutable_data() {
  // @@protoc_insertion_point(field_mutable_map:y3d.SettingData.data)
  return data_.MutableMap();
}

// -------------------------------------------------------------------

// PSetting

// .y3d.SettingData extra = 1;
inline bool PSetting::has_extra() const {
  return this != internal_default_instance() && extra_ != NULL;
}
inline void PSetting::clear_extra() {
  if (GetArenaNoVirtual() == NULL && extra_ != NULL) delete extra_;
  extra_ = NULL;
}
inline const ::y3d::SettingData& PSetting::extra() const {
  // @@protoc_insertion_point(field_get:y3d.PSetting.extra)
  return extra_ != NULL ? *extra_
                         : *::y3d::SettingData::internal_default_instance();
}
inline ::y3d::SettingData* PSetting::mutable_extra() {
  
  if (extra_ == NULL) {
    extra_ = new ::y3d::SettingData;
  }
  // @@protoc_insertion_point(field_mutable:y3d.PSetting.extra)
  return extra_;
}
inline ::y3d::SettingData* PSetting::release_extra() {
  // @@protoc_insertion_point(field_release:y3d.PSetting.extra)
  
  ::y3d::SettingData* temp = extra_;
  extra_ = NULL;
  return temp;
}
inline void PSetting::set_allocated_extra(::y3d::SettingData* extra) {
  delete extra_;
  extra_ = extra;
  if (extra) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.PSetting.extra)
}

// int32 max_recent = 2;
inline void PSetting::clear_max_recent() {
  max_recent_ = 0;
}
inline ::google::protobuf::int32 PSetting::max_recent() const {
  // @@protoc_insertion_point(field_get:y3d.PSetting.max_recent)
  return max_recent_;
}
inline void PSetting::set_max_recent(::google::protobuf::int32 value) {
  
  max_recent_ = value;
  // @@protoc_insertion_point(field_set:y3d.PSetting.max_recent)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// YSystem

// string working_folder = 1;
inline void YSystem::clear_working_folder() {
  working_folder_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YSystem::working_folder() const {
  // @@protoc_insertion_point(field_get:y3d.YSystem.working_folder)
  return working_folder_.GetNoArena();
}
inline void YSystem::set_working_folder(const ::std::string& value) {
  
  working_folder_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YSystem.working_folder)
}
#if LANG_CXX11
inline void YSystem::set_working_folder(::std::string&& value) {
  
  working_folder_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.YSystem.working_folder)
}
#endif
inline void YSystem::set_working_folder(const char* value) {
  
  working_folder_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YSystem.working_folder)
}
inline void YSystem::set_working_folder(const char* value, size_t size) {
  
  working_folder_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YSystem.working_folder)
}
inline ::std::string* YSystem::mutable_working_folder() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YSystem.working_folder)
  return working_folder_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YSystem::release_working_folder() {
  // @@protoc_insertion_point(field_release:y3d.YSystem.working_folder)
  
  return working_folder_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YSystem::set_allocated_working_folder(::std::string* working_folder) {
  if (working_folder != NULL) {
    
  } else {
    
  }
  working_folder_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), working_folder);
  // @@protoc_insertion_point(field_set_allocated:y3d.YSystem.working_folder)
}

// .y3d.ProjectInfo default_info = 2;
inline bool YSystem::has_default_info() const {
  return this != internal_default_instance() && default_info_ != NULL;
}
inline void YSystem::clear_default_info() {
  if (GetArenaNoVirtual() == NULL && default_info_ != NULL) delete default_info_;
  default_info_ = NULL;
}
inline const ::y3d::ProjectInfo& YSystem::default_info() const {
  // @@protoc_insertion_point(field_get:y3d.YSystem.default_info)
  return default_info_ != NULL ? *default_info_
                         : *::y3d::ProjectInfo::internal_default_instance();
}
inline ::y3d::ProjectInfo* YSystem::mutable_default_info() {
  
  if (default_info_ == NULL) {
    default_info_ = new ::y3d::ProjectInfo;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YSystem.default_info)
  return default_info_;
}
inline ::y3d::ProjectInfo* YSystem::release_default_info() {
  // @@protoc_insertion_point(field_release:y3d.YSystem.default_info)
  
  ::y3d::ProjectInfo* temp = default_info_;
  default_info_ = NULL;
  return temp;
}
inline void YSystem::set_allocated_default_info(::y3d::ProjectInfo* default_info) {
  delete default_info_;
  default_info_ = default_info;
  if (default_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YSystem.default_info)
}

// .y3d.PSetting default_setting = 3;
inline bool YSystem::has_default_setting() const {
  return this != internal_default_instance() && default_setting_ != NULL;
}
inline void YSystem::clear_default_setting() {
  if (GetArenaNoVirtual() == NULL && default_setting_ != NULL) delete default_setting_;
  default_setting_ = NULL;
}
inline const ::y3d::PSetting& YSystem::default_setting() const {
  // @@protoc_insertion_point(field_get:y3d.YSystem.default_setting)
  return default_setting_ != NULL ? *default_setting_
                         : *::y3d::PSetting::internal_default_instance();
}
inline ::y3d::PSetting* YSystem::mutable_default_setting() {
  
  if (default_setting_ == NULL) {
    default_setting_ = new ::y3d::PSetting;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YSystem.default_setting)
  return default_setting_;
}
inline ::y3d::PSetting* YSystem::release_default_setting() {
  // @@protoc_insertion_point(field_release:y3d.YSystem.default_setting)
  
  ::y3d::PSetting* temp = default_setting_;
  default_setting_ = NULL;
  return temp;
}
inline void YSystem::set_allocated_default_setting(::y3d::PSetting* default_setting) {
  delete default_setting_;
  default_setting_ = default_setting;
  if (default_setting) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YSystem.default_setting)
}

// repeated .y3d.ProjectInfo projects = 4;
inline int YSystem::projects_size() const {
  return projects_.size();
}
inline void YSystem::clear_projects() {
  projects_.Clear();
}
inline const ::y3d::ProjectInfo& YSystem::projects(int index) const {
  // @@protoc_insertion_point(field_get:y3d.YSystem.projects)
  return projects_.Get(index);
}
inline ::y3d::ProjectInfo* YSystem::mutable_projects(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.YSystem.projects)
  return projects_.Mutable(index);
}
inline ::y3d::ProjectInfo* YSystem::add_projects() {
  // @@protoc_insertion_point(field_add:y3d.YSystem.projects)
  return projects_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::y3d::ProjectInfo >*
YSystem::mutable_projects() {
  // @@protoc_insertion_point(field_mutable_list:y3d.YSystem.projects)
  return &projects_;
}
inline const ::google::protobuf::RepeatedPtrField< ::y3d::ProjectInfo >&
YSystem::projects() const {
  // @@protoc_insertion_point(field_list:y3d.YSystem.projects)
  return projects_;
}

// map<string, .y3d.WorkerApp> apps = 5;
inline int YSystem::apps_size() const {
  return apps_.size();
}
inline void YSystem::clear_apps() {
  apps_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::y3d::WorkerApp >&
YSystem::apps() const {
  // @@protoc_insertion_point(field_map:y3d.YSystem.apps)
  return apps_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::y3d::WorkerApp >*
YSystem::mutable_apps() {
  // @@protoc_insertion_point(field_mutable_map:y3d.YSystem.apps)
  return apps_.MutableMap();
}

// .y3d.YMasterServer master_server = 6;
inline bool YSystem::has_master_server() const {
  return this != internal_default_instance() && master_server_ != NULL;
}
inline void YSystem::clear_master_server() {
  if (GetArenaNoVirtual() == NULL && master_server_ != NULL) delete master_server_;
  master_server_ = NULL;
}
inline const ::y3d::YMasterServer& YSystem::master_server() const {
  // @@protoc_insertion_point(field_get:y3d.YSystem.master_server)
  return master_server_ != NULL ? *master_server_
                         : *::y3d::YMasterServer::internal_default_instance();
}
inline ::y3d::YMasterServer* YSystem::mutable_master_server() {
  
  if (master_server_ == NULL) {
    master_server_ = new ::y3d::YMasterServer;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YSystem.master_server)
  return master_server_;
}
inline ::y3d::YMasterServer* YSystem::release_master_server() {
  // @@protoc_insertion_point(field_release:y3d.YSystem.master_server)
  
  ::y3d::YMasterServer* temp = master_server_;
  master_server_ = NULL;
  return temp;
}
inline void YSystem::set_allocated_master_server(::y3d::YMasterServer* master_server) {
  delete master_server_;
  master_server_ = master_server;
  if (master_server) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YSystem.master_server)
}

// -------------------------------------------------------------------

// NewProjectParam

// string fname = 1;
inline void NewProjectParam::clear_fname() {
  fname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NewProjectParam::fname() const {
  // @@protoc_insertion_point(field_get:y3d.NewProjectParam.fname)
  return fname_.GetNoArena();
}
inline void NewProjectParam::set_fname(const ::std::string& value) {
  
  fname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.NewProjectParam.fname)
}
#if LANG_CXX11
inline void NewProjectParam::set_fname(::std::string&& value) {
  
  fname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.NewProjectParam.fname)
}
#endif
inline void NewProjectParam::set_fname(const char* value) {
  
  fname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.NewProjectParam.fname)
}
inline void NewProjectParam::set_fname(const char* value, size_t size) {
  
  fname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.NewProjectParam.fname)
}
inline ::std::string* NewProjectParam::mutable_fname() {
  
  // @@protoc_insertion_point(field_mutable:y3d.NewProjectParam.fname)
  return fname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewProjectParam::release_fname() {
  // @@protoc_insertion_point(field_release:y3d.NewProjectParam.fname)
  
  return fname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewProjectParam::set_allocated_fname(::std::string* fname) {
  if (fname != NULL) {
    
  } else {
    
  }
  fname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fname);
  // @@protoc_insertion_point(field_set_allocated:y3d.NewProjectParam.fname)
}

// string folder = 2;
inline void NewProjectParam::clear_folder() {
  folder_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NewProjectParam::folder() const {
  // @@protoc_insertion_point(field_get:y3d.NewProjectParam.folder)
  return folder_.GetNoArena();
}
inline void NewProjectParam::set_folder(const ::std::string& value) {
  
  folder_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.NewProjectParam.folder)
}
#if LANG_CXX11
inline void NewProjectParam::set_folder(::std::string&& value) {
  
  folder_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.NewProjectParam.folder)
}
#endif
inline void NewProjectParam::set_folder(const char* value) {
  
  folder_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.NewProjectParam.folder)
}
inline void NewProjectParam::set_folder(const char* value, size_t size) {
  
  folder_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.NewProjectParam.folder)
}
inline ::std::string* NewProjectParam::mutable_folder() {
  
  // @@protoc_insertion_point(field_mutable:y3d.NewProjectParam.folder)
  return folder_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewProjectParam::release_folder() {
  // @@protoc_insertion_point(field_release:y3d.NewProjectParam.folder)
  
  return folder_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewProjectParam::set_allocated_folder(::std::string* folder) {
  if (folder != NULL) {
    
  } else {
    
  }
  folder_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), folder);
  // @@protoc_insertion_point(field_set_allocated:y3d.NewProjectParam.folder)
}

// string project_path = 3;
inline void NewProjectParam::clear_project_path() {
  project_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NewProjectParam::project_path() const {
  // @@protoc_insertion_point(field_get:y3d.NewProjectParam.project_path)
  return project_path_.GetNoArena();
}
inline void NewProjectParam::set_project_path(const ::std::string& value) {
  
  project_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.NewProjectParam.project_path)
}
#if LANG_CXX11
inline void NewProjectParam::set_project_path(::std::string&& value) {
  
  project_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.NewProjectParam.project_path)
}
#endif
inline void NewProjectParam::set_project_path(const char* value) {
  
  project_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.NewProjectParam.project_path)
}
inline void NewProjectParam::set_project_path(const char* value, size_t size) {
  
  project_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.NewProjectParam.project_path)
}
inline ::std::string* NewProjectParam::mutable_project_path() {
  
  // @@protoc_insertion_point(field_mutable:y3d.NewProjectParam.project_path)
  return project_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewProjectParam::release_project_path() {
  // @@protoc_insertion_point(field_release:y3d.NewProjectParam.project_path)
  
  return project_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewProjectParam::set_allocated_project_path(::std::string* project_path) {
  if (project_path != NULL) {
    
  } else {
    
  }
  project_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), project_path);
  // @@protoc_insertion_point(field_set_allocated:y3d.NewProjectParam.project_path)
}

// -------------------------------------------------------------------

// ResponseNProject

// .y3d.ProjectInfo pInfo = 1;
inline bool ResponseNProject::has_pinfo() const {
  return this != internal_default_instance() && pinfo_ != NULL;
}
inline void ResponseNProject::clear_pinfo() {
  if (GetArenaNoVirtual() == NULL && pinfo_ != NULL) delete pinfo_;
  pinfo_ = NULL;
}
inline const ::y3d::ProjectInfo& ResponseNProject::pinfo() const {
  // @@protoc_insertion_point(field_get:y3d.ResponseNProject.pInfo)
  return pinfo_ != NULL ? *pinfo_
                         : *::y3d::ProjectInfo::internal_default_instance();
}
inline ::y3d::ProjectInfo* ResponseNProject::mutable_pinfo() {
  
  if (pinfo_ == NULL) {
    pinfo_ = new ::y3d::ProjectInfo;
  }
  // @@protoc_insertion_point(field_mutable:y3d.ResponseNProject.pInfo)
  return pinfo_;
}
inline ::y3d::ProjectInfo* ResponseNProject::release_pinfo() {
  // @@protoc_insertion_point(field_release:y3d.ResponseNProject.pInfo)
  
  ::y3d::ProjectInfo* temp = pinfo_;
  pinfo_ = NULL;
  return temp;
}
inline void ResponseNProject::set_allocated_pinfo(::y3d::ProjectInfo* pinfo) {
  delete pinfo_;
  pinfo_ = pinfo;
  if (pinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.ResponseNProject.pInfo)
}

// .y3d.YAreaList yal = 2;
inline bool ResponseNProject::has_yal() const {
  return this != internal_default_instance() && yal_ != NULL;
}
inline void ResponseNProject::clear_yal() {
  if (GetArenaNoVirtual() == NULL && yal_ != NULL) delete yal_;
  yal_ = NULL;
}
inline const ::y3d::YAreaList& ResponseNProject::yal() const {
  // @@protoc_insertion_point(field_get:y3d.ResponseNProject.yal)
  return yal_ != NULL ? *yal_
                         : *::y3d::YAreaList::internal_default_instance();
}
inline ::y3d::YAreaList* ResponseNProject::mutable_yal() {
  
  if (yal_ == NULL) {
    yal_ = new ::y3d::YAreaList;
  }
  // @@protoc_insertion_point(field_mutable:y3d.ResponseNProject.yal)
  return yal_;
}
inline ::y3d::YAreaList* ResponseNProject::release_yal() {
  // @@protoc_insertion_point(field_release:y3d.ResponseNProject.yal)
  
  ::y3d::YAreaList* temp = yal_;
  yal_ = NULL;
  return temp;
}
inline void ResponseNProject::set_allocated_yal(::y3d::YAreaList* yal) {
  delete yal_;
  yal_ = yal;
  if (yal) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.ResponseNProject.yal)
}

// string err = 4;
inline void ResponseNProject::clear_err() {
  err_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseNProject::err() const {
  // @@protoc_insertion_point(field_get:y3d.ResponseNProject.err)
  return err_.GetNoArena();
}
inline void ResponseNProject::set_err(const ::std::string& value) {
  
  err_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.ResponseNProject.err)
}
#if LANG_CXX11
inline void ResponseNProject::set_err(::std::string&& value) {
  
  err_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.ResponseNProject.err)
}
#endif
inline void ResponseNProject::set_err(const char* value) {
  
  err_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.ResponseNProject.err)
}
inline void ResponseNProject::set_err(const char* value, size_t size) {
  
  err_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.ResponseNProject.err)
}
inline ::std::string* ResponseNProject::mutable_err() {
  
  // @@protoc_insertion_point(field_mutable:y3d.ResponseNProject.err)
  return err_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseNProject::release_err() {
  // @@protoc_insertion_point(field_release:y3d.ResponseNProject.err)
  
  return err_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseNProject::set_allocated_err(::std::string* err) {
  if (err != NULL) {
    
  } else {
    
  }
  err_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), err);
  // @@protoc_insertion_point(field_set_allocated:y3d.ResponseNProject.err)
}

// -------------------------------------------------------------------

// YJobAction

// .y3d.EUnwrap unwrap = 1;
inline bool YJobAction::has_unwrap() const {
  return action_case() == kUnwrap;
}
inline void YJobAction::set_has_unwrap() {
  _oneof_case_[0] = kUnwrap;
}
inline void YJobAction::clear_unwrap() {
  if (has_unwrap()) {
    delete action_.unwrap_;
    clear_has_action();
  }
}
inline  const ::y3d::EUnwrap& YJobAction::unwrap() const {
  // @@protoc_insertion_point(field_get:y3d.YJobAction.unwrap)
  return has_unwrap()
      ? *action_.unwrap_
      : ::y3d::EUnwrap::default_instance();
}
inline ::y3d::EUnwrap* YJobAction::mutable_unwrap() {
  if (!has_unwrap()) {
    clear_action();
    set_has_unwrap();
    action_.unwrap_ = new ::y3d::EUnwrap;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YJobAction.unwrap)
  return action_.unwrap_;
}
inline ::y3d::EUnwrap* YJobAction::release_unwrap() {
  // @@protoc_insertion_point(field_release:y3d.YJobAction.unwrap)
  if (has_unwrap()) {
    clear_has_action();
    ::y3d::EUnwrap* temp = action_.unwrap_;
    action_.unwrap_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void YJobAction::set_allocated_unwrap(::y3d::EUnwrap* unwrap) {
  clear_action();
  if (unwrap) {
    set_has_unwrap();
    action_.unwrap_ = unwrap;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YJobAction.unwrap)
}

// .y3d.EPacking pack = 2;
inline bool YJobAction::has_pack() const {
  return action_case() == kPack;
}
inline void YJobAction::set_has_pack() {
  _oneof_case_[0] = kPack;
}
inline void YJobAction::clear_pack() {
  if (has_pack()) {
    delete action_.pack_;
    clear_has_action();
  }
}
inline  const ::y3d::EPacking& YJobAction::pack() const {
  // @@protoc_insertion_point(field_get:y3d.YJobAction.pack)
  return has_pack()
      ? *action_.pack_
      : ::y3d::EPacking::default_instance();
}
inline ::y3d::EPacking* YJobAction::mutable_pack() {
  if (!has_pack()) {
    clear_action();
    set_has_pack();
    action_.pack_ = new ::y3d::EPacking;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YJobAction.pack)
  return action_.pack_;
}
inline ::y3d::EPacking* YJobAction::release_pack() {
  // @@protoc_insertion_point(field_release:y3d.YJobAction.pack)
  if (has_pack()) {
    clear_has_action();
    ::y3d::EPacking* temp = action_.pack_;
    action_.pack_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void YJobAction::set_allocated_pack(::y3d::EPacking* pack) {
  clear_action();
  if (pack) {
    set_has_pack();
    action_.pack_ = pack;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YJobAction.pack)
}

// .y3d.ELowpoly lowpoly = 3;
inline bool YJobAction::has_lowpoly() const {
  return action_case() == kLowpoly;
}
inline void YJobAction::set_has_lowpoly() {
  _oneof_case_[0] = kLowpoly;
}
inline void YJobAction::clear_lowpoly() {
  if (has_lowpoly()) {
    delete action_.lowpoly_;
    clear_has_action();
  }
}
inline  const ::y3d::ELowpoly& YJobAction::lowpoly() const {
  // @@protoc_insertion_point(field_get:y3d.YJobAction.lowpoly)
  return has_lowpoly()
      ? *action_.lowpoly_
      : ::y3d::ELowpoly::default_instance();
}
inline ::y3d::ELowpoly* YJobAction::mutable_lowpoly() {
  if (!has_lowpoly()) {
    clear_action();
    set_has_lowpoly();
    action_.lowpoly_ = new ::y3d::ELowpoly;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YJobAction.lowpoly)
  return action_.lowpoly_;
}
inline ::y3d::ELowpoly* YJobAction::release_lowpoly() {
  // @@protoc_insertion_point(field_release:y3d.YJobAction.lowpoly)
  if (has_lowpoly()) {
    clear_has_action();
    ::y3d::ELowpoly* temp = action_.lowpoly_;
    action_.lowpoly_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void YJobAction::set_allocated_lowpoly(::y3d::ELowpoly* lowpoly) {
  clear_action();
  if (lowpoly) {
    set_has_lowpoly();
    action_.lowpoly_ = lowpoly;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YJobAction.lowpoly)
}

// .y3d.ENormal bake_normal = 4;
inline bool YJobAction::has_bake_normal() const {
  return action_case() == kBakeNormal;
}
inline void YJobAction::set_has_bake_normal() {
  _oneof_case_[0] = kBakeNormal;
}
inline void YJobAction::clear_bake_normal() {
  if (has_bake_normal()) {
    delete action_.bake_normal_;
    clear_has_action();
  }
}
inline  const ::y3d::ENormal& YJobAction::bake_normal() const {
  // @@protoc_insertion_point(field_get:y3d.YJobAction.bake_normal)
  return has_bake_normal()
      ? *action_.bake_normal_
      : ::y3d::ENormal::default_instance();
}
inline ::y3d::ENormal* YJobAction::mutable_bake_normal() {
  if (!has_bake_normal()) {
    clear_action();
    set_has_bake_normal();
    action_.bake_normal_ = new ::y3d::ENormal;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YJobAction.bake_normal)
  return action_.bake_normal_;
}
inline ::y3d::ENormal* YJobAction::release_bake_normal() {
  // @@protoc_insertion_point(field_release:y3d.YJobAction.bake_normal)
  if (has_bake_normal()) {
    clear_has_action();
    ::y3d::ENormal* temp = action_.bake_normal_;
    action_.bake_normal_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void YJobAction::set_allocated_bake_normal(::y3d::ENormal* bake_normal) {
  clear_action();
  if (bake_normal) {
    set_has_bake_normal();
    action_.bake_normal_ = bake_normal;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YJobAction.bake_normal)
}

inline bool YJobAction::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void YJobAction::clear_has_action() {
  _oneof_case_[0] = ACTION_NOT_SET;
}
inline YJobAction::ActionCase YJobAction::action_case() const {
  return YJobAction::ActionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// YItemMesh

// .y3d.YMat bake_mat = 1;
inline bool YItemMesh::has_bake_mat() const {
  return this != internal_default_instance() && bake_mat_ != NULL;
}
inline void YItemMesh::clear_bake_mat() {
  if (GetArenaNoVirtual() == NULL && bake_mat_ != NULL) delete bake_mat_;
  bake_mat_ = NULL;
}
inline const ::y3d::YMat& YItemMesh::bake_mat() const {
  // @@protoc_insertion_point(field_get:y3d.YItemMesh.bake_mat)
  return bake_mat_ != NULL ? *bake_mat_
                         : *::y3d::YMat::internal_default_instance();
}
inline ::y3d::YMat* YItemMesh::mutable_bake_mat() {
  
  if (bake_mat_ == NULL) {
    bake_mat_ = new ::y3d::YMat;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YItemMesh.bake_mat)
  return bake_mat_;
}
inline ::y3d::YMat* YItemMesh::release_bake_mat() {
  // @@protoc_insertion_point(field_release:y3d.YItemMesh.bake_mat)
  
  ::y3d::YMat* temp = bake_mat_;
  bake_mat_ = NULL;
  return temp;
}
inline void YItemMesh::set_allocated_bake_mat(::y3d::YMat* bake_mat) {
  delete bake_mat_;
  bake_mat_ = bake_mat;
  if (bake_mat) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YItemMesh.bake_mat)
}

// .y3d.YBaseMap map = 2;
inline bool YItemMesh::has_map() const {
  return this != internal_default_instance() && map_ != NULL;
}
inline void YItemMesh::clear_map() {
  if (GetArenaNoVirtual() == NULL && map_ != NULL) delete map_;
  map_ = NULL;
}
inline const ::y3d::YBaseMap& YItemMesh::map() const {
  // @@protoc_insertion_point(field_get:y3d.YItemMesh.map)
  return map_ != NULL ? *map_
                         : *::y3d::YBaseMap::internal_default_instance();
}
inline ::y3d::YBaseMap* YItemMesh::mutable_map() {
  
  if (map_ == NULL) {
    map_ = new ::y3d::YBaseMap;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YItemMesh.map)
  return map_;
}
inline ::y3d::YBaseMap* YItemMesh::release_map() {
  // @@protoc_insertion_point(field_release:y3d.YItemMesh.map)
  
  ::y3d::YBaseMap* temp = map_;
  map_ = NULL;
  return temp;
}
inline void YItemMesh::set_allocated_map(::y3d::YBaseMap* map) {
  delete map_;
  map_ = map;
  if (map) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YItemMesh.map)
}

// .y3d.YMesh mesh = 3;
inline bool YItemMesh::has_mesh() const {
  return this != internal_default_instance() && mesh_ != NULL;
}
inline void YItemMesh::clear_mesh() {
  if (GetArenaNoVirtual() == NULL && mesh_ != NULL) delete mesh_;
  mesh_ = NULL;
}
inline const ::y3d::YMesh& YItemMesh::mesh() const {
  // @@protoc_insertion_point(field_get:y3d.YItemMesh.mesh)
  return mesh_ != NULL ? *mesh_
                         : *::y3d::YMesh::internal_default_instance();
}
inline ::y3d::YMesh* YItemMesh::mutable_mesh() {
  
  if (mesh_ == NULL) {
    mesh_ = new ::y3d::YMesh;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YItemMesh.mesh)
  return mesh_;
}
inline ::y3d::YMesh* YItemMesh::release_mesh() {
  // @@protoc_insertion_point(field_release:y3d.YItemMesh.mesh)
  
  ::y3d::YMesh* temp = mesh_;
  mesh_ = NULL;
  return temp;
}
inline void YItemMesh::set_allocated_mesh(::y3d::YMesh* mesh) {
  delete mesh_;
  mesh_ = mesh;
  if (mesh) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YItemMesh.mesh)
}

// repeated .y3d.YMesh meshes = 4;
inline int YItemMesh::meshes_size() const {
  return meshes_.size();
}
inline void YItemMesh::clear_meshes() {
  meshes_.Clear();
}
inline const ::y3d::YMesh& YItemMesh::meshes(int index) const {
  // @@protoc_insertion_point(field_get:y3d.YItemMesh.meshes)
  return meshes_.Get(index);
}
inline ::y3d::YMesh* YItemMesh::mutable_meshes(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.YItemMesh.meshes)
  return meshes_.Mutable(index);
}
inline ::y3d::YMesh* YItemMesh::add_meshes() {
  // @@protoc_insertion_point(field_add:y3d.YItemMesh.meshes)
  return meshes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::y3d::YMesh >*
YItemMesh::mutable_meshes() {
  // @@protoc_insertion_point(field_mutable_list:y3d.YItemMesh.meshes)
  return &meshes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::y3d::YMesh >&
YItemMesh::meshes() const {
  // @@protoc_insertion_point(field_list:y3d.YItemMesh.meshes)
  return meshes_;
}

// -------------------------------------------------------------------

// TestObject

// bool active = 1;
inline void TestObject::clear_active() {
  active_ = false;
}
inline bool TestObject::active() const {
  // @@protoc_insertion_point(field_get:y3d.TestObject.active)
  return active_;
}
inline void TestObject::set_active(bool value) {
  
  active_ = value;
  // @@protoc_insertion_point(field_set:y3d.TestObject.active)
}

// .y3d.YMat original_mat = 2;
inline bool TestObject::has_original_mat() const {
  return this != internal_default_instance() && original_mat_ != NULL;
}
inline void TestObject::clear_original_mat() {
  if (GetArenaNoVirtual() == NULL && original_mat_ != NULL) delete original_mat_;
  original_mat_ = NULL;
}
inline const ::y3d::YMat& TestObject::original_mat() const {
  // @@protoc_insertion_point(field_get:y3d.TestObject.original_mat)
  return original_mat_ != NULL ? *original_mat_
                         : *::y3d::YMat::internal_default_instance();
}
inline ::y3d::YMat* TestObject::mutable_original_mat() {
  
  if (original_mat_ == NULL) {
    original_mat_ = new ::y3d::YMat;
  }
  // @@protoc_insertion_point(field_mutable:y3d.TestObject.original_mat)
  return original_mat_;
}
inline ::y3d::YMat* TestObject::release_original_mat() {
  // @@protoc_insertion_point(field_release:y3d.TestObject.original_mat)
  
  ::y3d::YMat* temp = original_mat_;
  original_mat_ = NULL;
  return temp;
}
inline void TestObject::set_allocated_original_mat(::y3d::YMat* original_mat) {
  delete original_mat_;
  original_mat_ = original_mat;
  if (original_mat) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.TestObject.original_mat)
}

// string tname = 3;
inline void TestObject::clear_tname() {
  tname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TestObject::tname() const {
  // @@protoc_insertion_point(field_get:y3d.TestObject.tname)
  return tname_.GetNoArena();
}
inline void TestObject::set_tname(const ::std::string& value) {
  
  tname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.TestObject.tname)
}
#if LANG_CXX11
inline void TestObject::set_tname(::std::string&& value) {
  
  tname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.TestObject.tname)
}
#endif
inline void TestObject::set_tname(const char* value) {
  
  tname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.TestObject.tname)
}
inline void TestObject::set_tname(const char* value, size_t size) {
  
  tname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.TestObject.tname)
}
inline ::std::string* TestObject::mutable_tname() {
  
  // @@protoc_insertion_point(field_mutable:y3d.TestObject.tname)
  return tname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TestObject::release_tname() {
  // @@protoc_insertion_point(field_release:y3d.TestObject.tname)
  
  return tname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TestObject::set_allocated_tname(::std::string* tname) {
  if (tname != NULL) {
    
  } else {
    
  }
  tname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tname);
  // @@protoc_insertion_point(field_set_allocated:y3d.TestObject.tname)
}

// string oname = 4;
inline void TestObject::clear_oname() {
  oname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TestObject::oname() const {
  // @@protoc_insertion_point(field_get:y3d.TestObject.oname)
  return oname_.GetNoArena();
}
inline void TestObject::set_oname(const ::std::string& value) {
  
  oname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.TestObject.oname)
}
#if LANG_CXX11
inline void TestObject::set_oname(::std::string&& value) {
  
  oname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.TestObject.oname)
}
#endif
inline void TestObject::set_oname(const char* value) {
  
  oname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.TestObject.oname)
}
inline void TestObject::set_oname(const char* value, size_t size) {
  
  oname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.TestObject.oname)
}
inline ::std::string* TestObject::mutable_oname() {
  
  // @@protoc_insertion_point(field_mutable:y3d.TestObject.oname)
  return oname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TestObject::release_oname() {
  // @@protoc_insertion_point(field_release:y3d.TestObject.oname)
  
  return oname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TestObject::set_allocated_oname(::std::string* oname) {
  if (oname != NULL) {
    
  } else {
    
  }
  oname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), oname);
  // @@protoc_insertion_point(field_set_allocated:y3d.TestObject.oname)
}

// string save_path = 9;
inline void TestObject::clear_save_path() {
  save_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TestObject::save_path() const {
  // @@protoc_insertion_point(field_get:y3d.TestObject.save_path)
  return save_path_.GetNoArena();
}
inline void TestObject::set_save_path(const ::std::string& value) {
  
  save_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.TestObject.save_path)
}
#if LANG_CXX11
inline void TestObject::set_save_path(::std::string&& value) {
  
  save_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.TestObject.save_path)
}
#endif
inline void TestObject::set_save_path(const char* value) {
  
  save_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.TestObject.save_path)
}
inline void TestObject::set_save_path(const char* value, size_t size) {
  
  save_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.TestObject.save_path)
}
inline ::std::string* TestObject::mutable_save_path() {
  
  // @@protoc_insertion_point(field_mutable:y3d.TestObject.save_path)
  return save_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TestObject::release_save_path() {
  // @@protoc_insertion_point(field_release:y3d.TestObject.save_path)
  
  return save_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TestObject::set_allocated_save_path(::std::string* save_path) {
  if (save_path != NULL) {
    
  } else {
    
  }
  save_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), save_path);
  // @@protoc_insertion_point(field_set_allocated:y3d.TestObject.save_path)
}

// .y3d.YItemMesh out = 10;
inline bool TestObject::has_out() const {
  return this != internal_default_instance() && out_ != NULL;
}
inline void TestObject::clear_out() {
  if (GetArenaNoVirtual() == NULL && out_ != NULL) delete out_;
  out_ = NULL;
}
inline const ::y3d::YItemMesh& TestObject::out() const {
  // @@protoc_insertion_point(field_get:y3d.TestObject.out)
  return out_ != NULL ? *out_
                         : *::y3d::YItemMesh::internal_default_instance();
}
inline ::y3d::YItemMesh* TestObject::mutable_out() {
  
  if (out_ == NULL) {
    out_ = new ::y3d::YItemMesh;
  }
  // @@protoc_insertion_point(field_mutable:y3d.TestObject.out)
  return out_;
}
inline ::y3d::YItemMesh* TestObject::release_out() {
  // @@protoc_insertion_point(field_release:y3d.TestObject.out)
  
  ::y3d::YItemMesh* temp = out_;
  out_ = NULL;
  return temp;
}
inline void TestObject::set_allocated_out(::y3d::YItemMesh* out) {
  delete out_;
  out_ = out;
  if (out) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.TestObject.out)
}

// -------------------------------------------------------------------

// YJob

// string jname = 1;
inline void YJob::clear_jname() {
  jname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YJob::jname() const {
  // @@protoc_insertion_point(field_get:y3d.YJob.jname)
  return jname_.GetNoArena();
}
inline void YJob::set_jname(const ::std::string& value) {
  
  jname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YJob.jname)
}
#if LANG_CXX11
inline void YJob::set_jname(::std::string&& value) {
  
  jname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.YJob.jname)
}
#endif
inline void YJob::set_jname(const char* value) {
  
  jname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YJob.jname)
}
inline void YJob::set_jname(const char* value, size_t size) {
  
  jname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YJob.jname)
}
inline ::std::string* YJob::mutable_jname() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YJob.jname)
  return jname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YJob::release_jname() {
  // @@protoc_insertion_point(field_release:y3d.YJob.jname)
  
  return jname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YJob::set_allocated_jname(::std::string* jname) {
  if (jname != NULL) {
    
  } else {
    
  }
  jname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), jname);
  // @@protoc_insertion_point(field_set_allocated:y3d.YJob.jname)
}

// repeated .y3d.YJobAction act = 2;
inline int YJob::act_size() const {
  return act_.size();
}
inline void YJob::clear_act() {
  act_.Clear();
}
inline const ::y3d::YJobAction& YJob::act(int index) const {
  // @@protoc_insertion_point(field_get:y3d.YJob.act)
  return act_.Get(index);
}
inline ::y3d::YJobAction* YJob::mutable_act(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.YJob.act)
  return act_.Mutable(index);
}
inline ::y3d::YJobAction* YJob::add_act() {
  // @@protoc_insertion_point(field_add:y3d.YJob.act)
  return act_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::y3d::YJobAction >*
YJob::mutable_act() {
  // @@protoc_insertion_point(field_mutable_list:y3d.YJob.act)
  return &act_;
}
inline const ::google::protobuf::RepeatedPtrField< ::y3d::YJobAction >&
YJob::act() const {
  // @@protoc_insertion_point(field_list:y3d.YJob.act)
  return act_;
}

// .y3d.YObject obj = 3;
inline bool YJob::has_obj() const {
  return this != internal_default_instance() && obj_ != NULL;
}
inline void YJob::clear_obj() {
  if (GetArenaNoVirtual() == NULL && obj_ != NULL) delete obj_;
  obj_ = NULL;
}
inline const ::y3d::YObject& YJob::obj() const {
  // @@protoc_insertion_point(field_get:y3d.YJob.obj)
  return obj_ != NULL ? *obj_
                         : *::y3d::YObject::internal_default_instance();
}
inline ::y3d::YObject* YJob::mutable_obj() {
  
  if (obj_ == NULL) {
    obj_ = new ::y3d::YObject;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YJob.obj)
  return obj_;
}
inline ::y3d::YObject* YJob::release_obj() {
  // @@protoc_insertion_point(field_release:y3d.YJob.obj)
  
  ::y3d::YObject* temp = obj_;
  obj_ = NULL;
  return temp;
}
inline void YJob::set_allocated_obj(::y3d::YObject* obj) {
  delete obj_;
  obj_ = obj;
  if (obj) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YJob.obj)
}

// repeated .y3d.YObject objs = 4;
inline int YJob::objs_size() const {
  return objs_.size();
}
inline void YJob::clear_objs() {
  objs_.Clear();
}
inline const ::y3d::YObject& YJob::objs(int index) const {
  // @@protoc_insertion_point(field_get:y3d.YJob.objs)
  return objs_.Get(index);
}
inline ::y3d::YObject* YJob::mutable_objs(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.YJob.objs)
  return objs_.Mutable(index);
}
inline ::y3d::YObject* YJob::add_objs() {
  // @@protoc_insertion_point(field_add:y3d.YJob.objs)
  return objs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::y3d::YObject >*
YJob::mutable_objs() {
  // @@protoc_insertion_point(field_mutable_list:y3d.YJob.objs)
  return &objs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::y3d::YObject >&
YJob::objs() const {
  // @@protoc_insertion_point(field_list:y3d.YJob.objs)
  return objs_;
}

// .y3d.YItemMesh out = 5;
inline bool YJob::has_out() const {
  return this != internal_default_instance() && out_ != NULL;
}
inline void YJob::clear_out() {
  if (GetArenaNoVirtual() == NULL && out_ != NULL) delete out_;
  out_ = NULL;
}
inline const ::y3d::YItemMesh& YJob::out() const {
  // @@protoc_insertion_point(field_get:y3d.YJob.out)
  return out_ != NULL ? *out_
                         : *::y3d::YItemMesh::internal_default_instance();
}
inline ::y3d::YItemMesh* YJob::mutable_out() {
  
  if (out_ == NULL) {
    out_ = new ::y3d::YItemMesh;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YJob.out)
  return out_;
}
inline ::y3d::YItemMesh* YJob::release_out() {
  // @@protoc_insertion_point(field_release:y3d.YJob.out)
  
  ::y3d::YItemMesh* temp = out_;
  out_ = NULL;
  return temp;
}
inline void YJob::set_allocated_out(::y3d::YItemMesh* out) {
  delete out_;
  out_ = out;
  if (out) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YJob.out)
}

// repeated .y3d.TestObject tests = 7;
inline int YJob::tests_size() const {
  return tests_.size();
}
inline void YJob::clear_tests() {
  tests_.Clear();
}
inline const ::y3d::TestObject& YJob::tests(int index) const {
  // @@protoc_insertion_point(field_get:y3d.YJob.tests)
  return tests_.Get(index);
}
inline ::y3d::TestObject* YJob::mutable_tests(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.YJob.tests)
  return tests_.Mutable(index);
}
inline ::y3d::TestObject* YJob::add_tests() {
  // @@protoc_insertion_point(field_add:y3d.YJob.tests)
  return tests_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::y3d::TestObject >*
YJob::mutable_tests() {
  // @@protoc_insertion_point(field_mutable_list:y3d.YJob.tests)
  return &tests_;
}
inline const ::google::protobuf::RepeatedPtrField< ::y3d::TestObject >&
YJob::tests() const {
  // @@protoc_insertion_point(field_list:y3d.YJob.tests)
  return tests_;
}

// -------------------------------------------------------------------

// YJobList

// repeated .y3d.YJob jobs = 1;
inline int YJobList::jobs_size() const {
  return jobs_.size();
}
inline void YJobList::clear_jobs() {
  jobs_.Clear();
}
inline const ::y3d::YJob& YJobList::jobs(int index) const {
  // @@protoc_insertion_point(field_get:y3d.YJobList.jobs)
  return jobs_.Get(index);
}
inline ::y3d::YJob* YJobList::mutable_jobs(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.YJobList.jobs)
  return jobs_.Mutable(index);
}
inline ::y3d::YJob* YJobList::add_jobs() {
  // @@protoc_insertion_point(field_add:y3d.YJobList.jobs)
  return jobs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::y3d::YJob >*
YJobList::mutable_jobs() {
  // @@protoc_insertion_point(field_mutable_list:y3d.YJobList.jobs)
  return &jobs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::y3d::YJob >&
YJobList::jobs() const {
  // @@protoc_insertion_point(field_list:y3d.YJobList.jobs)
  return jobs_;
}

// -------------------------------------------------------------------

// YWorker

// int32 wid = 1;
inline void YWorker::clear_wid() {
  wid_ = 0;
}
inline ::google::protobuf::int32 YWorker::wid() const {
  // @@protoc_insertion_point(field_get:y3d.YWorker.wid)
  return wid_;
}
inline void YWorker::set_wid(::google::protobuf::int32 value) {
  
  wid_ = value;
  // @@protoc_insertion_point(field_set:y3d.YWorker.wid)
}

// string wname = 2;
inline void YWorker::clear_wname() {
  wname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YWorker::wname() const {
  // @@protoc_insertion_point(field_get:y3d.YWorker.wname)
  return wname_.GetNoArena();
}
inline void YWorker::set_wname(const ::std::string& value) {
  
  wname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YWorker.wname)
}
#if LANG_CXX11
inline void YWorker::set_wname(::std::string&& value) {
  
  wname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.YWorker.wname)
}
#endif
inline void YWorker::set_wname(const char* value) {
  
  wname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YWorker.wname)
}
inline void YWorker::set_wname(const char* value, size_t size) {
  
  wname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YWorker.wname)
}
inline ::std::string* YWorker::mutable_wname() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YWorker.wname)
  return wname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YWorker::release_wname() {
  // @@protoc_insertion_point(field_release:y3d.YWorker.wname)
  
  return wname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YWorker::set_allocated_wname(::std::string* wname) {
  if (wname != NULL) {
    
  } else {
    
  }
  wname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), wname);
  // @@protoc_insertion_point(field_set_allocated:y3d.YWorker.wname)
}

// string ip_address = 3;
inline void YWorker::clear_ip_address() {
  ip_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YWorker::ip_address() const {
  // @@protoc_insertion_point(field_get:y3d.YWorker.ip_address)
  return ip_address_.GetNoArena();
}
inline void YWorker::set_ip_address(const ::std::string& value) {
  
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YWorker.ip_address)
}
#if LANG_CXX11
inline void YWorker::set_ip_address(::std::string&& value) {
  
  ip_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.YWorker.ip_address)
}
#endif
inline void YWorker::set_ip_address(const char* value) {
  
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YWorker.ip_address)
}
inline void YWorker::set_ip_address(const char* value, size_t size) {
  
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YWorker.ip_address)
}
inline ::std::string* YWorker::mutable_ip_address() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YWorker.ip_address)
  return ip_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YWorker::release_ip_address() {
  // @@protoc_insertion_point(field_release:y3d.YWorker.ip_address)
  
  return ip_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YWorker::set_allocated_ip_address(::std::string* ip_address) {
  if (ip_address != NULL) {
    
  } else {
    
  }
  ip_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip_address);
  // @@protoc_insertion_point(field_set_allocated:y3d.YWorker.ip_address)
}

// int32 process_id = 4;
inline void YWorker::clear_process_id() {
  process_id_ = 0;
}
inline ::google::protobuf::int32 YWorker::process_id() const {
  // @@protoc_insertion_point(field_get:y3d.YWorker.process_id)
  return process_id_;
}
inline void YWorker::set_process_id(::google::protobuf::int32 value) {
  
  process_id_ = value;
  // @@protoc_insertion_point(field_set:y3d.YWorker.process_id)
}

// .y3d.YWorker.ServingStatus status = 5;
inline void YWorker::clear_status() {
  status_ = 0;
}
inline ::y3d::YWorker_ServingStatus YWorker::status() const {
  // @@protoc_insertion_point(field_get:y3d.YWorker.status)
  return static_cast< ::y3d::YWorker_ServingStatus >(status_);
}
inline void YWorker::set_status(::y3d::YWorker_ServingStatus value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:y3d.YWorker.status)
}

// -------------------------------------------------------------------

// YSubWorker

// int32 sid = 1;
inline void YSubWorker::clear_sid() {
  sid_ = 0;
}
inline ::google::protobuf::int32 YSubWorker::sid() const {
  // @@protoc_insertion_point(field_get:y3d.YSubWorker.sid)
  return sid_;
}
inline void YSubWorker::set_sid(::google::protobuf::int32 value) {
  
  sid_ = value;
  // @@protoc_insertion_point(field_set:y3d.YSubWorker.sid)
}

// string sname = 2;
inline void YSubWorker::clear_sname() {
  sname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YSubWorker::sname() const {
  // @@protoc_insertion_point(field_get:y3d.YSubWorker.sname)
  return sname_.GetNoArena();
}
inline void YSubWorker::set_sname(const ::std::string& value) {
  
  sname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YSubWorker.sname)
}
#if LANG_CXX11
inline void YSubWorker::set_sname(::std::string&& value) {
  
  sname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.YSubWorker.sname)
}
#endif
inline void YSubWorker::set_sname(const char* value) {
  
  sname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YSubWorker.sname)
}
inline void YSubWorker::set_sname(const char* value, size_t size) {
  
  sname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YSubWorker.sname)
}
inline ::std::string* YSubWorker::mutable_sname() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YSubWorker.sname)
  return sname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YSubWorker::release_sname() {
  // @@protoc_insertion_point(field_release:y3d.YSubWorker.sname)
  
  return sname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YSubWorker::set_allocated_sname(::std::string* sname) {
  if (sname != NULL) {
    
  } else {
    
  }
  sname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sname);
  // @@protoc_insertion_point(field_set_allocated:y3d.YSubWorker.sname)
}

// string asset_folder = 3;
inline void YSubWorker::clear_asset_folder() {
  asset_folder_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YSubWorker::asset_folder() const {
  // @@protoc_insertion_point(field_get:y3d.YSubWorker.asset_folder)
  return asset_folder_.GetNoArena();
}
inline void YSubWorker::set_asset_folder(const ::std::string& value) {
  
  asset_folder_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YSubWorker.asset_folder)
}
#if LANG_CXX11
inline void YSubWorker::set_asset_folder(::std::string&& value) {
  
  asset_folder_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.YSubWorker.asset_folder)
}
#endif
inline void YSubWorker::set_asset_folder(const char* value) {
  
  asset_folder_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YSubWorker.asset_folder)
}
inline void YSubWorker::set_asset_folder(const char* value, size_t size) {
  
  asset_folder_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YSubWorker.asset_folder)
}
inline ::std::string* YSubWorker::mutable_asset_folder() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YSubWorker.asset_folder)
  return asset_folder_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YSubWorker::release_asset_folder() {
  // @@protoc_insertion_point(field_release:y3d.YSubWorker.asset_folder)
  
  return asset_folder_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YSubWorker::set_allocated_asset_folder(::std::string* asset_folder) {
  if (asset_folder != NULL) {
    
  } else {
    
  }
  asset_folder_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asset_folder);
  // @@protoc_insertion_point(field_set_allocated:y3d.YSubWorker.asset_folder)
}

// .y3d.YWorker worker = 4;
inline bool YSubWorker::has_worker() const {
  return this != internal_default_instance() && worker_ != NULL;
}
inline void YSubWorker::clear_worker() {
  if (GetArenaNoVirtual() == NULL && worker_ != NULL) delete worker_;
  worker_ = NULL;
}
inline const ::y3d::YWorker& YSubWorker::worker() const {
  // @@protoc_insertion_point(field_get:y3d.YSubWorker.worker)
  return worker_ != NULL ? *worker_
                         : *::y3d::YWorker::internal_default_instance();
}
inline ::y3d::YWorker* YSubWorker::mutable_worker() {
  
  if (worker_ == NULL) {
    worker_ = new ::y3d::YWorker;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YSubWorker.worker)
  return worker_;
}
inline ::y3d::YWorker* YSubWorker::release_worker() {
  // @@protoc_insertion_point(field_release:y3d.YSubWorker.worker)
  
  ::y3d::YWorker* temp = worker_;
  worker_ = NULL;
  return temp;
}
inline void YSubWorker::set_allocated_worker(::y3d::YWorker* worker) {
  delete worker_;
  worker_ = worker;
  if (worker) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YSubWorker.worker)
}

// -------------------------------------------------------------------

// YMainWorker

// .y3d.YSubWorker main_worker = 1;
inline bool YMainWorker::has_main_worker() const {
  return this != internal_default_instance() && main_worker_ != NULL;
}
inline void YMainWorker::clear_main_worker() {
  if (GetArenaNoVirtual() == NULL && main_worker_ != NULL) delete main_worker_;
  main_worker_ = NULL;
}
inline const ::y3d::YSubWorker& YMainWorker::main_worker() const {
  // @@protoc_insertion_point(field_get:y3d.YMainWorker.main_worker)
  return main_worker_ != NULL ? *main_worker_
                         : *::y3d::YSubWorker::internal_default_instance();
}
inline ::y3d::YSubWorker* YMainWorker::mutable_main_worker() {
  
  if (main_worker_ == NULL) {
    main_worker_ = new ::y3d::YSubWorker;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YMainWorker.main_worker)
  return main_worker_;
}
inline ::y3d::YSubWorker* YMainWorker::release_main_worker() {
  // @@protoc_insertion_point(field_release:y3d.YMainWorker.main_worker)
  
  ::y3d::YSubWorker* temp = main_worker_;
  main_worker_ = NULL;
  return temp;
}
inline void YMainWorker::set_allocated_main_worker(::y3d::YSubWorker* main_worker) {
  delete main_worker_;
  main_worker_ = main_worker;
  if (main_worker) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YMainWorker.main_worker)
}

// repeated .y3d.YSubWorker workers = 2;
inline int YMainWorker::workers_size() const {
  return workers_.size();
}
inline void YMainWorker::clear_workers() {
  workers_.Clear();
}
inline const ::y3d::YSubWorker& YMainWorker::workers(int index) const {
  // @@protoc_insertion_point(field_get:y3d.YMainWorker.workers)
  return workers_.Get(index);
}
inline ::y3d::YSubWorker* YMainWorker::mutable_workers(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.YMainWorker.workers)
  return workers_.Mutable(index);
}
inline ::y3d::YSubWorker* YMainWorker::add_workers() {
  // @@protoc_insertion_point(field_add:y3d.YMainWorker.workers)
  return workers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::y3d::YSubWorker >*
YMainWorker::mutable_workers() {
  // @@protoc_insertion_point(field_mutable_list:y3d.YMainWorker.workers)
  return &workers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::y3d::YSubWorker >&
YMainWorker::workers() const {
  // @@protoc_insertion_point(field_list:y3d.YMainWorker.workers)
  return workers_;
}

// string working_project = 3;
inline void YMainWorker::clear_working_project() {
  working_project_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YMainWorker::working_project() const {
  // @@protoc_insertion_point(field_get:y3d.YMainWorker.working_project)
  return working_project_.GetNoArena();
}
inline void YMainWorker::set_working_project(const ::std::string& value) {
  
  working_project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YMainWorker.working_project)
}
#if LANG_CXX11
inline void YMainWorker::set_working_project(::std::string&& value) {
  
  working_project_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.YMainWorker.working_project)
}
#endif
inline void YMainWorker::set_working_project(const char* value) {
  
  working_project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YMainWorker.working_project)
}
inline void YMainWorker::set_working_project(const char* value, size_t size) {
  
  working_project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YMainWorker.working_project)
}
inline ::std::string* YMainWorker::mutable_working_project() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YMainWorker.working_project)
  return working_project_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YMainWorker::release_working_project() {
  // @@protoc_insertion_point(field_release:y3d.YMainWorker.working_project)
  
  return working_project_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YMainWorker::set_allocated_working_project(::std::string* working_project) {
  if (working_project != NULL) {
    
  } else {
    
  }
  working_project_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), working_project);
  // @@protoc_insertion_point(field_set_allocated:y3d.YMainWorker.working_project)
}

// -------------------------------------------------------------------

// YWorkerList

// repeated .y3d.YWorker workers = 1;
inline int YWorkerList::workers_size() const {
  return workers_.size();
}
inline void YWorkerList::clear_workers() {
  workers_.Clear();
}
inline const ::y3d::YWorker& YWorkerList::workers(int index) const {
  // @@protoc_insertion_point(field_get:y3d.YWorkerList.workers)
  return workers_.Get(index);
}
inline ::y3d::YWorker* YWorkerList::mutable_workers(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.YWorkerList.workers)
  return workers_.Mutable(index);
}
inline ::y3d::YWorker* YWorkerList::add_workers() {
  // @@protoc_insertion_point(field_add:y3d.YWorkerList.workers)
  return workers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::y3d::YWorker >*
YWorkerList::mutable_workers() {
  // @@protoc_insertion_point(field_mutable_list:y3d.YWorkerList.workers)
  return &workers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::y3d::YWorker >&
YWorkerList::workers() const {
  // @@protoc_insertion_point(field_list:y3d.YWorkerList.workers)
  return workers_;
}

// -------------------------------------------------------------------

// YWorkerRequest

// bool call_in_app = 1;
inline void YWorkerRequest::clear_call_in_app() {
  call_in_app_ = false;
}
inline bool YWorkerRequest::call_in_app() const {
  // @@protoc_insertion_point(field_get:y3d.YWorkerRequest.call_in_app)
  return call_in_app_;
}
inline void YWorkerRequest::set_call_in_app(bool value) {
  
  call_in_app_ = value;
  // @@protoc_insertion_point(field_set:y3d.YWorkerRequest.call_in_app)
}

// bool slient = 2;
inline void YWorkerRequest::clear_slient() {
  slient_ = false;
}
inline bool YWorkerRequest::slient() const {
  // @@protoc_insertion_point(field_get:y3d.YWorkerRequest.slient)
  return slient_;
}
inline void YWorkerRequest::set_slient(bool value) {
  
  slient_ = value;
  // @@protoc_insertion_point(field_set:y3d.YWorkerRequest.slient)
}

// .y3d.WorkerApp app = 3;
inline bool YWorkerRequest::has_app() const {
  return this != internal_default_instance() && app_ != NULL;
}
inline void YWorkerRequest::clear_app() {
  if (GetArenaNoVirtual() == NULL && app_ != NULL) delete app_;
  app_ = NULL;
}
inline const ::y3d::WorkerApp& YWorkerRequest::app() const {
  // @@protoc_insertion_point(field_get:y3d.YWorkerRequest.app)
  return app_ != NULL ? *app_
                         : *::y3d::WorkerApp::internal_default_instance();
}
inline ::y3d::WorkerApp* YWorkerRequest::mutable_app() {
  
  if (app_ == NULL) {
    app_ = new ::y3d::WorkerApp;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YWorkerRequest.app)
  return app_;
}
inline ::y3d::WorkerApp* YWorkerRequest::release_app() {
  // @@protoc_insertion_point(field_release:y3d.YWorkerRequest.app)
  
  ::y3d::WorkerApp* temp = app_;
  app_ = NULL;
  return temp;
}
inline void YWorkerRequest::set_allocated_app(::y3d::WorkerApp* app) {
  delete app_;
  app_ = app;
  if (app) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YWorkerRequest.app)
}

// -------------------------------------------------------------------

// WorkerApp

// string wname = 1;
inline void WorkerApp::clear_wname() {
  wname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WorkerApp::wname() const {
  // @@protoc_insertion_point(field_get:y3d.WorkerApp.wname)
  return wname_.GetNoArena();
}
inline void WorkerApp::set_wname(const ::std::string& value) {
  
  wname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.WorkerApp.wname)
}
#if LANG_CXX11
inline void WorkerApp::set_wname(::std::string&& value) {
  
  wname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.WorkerApp.wname)
}
#endif
inline void WorkerApp::set_wname(const char* value) {
  
  wname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.WorkerApp.wname)
}
inline void WorkerApp::set_wname(const char* value, size_t size) {
  
  wname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.WorkerApp.wname)
}
inline ::std::string* WorkerApp::mutable_wname() {
  
  // @@protoc_insertion_point(field_mutable:y3d.WorkerApp.wname)
  return wname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WorkerApp::release_wname() {
  // @@protoc_insertion_point(field_release:y3d.WorkerApp.wname)
  
  return wname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WorkerApp::set_allocated_wname(::std::string* wname) {
  if (wname != NULL) {
    
  } else {
    
  }
  wname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), wname);
  // @@protoc_insertion_point(field_set_allocated:y3d.WorkerApp.wname)
}

// string path_run = 2;
inline void WorkerApp::clear_path_run() {
  path_run_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WorkerApp::path_run() const {
  // @@protoc_insertion_point(field_get:y3d.WorkerApp.path_run)
  return path_run_.GetNoArena();
}
inline void WorkerApp::set_path_run(const ::std::string& value) {
  
  path_run_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.WorkerApp.path_run)
}
#if LANG_CXX11
inline void WorkerApp::set_path_run(::std::string&& value) {
  
  path_run_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.WorkerApp.path_run)
}
#endif
inline void WorkerApp::set_path_run(const char* value) {
  
  path_run_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.WorkerApp.path_run)
}
inline void WorkerApp::set_path_run(const char* value, size_t size) {
  
  path_run_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.WorkerApp.path_run)
}
inline ::std::string* WorkerApp::mutable_path_run() {
  
  // @@protoc_insertion_point(field_mutable:y3d.WorkerApp.path_run)
  return path_run_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WorkerApp::release_path_run() {
  // @@protoc_insertion_point(field_release:y3d.WorkerApp.path_run)
  
  return path_run_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WorkerApp::set_allocated_path_run(::std::string* path_run) {
  if (path_run != NULL) {
    
  } else {
    
  }
  path_run_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path_run);
  // @@protoc_insertion_point(field_set_allocated:y3d.WorkerApp.path_run)
}

// string extra = 3;
inline void WorkerApp::clear_extra() {
  extra_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WorkerApp::extra() const {
  // @@protoc_insertion_point(field_get:y3d.WorkerApp.extra)
  return extra_.GetNoArena();
}
inline void WorkerApp::set_extra(const ::std::string& value) {
  
  extra_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.WorkerApp.extra)
}
#if LANG_CXX11
inline void WorkerApp::set_extra(::std::string&& value) {
  
  extra_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.WorkerApp.extra)
}
#endif
inline void WorkerApp::set_extra(const char* value) {
  
  extra_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.WorkerApp.extra)
}
inline void WorkerApp::set_extra(const char* value, size_t size) {
  
  extra_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.WorkerApp.extra)
}
inline ::std::string* WorkerApp::mutable_extra() {
  
  // @@protoc_insertion_point(field_mutable:y3d.WorkerApp.extra)
  return extra_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WorkerApp::release_extra() {
  // @@protoc_insertion_point(field_release:y3d.WorkerApp.extra)
  
  return extra_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WorkerApp::set_allocated_extra(::std::string* extra) {
  if (extra != NULL) {
    
  } else {
    
  }
  extra_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), extra);
  // @@protoc_insertion_point(field_set_allocated:y3d.WorkerApp.extra)
}

// -------------------------------------------------------------------

// YWorkerResponse

// .y3d.YWorkerList wlist = 1;
inline bool YWorkerResponse::has_wlist() const {
  return this != internal_default_instance() && wlist_ != NULL;
}
inline void YWorkerResponse::clear_wlist() {
  if (GetArenaNoVirtual() == NULL && wlist_ != NULL) delete wlist_;
  wlist_ = NULL;
}
inline const ::y3d::YWorkerList& YWorkerResponse::wlist() const {
  // @@protoc_insertion_point(field_get:y3d.YWorkerResponse.wlist)
  return wlist_ != NULL ? *wlist_
                         : *::y3d::YWorkerList::internal_default_instance();
}
inline ::y3d::YWorkerList* YWorkerResponse::mutable_wlist() {
  
  if (wlist_ == NULL) {
    wlist_ = new ::y3d::YWorkerList;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YWorkerResponse.wlist)
  return wlist_;
}
inline ::y3d::YWorkerList* YWorkerResponse::release_wlist() {
  // @@protoc_insertion_point(field_release:y3d.YWorkerResponse.wlist)
  
  ::y3d::YWorkerList* temp = wlist_;
  wlist_ = NULL;
  return temp;
}
inline void YWorkerResponse::set_allocated_wlist(::y3d::YWorkerList* wlist) {
  delete wlist_;
  wlist_ = wlist;
  if (wlist) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YWorkerResponse.wlist)
}

// .y3d.YWorker worker = 2;
inline bool YWorkerResponse::has_worker() const {
  return this != internal_default_instance() && worker_ != NULL;
}
inline void YWorkerResponse::clear_worker() {
  if (GetArenaNoVirtual() == NULL && worker_ != NULL) delete worker_;
  worker_ = NULL;
}
inline const ::y3d::YWorker& YWorkerResponse::worker() const {
  // @@protoc_insertion_point(field_get:y3d.YWorkerResponse.worker)
  return worker_ != NULL ? *worker_
                         : *::y3d::YWorker::internal_default_instance();
}
inline ::y3d::YWorker* YWorkerResponse::mutable_worker() {
  
  if (worker_ == NULL) {
    worker_ = new ::y3d::YWorker;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YWorkerResponse.worker)
  return worker_;
}
inline ::y3d::YWorker* YWorkerResponse::release_worker() {
  // @@protoc_insertion_point(field_release:y3d.YWorkerResponse.worker)
  
  ::y3d::YWorker* temp = worker_;
  worker_ = NULL;
  return temp;
}
inline void YWorkerResponse::set_allocated_worker(::y3d::YWorker* worker) {
  delete worker_;
  worker_ = worker;
  if (worker) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YWorkerResponse.worker)
}

// bool error = 3;
inline void YWorkerResponse::clear_error() {
  error_ = false;
}
inline bool YWorkerResponse::error() const {
  // @@protoc_insertion_point(field_get:y3d.YWorkerResponse.error)
  return error_;
}
inline void YWorkerResponse::set_error(bool value) {
  
  error_ = value;
  // @@protoc_insertion_point(field_set:y3d.YWorkerResponse.error)
}

// string message = 4;
inline void YWorkerResponse::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YWorkerResponse::message() const {
  // @@protoc_insertion_point(field_get:y3d.YWorkerResponse.message)
  return message_.GetNoArena();
}
inline void YWorkerResponse::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YWorkerResponse.message)
}
#if LANG_CXX11
inline void YWorkerResponse::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.YWorkerResponse.message)
}
#endif
inline void YWorkerResponse::set_message(const char* value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YWorkerResponse.message)
}
inline void YWorkerResponse::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YWorkerResponse.message)
}
inline ::std::string* YWorkerResponse::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YWorkerResponse.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YWorkerResponse::release_message() {
  // @@protoc_insertion_point(field_release:y3d.YWorkerResponse.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YWorkerResponse::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:y3d.YWorkerResponse.message)
}

// -------------------------------------------------------------------

// YMasterServer

// string mname = 1;
inline void YMasterServer::clear_mname() {
  mname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YMasterServer::mname() const {
  // @@protoc_insertion_point(field_get:y3d.YMasterServer.mname)
  return mname_.GetNoArena();
}
inline void YMasterServer::set_mname(const ::std::string& value) {
  
  mname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YMasterServer.mname)
}
#if LANG_CXX11
inline void YMasterServer::set_mname(::std::string&& value) {
  
  mname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.YMasterServer.mname)
}
#endif
inline void YMasterServer::set_mname(const char* value) {
  
  mname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YMasterServer.mname)
}
inline void YMasterServer::set_mname(const char* value, size_t size) {
  
  mname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YMasterServer.mname)
}
inline ::std::string* YMasterServer::mutable_mname() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YMasterServer.mname)
  return mname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YMasterServer::release_mname() {
  // @@protoc_insertion_point(field_release:y3d.YMasterServer.mname)
  
  return mname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YMasterServer::set_allocated_mname(::std::string* mname) {
  if (mname != NULL) {
    
  } else {
    
  }
  mname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mname);
  // @@protoc_insertion_point(field_set_allocated:y3d.YMasterServer.mname)
}

// string address = 2;
inline void YMasterServer::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YMasterServer::address() const {
  // @@protoc_insertion_point(field_get:y3d.YMasterServer.address)
  return address_.GetNoArena();
}
inline void YMasterServer::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YMasterServer.address)
}
#if LANG_CXX11
inline void YMasterServer::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.YMasterServer.address)
}
#endif
inline void YMasterServer::set_address(const char* value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YMasterServer.address)
}
inline void YMasterServer::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YMasterServer.address)
}
inline ::std::string* YMasterServer::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YMasterServer.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YMasterServer::release_address() {
  // @@protoc_insertion_point(field_release:y3d.YMasterServer.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YMasterServer::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:y3d.YMasterServer.address)
}

// int32 port = 5;
inline void YMasterServer::clear_port() {
  port_ = 0;
}
inline ::google::protobuf::int32 YMasterServer::port() const {
  // @@protoc_insertion_point(field_get:y3d.YMasterServer.port)
  return port_;
}
inline void YMasterServer::set_port(::google::protobuf::int32 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:y3d.YMasterServer.port)
}

// string shared_folder = 3;
inline void YMasterServer::clear_shared_folder() {
  shared_folder_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YMasterServer::shared_folder() const {
  // @@protoc_insertion_point(field_get:y3d.YMasterServer.shared_folder)
  return shared_folder_.GetNoArena();
}
inline void YMasterServer::set_shared_folder(const ::std::string& value) {
  
  shared_folder_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YMasterServer.shared_folder)
}
#if LANG_CXX11
inline void YMasterServer::set_shared_folder(::std::string&& value) {
  
  shared_folder_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.YMasterServer.shared_folder)
}
#endif
inline void YMasterServer::set_shared_folder(const char* value) {
  
  shared_folder_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YMasterServer.shared_folder)
}
inline void YMasterServer::set_shared_folder(const char* value, size_t size) {
  
  shared_folder_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YMasterServer.shared_folder)
}
inline ::std::string* YMasterServer::mutable_shared_folder() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YMasterServer.shared_folder)
  return shared_folder_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YMasterServer::release_shared_folder() {
  // @@protoc_insertion_point(field_release:y3d.YMasterServer.shared_folder)
  
  return shared_folder_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YMasterServer::set_allocated_shared_folder(::std::string* shared_folder) {
  if (shared_folder != NULL) {
    
  } else {
    
  }
  shared_folder_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), shared_folder);
  // @@protoc_insertion_point(field_set_allocated:y3d.YMasterServer.shared_folder)
}

// repeated .y3d.YMainWorker main_workers = 4;
inline int YMasterServer::main_workers_size() const {
  return main_workers_.size();
}
inline void YMasterServer::clear_main_workers() {
  main_workers_.Clear();
}
inline const ::y3d::YMainWorker& YMasterServer::main_workers(int index) const {
  // @@protoc_insertion_point(field_get:y3d.YMasterServer.main_workers)
  return main_workers_.Get(index);
}
inline ::y3d::YMainWorker* YMasterServer::mutable_main_workers(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.YMasterServer.main_workers)
  return main_workers_.Mutable(index);
}
inline ::y3d::YMainWorker* YMasterServer::add_main_workers() {
  // @@protoc_insertion_point(field_add:y3d.YMasterServer.main_workers)
  return main_workers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::y3d::YMainWorker >*
YMasterServer::mutable_main_workers() {
  // @@protoc_insertion_point(field_mutable_list:y3d.YMasterServer.main_workers)
  return &main_workers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::y3d::YMainWorker >&
YMasterServer::main_workers() const {
  // @@protoc_insertion_point(field_list:y3d.YMasterServer.main_workers)
  return main_workers_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace y3d

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::y3d::YResource_ResourceType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::y3d::YResource_ResourceType>() {
  return ::y3d::YResource_ResourceType_descriptor();
}
template <> struct is_proto_enum< ::y3d::YMesh_MeshType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::y3d::YMesh_MeshType>() {
  return ::y3d::YMesh_MeshType_descriptor();
}
template <> struct is_proto_enum< ::y3d::YMesh_XrefStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::y3d::YMesh_XrefStatus>() {
  return ::y3d::YMesh_XrefStatus_descriptor();
}
template <> struct is_proto_enum< ::y3d::LPoly3DMax_OpMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::y3d::LPoly3DMax_OpMode>() {
  return ::y3d::LPoly3DMax_OpMode_descriptor();
}
template <> struct is_proto_enum< ::y3d::LPoly3DMax_NormalMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::y3d::LPoly3DMax_NormalMode>() {
  return ::y3d::LPoly3DMax_NormalMode_descriptor();
}
template <> struct is_proto_enum< ::y3d::YWorker_ServingStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::y3d::YWorker_ServingStatus>() {
  return ::y3d::YWorker_ServingStatus_descriptor();
}
template <> struct is_proto_enum< ::y3d::ObjectType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::y3d::ObjectType>() {
  return ::y3d::ObjectType_descriptor();
}
template <> struct is_proto_enum< ::y3d::GVerType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::y3d::GVerType>() {
  return ::y3d::GVerType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_y3d_2eproto__INCLUDED
