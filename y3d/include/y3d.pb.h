// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: y3d.proto

#ifndef PROTOBUF_y3d_2eproto__INCLUDED
#define PROTOBUF_y3d_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000002 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/map.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
#include <google/protobuf/timestamp.pb.h>
#include "xnormal.pb.h"
// @@protoc_insertion_point(includes)

namespace y3d {

// Internal implementation detail -- do not call these.
void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
void protobuf_AssignDesc_y3d_2eproto();
void protobuf_ShutdownFile_y3d_2eproto();

class BatchOptimizeParam;
class BlenderUnwrap;
class EDelete;
class EIsolate;
class ELowpoly;
class EMove;
class ENone;
class ENormal;
class EPacking;
class ERotate;
class ESelect;
class ESelectMany;
class EUnwrap;
class EmptyParam;
class FRangeItem;
class FilterView;
class LPoly3DMax;
class LPolyBlender;
class LPolyMeshlab;
class Make4TestParam;
class MaxUnwrap;
class NewProjectParam;
class Normal3DMax;
class OptimizeOptions;
class OptimizeParam;
class PSetting;
class Pack3DMax;
class PackRect;
class ProjectInfo;
class RenameParam;
class ResponseEvent;
class ResponseNProject;
class ResultReply;
class SettingData;
class StringParam;
class TestParam;
class YArea;
class YAreaList;
class YBox3;
class YCamera;
class YColor;
class YEvent;
class YGroup;
class YGroupVer;
class YLayer;
class YLight;
class YMesh;
class YObject;
class YPoint3;
class YResource;
class YSystem;

enum YResource_ResourceType {
  YResource_ResourceType_BINARY = 0,
  YResource_ResourceType_IMAGE = 1,
  YResource_ResourceType_FLATBUFFER = 2,
  YResource_ResourceType_PROTOBUF = 3,
  YResource_ResourceType_CAPNP = 4,
  YResource_ResourceType_YResource_ResourceType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  YResource_ResourceType_YResource_ResourceType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
Y3D_EXPORT_MACRO bool YResource_ResourceType_IsValid(int value);
const YResource_ResourceType YResource_ResourceType_ResourceType_MIN = YResource_ResourceType_BINARY;
const YResource_ResourceType YResource_ResourceType_ResourceType_MAX = YResource_ResourceType_CAPNP;
const int YResource_ResourceType_ResourceType_ARRAYSIZE = YResource_ResourceType_ResourceType_MAX + 1;

Y3D_EXPORT_MACRO const ::google::protobuf::EnumDescriptor* YResource_ResourceType_descriptor();
inline const ::std::string& YResource_ResourceType_Name(YResource_ResourceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    YResource_ResourceType_descriptor(), value);
}
inline bool YResource_ResourceType_Parse(
    const ::std::string& name, YResource_ResourceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<YResource_ResourceType>(
    YResource_ResourceType_descriptor(), name, value);
}
enum YMesh_MeshType {
  YMesh_MeshType_Unknown = 0,
  YMesh_MeshType_Editable_Mesh = 1,
  YMesh_MeshType_Editable_Poly = 2,
  YMesh_MeshType_Box = 3,
  YMesh_MeshType_Sphere = 4,
  YMesh_MeshType_GeoSphere = 5,
  YMesh_MeshType_Cylinder = 6,
  YMesh_MeshType_Tube = 7,
  YMesh_MeshType_Torus = 8,
  YMesh_MeshType_Pyramid = 9,
  YMesh_MeshType_Teapot = 10,
  YMesh_MeshType_Plane = 11,
  YMesh_MeshType_Target = 12,
  YMesh_MeshType_Cone = 13,
  YMesh_MeshType_YMesh_MeshType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  YMesh_MeshType_YMesh_MeshType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
Y3D_EXPORT_MACRO bool YMesh_MeshType_IsValid(int value);
const YMesh_MeshType YMesh_MeshType_MeshType_MIN = YMesh_MeshType_Unknown;
const YMesh_MeshType YMesh_MeshType_MeshType_MAX = YMesh_MeshType_Cone;
const int YMesh_MeshType_MeshType_ARRAYSIZE = YMesh_MeshType_MeshType_MAX + 1;

Y3D_EXPORT_MACRO const ::google::protobuf::EnumDescriptor* YMesh_MeshType_descriptor();
inline const ::std::string& YMesh_MeshType_Name(YMesh_MeshType value) {
  return ::google::protobuf::internal::NameOfEnum(
    YMesh_MeshType_descriptor(), value);
}
inline bool YMesh_MeshType_Parse(
    const ::std::string& name, YMesh_MeshType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<YMesh_MeshType>(
    YMesh_MeshType_descriptor(), name, value);
}
enum YMesh_XrefStatus {
  YMesh_XrefStatus_ORIGINAL = 0,
  YMesh_XrefStatus_XREF_HIGHT = 1,
  YMesh_XrefStatus_XREF_LOW = 2,
  YMesh_XrefStatus_XREF_LOW_DISPLAY = 3,
  YMesh_XrefStatus_BOX = 4,
  YMesh_XrefStatus_MERGED = 5,
  YMesh_XrefStatus_FINAL = 6,
  YMesh_XrefStatus_YMesh_XrefStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  YMesh_XrefStatus_YMesh_XrefStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
Y3D_EXPORT_MACRO bool YMesh_XrefStatus_IsValid(int value);
const YMesh_XrefStatus YMesh_XrefStatus_XrefStatus_MIN = YMesh_XrefStatus_ORIGINAL;
const YMesh_XrefStatus YMesh_XrefStatus_XrefStatus_MAX = YMesh_XrefStatus_FINAL;
const int YMesh_XrefStatus_XrefStatus_ARRAYSIZE = YMesh_XrefStatus_XrefStatus_MAX + 1;

Y3D_EXPORT_MACRO const ::google::protobuf::EnumDescriptor* YMesh_XrefStatus_descriptor();
inline const ::std::string& YMesh_XrefStatus_Name(YMesh_XrefStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    YMesh_XrefStatus_descriptor(), value);
}
inline bool YMesh_XrefStatus_Parse(
    const ::std::string& name, YMesh_XrefStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<YMesh_XrefStatus>(
    YMesh_XrefStatus_descriptor(), name, value);
}
enum LPoly3DMax_OpMode {
  LPoly3DMax_OpMode_CRUNCH_BORDERS = 0,
  LPoly3DMax_OpMode_PROTECT_BORDERS = 1,
  LPoly3DMax_OpMode_EXCLUDE_BORDERS = 2,
  LPoly3DMax_OpMode_LPoly3DMax_OpMode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LPoly3DMax_OpMode_LPoly3DMax_OpMode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
Y3D_EXPORT_MACRO bool LPoly3DMax_OpMode_IsValid(int value);
const LPoly3DMax_OpMode LPoly3DMax_OpMode_OpMode_MIN = LPoly3DMax_OpMode_CRUNCH_BORDERS;
const LPoly3DMax_OpMode LPoly3DMax_OpMode_OpMode_MAX = LPoly3DMax_OpMode_EXCLUDE_BORDERS;
const int LPoly3DMax_OpMode_OpMode_ARRAYSIZE = LPoly3DMax_OpMode_OpMode_MAX + 1;

Y3D_EXPORT_MACRO const ::google::protobuf::EnumDescriptor* LPoly3DMax_OpMode_descriptor();
inline const ::std::string& LPoly3DMax_OpMode_Name(LPoly3DMax_OpMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    LPoly3DMax_OpMode_descriptor(), value);
}
inline bool LPoly3DMax_OpMode_Parse(
    const ::std::string& name, LPoly3DMax_OpMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LPoly3DMax_OpMode>(
    LPoly3DMax_OpMode_descriptor(), name, value);
}
enum LPoly3DMax_NormalMode {
  LPoly3DMax_NormalMode_CRUNCH_NORMALS = 0,
  LPoly3DMax_NormalMode_PROTECT_NORMALS = 1,
  LPoly3DMax_NormalMode_EXCLUDE_NORMALS = 2,
  LPoly3DMax_NormalMode_LPoly3DMax_NormalMode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LPoly3DMax_NormalMode_LPoly3DMax_NormalMode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
Y3D_EXPORT_MACRO bool LPoly3DMax_NormalMode_IsValid(int value);
const LPoly3DMax_NormalMode LPoly3DMax_NormalMode_NormalMode_MIN = LPoly3DMax_NormalMode_CRUNCH_NORMALS;
const LPoly3DMax_NormalMode LPoly3DMax_NormalMode_NormalMode_MAX = LPoly3DMax_NormalMode_EXCLUDE_NORMALS;
const int LPoly3DMax_NormalMode_NormalMode_ARRAYSIZE = LPoly3DMax_NormalMode_NormalMode_MAX + 1;

Y3D_EXPORT_MACRO const ::google::protobuf::EnumDescriptor* LPoly3DMax_NormalMode_descriptor();
inline const ::std::string& LPoly3DMax_NormalMode_Name(LPoly3DMax_NormalMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    LPoly3DMax_NormalMode_descriptor(), value);
}
inline bool LPoly3DMax_NormalMode_Parse(
    const ::std::string& name, LPoly3DMax_NormalMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LPoly3DMax_NormalMode>(
    LPoly3DMax_NormalMode_descriptor(), name, value);
}
enum ObjectType {
  GEOMETRY = 0,
  LIGHT = 1,
  CAMERA = 2,
  SHAPE = 3,
  OTHER = 4,
  ObjectType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ObjectType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
Y3D_EXPORT_MACRO bool ObjectType_IsValid(int value);
const ObjectType ObjectType_MIN = GEOMETRY;
const ObjectType ObjectType_MAX = OTHER;
const int ObjectType_ARRAYSIZE = ObjectType_MAX + 1;

Y3D_EXPORT_MACRO const ::google::protobuf::EnumDescriptor* ObjectType_descriptor();
inline const ::std::string& ObjectType_Name(ObjectType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ObjectType_descriptor(), value);
}
inline bool ObjectType_Parse(
    const ::std::string& name, ObjectType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ObjectType>(
    ObjectType_descriptor(), name, value);
}
enum GVerType {
  NO_VER = 0,
  ORIGINAL = 1,
  IN_BAKE = 2,
  STANDARD = 3,
  GVerType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  GVerType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
Y3D_EXPORT_MACRO bool GVerType_IsValid(int value);
const GVerType GVerType_MIN = NO_VER;
const GVerType GVerType_MAX = STANDARD;
const int GVerType_ARRAYSIZE = GVerType_MAX + 1;

Y3D_EXPORT_MACRO const ::google::protobuf::EnumDescriptor* GVerType_descriptor();
inline const ::std::string& GVerType_Name(GVerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GVerType_descriptor(), value);
}
inline bool GVerType_Parse(
    const ::std::string& name, GVerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GVerType>(
    GVerType_descriptor(), name, value);
}
// ===================================================================

class Y3D_EXPORT_MACRO YColor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YColor) */ {
 public:
  YColor();
  virtual ~YColor();

  YColor(const YColor& from);

  inline YColor& operator=(const YColor& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YColor& default_instance();

  void Swap(YColor* other);

  // implements Message ----------------------------------------------

  inline YColor* New() const { return New(NULL); }

  YColor* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const YColor& from);
  void MergeFrom(const YColor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(YColor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional int32 argb = 2;
  void clear_argb();
  static const int kArgbFieldNumber = 2;
  ::google::protobuf::int32 argb() const;
  void set_argb(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:y3d.YColor)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 argb_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static YColor* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YPoint3 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YPoint3) */ {
 public:
  YPoint3();
  virtual ~YPoint3();

  YPoint3(const YPoint3& from);

  inline YPoint3& operator=(const YPoint3& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YPoint3& default_instance();

  void Swap(YPoint3* other);

  // implements Message ----------------------------------------------

  inline YPoint3* New() const { return New(NULL); }

  YPoint3* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const YPoint3& from);
  void MergeFrom(const YPoint3& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(YPoint3* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // optional float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // optional float z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:y3d.YPoint3)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  float x_;
  float y_;
  float z_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static YPoint3* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YBox3 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YBox3) */ {
 public:
  YBox3();
  virtual ~YBox3();

  YBox3(const YBox3& from);

  inline YBox3& operator=(const YBox3& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YBox3& default_instance();

  void Swap(YBox3* other);

  // implements Message ----------------------------------------------

  inline YBox3* New() const { return New(NULL); }

  YBox3* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const YBox3& from);
  void MergeFrom(const YBox3& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(YBox3* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .y3d.YPoint3 pmin = 1;
  bool has_pmin() const;
  void clear_pmin();
  static const int kPminFieldNumber = 1;
  const ::y3d::YPoint3& pmin() const;
  ::y3d::YPoint3* mutable_pmin();
  ::y3d::YPoint3* release_pmin();
  void set_allocated_pmin(::y3d::YPoint3* pmin);

  // optional .y3d.YPoint3 pmax = 2;
  bool has_pmax() const;
  void clear_pmax();
  static const int kPmaxFieldNumber = 2;
  const ::y3d::YPoint3& pmax() const;
  ::y3d::YPoint3* mutable_pmax();
  ::y3d::YPoint3* release_pmax();
  void set_allocated_pmax(::y3d::YPoint3* pmax);

  // @@protoc_insertion_point(class_scope:y3d.YBox3)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::y3d::YPoint3* pmin_;
  ::y3d::YPoint3* pmax_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static YBox3* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YResource : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YResource) */ {
 public:
  YResource();
  virtual ~YResource();

  YResource(const YResource& from);

  inline YResource& operator=(const YResource& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YResource& default_instance();

  void Swap(YResource* other);

  // implements Message ----------------------------------------------

  inline YResource* New() const { return New(NULL); }

  YResource* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const YResource& from);
  void MergeFrom(const YResource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(YResource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef YResource_ResourceType ResourceType;
  static const ResourceType BINARY =
    YResource_ResourceType_BINARY;
  static const ResourceType IMAGE =
    YResource_ResourceType_IMAGE;
  static const ResourceType FLATBUFFER =
    YResource_ResourceType_FLATBUFFER;
  static const ResourceType PROTOBUF =
    YResource_ResourceType_PROTOBUF;
  static const ResourceType CAPNP =
    YResource_ResourceType_CAPNP;
  static inline bool ResourceType_IsValid(int value) {
    return YResource_ResourceType_IsValid(value);
  }
  static const ResourceType ResourceType_MIN =
    YResource_ResourceType_ResourceType_MIN;
  static const ResourceType ResourceType_MAX =
    YResource_ResourceType_ResourceType_MAX;
  static const int ResourceType_ARRAYSIZE =
    YResource_ResourceType_ResourceType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResourceType_descriptor() {
    return YResource_ResourceType_descriptor();
  }
  static inline const ::std::string& ResourceType_Name(ResourceType value) {
    return YResource_ResourceType_Name(value);
  }
  static inline bool ResourceType_Parse(const ::std::string& name,
      ResourceType* value) {
    return YResource_ResourceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string rid = 1;
  void clear_rid();
  static const int kRidFieldNumber = 1;
  const ::std::string& rid() const;
  void set_rid(const ::std::string& value);
  void set_rid(const char* value);
  void set_rid(const char* value, size_t size);
  ::std::string* mutable_rid();
  ::std::string* release_rid();
  void set_allocated_rid(::std::string* rid);

  // optional .y3d.YResource.ResourceType rtype = 2;
  void clear_rtype();
  static const int kRtypeFieldNumber = 2;
  ::y3d::YResource_ResourceType rtype() const;
  void set_rtype(::y3d::YResource_ResourceType value);

  // optional string link = 3;
  void clear_link();
  static const int kLinkFieldNumber = 3;
  const ::std::string& link() const;
  void set_link(const ::std::string& value);
  void set_link(const char* value);
  void set_link(const char* value, size_t size);
  ::std::string* mutable_link();
  ::std::string* release_link();
  void set_allocated_link(::std::string* link);

  // @@protoc_insertion_point(class_scope:y3d.YResource)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr rid_;
  ::google::protobuf::internal::ArenaStringPtr link_;
  int rtype_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static YResource* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YLight : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YLight) */ {
 public:
  YLight();
  virtual ~YLight();

  YLight(const YLight& from);

  inline YLight& operator=(const YLight& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YLight& default_instance();

  void Swap(YLight* other);

  // implements Message ----------------------------------------------

  inline YLight* New() const { return New(NULL); }

  YLight* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const YLight& from);
  void MergeFrom(const YLight& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(YLight* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float diffuse = 3;
  int diffuse_size() const;
  void clear_diffuse();
  static const int kDiffuseFieldNumber = 3;
  float diffuse(int index) const;
  void set_diffuse(int index, float value);
  void add_diffuse(float value);
  const ::google::protobuf::RepeatedField< float >&
      diffuse() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_diffuse();

  // repeated float specular = 4;
  int specular_size() const;
  void clear_specular();
  static const int kSpecularFieldNumber = 4;
  float specular(int index) const;
  void set_specular(int index, float value);
  void add_specular(float value);
  const ::google::protobuf::RepeatedField< float >&
      specular() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_specular();

  // optional float intensity = 5;
  void clear_intensity();
  static const int kIntensityFieldNumber = 5;
  float intensity() const;
  void set_intensity(float value);

  // optional float range = 6;
  void clear_range();
  static const int kRangeFieldNumber = 6;
  float range() const;
  void set_range(float value);

  // optional float angle = 7;
  void clear_angle();
  static const int kAngleFieldNumber = 7;
  float angle() const;
  void set_angle(float value);

  // optional float exponent = 8;
  void clear_exponent();
  static const int kExponentFieldNumber = 8;
  float exponent() const;
  void set_exponent(float value);

  // repeated string excludedMeshesIds = 9;
  int excludedmeshesids_size() const;
  void clear_excludedmeshesids();
  static const int kExcludedMeshesIdsFieldNumber = 9;
  const ::std::string& excludedmeshesids(int index) const;
  ::std::string* mutable_excludedmeshesids(int index);
  void set_excludedmeshesids(int index, const ::std::string& value);
  void set_excludedmeshesids(int index, const char* value);
  void set_excludedmeshesids(int index, const char* value, size_t size);
  ::std::string* add_excludedmeshesids();
  void add_excludedmeshesids(const ::std::string& value);
  void add_excludedmeshesids(const char* value);
  void add_excludedmeshesids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& excludedmeshesids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_excludedmeshesids();

  // repeated string includedOnlyMeshesIds = 10;
  int includedonlymeshesids_size() const;
  void clear_includedonlymeshesids();
  static const int kIncludedOnlyMeshesIdsFieldNumber = 10;
  const ::std::string& includedonlymeshesids(int index) const;
  ::std::string* mutable_includedonlymeshesids(int index);
  void set_includedonlymeshesids(int index, const ::std::string& value);
  void set_includedonlymeshesids(int index, const char* value);
  void set_includedonlymeshesids(int index, const char* value, size_t size);
  ::std::string* add_includedonlymeshesids();
  void add_includedonlymeshesids(const ::std::string& value);
  void add_includedonlymeshesids(const char* value);
  void add_includedonlymeshesids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& includedonlymeshesids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_includedonlymeshesids();

  // @@protoc_insertion_point(class_scope:y3d.YLight)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedField< float > diffuse_;
  mutable int _diffuse_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > specular_;
  mutable int _specular_cached_byte_size_;
  float intensity_;
  float range_;
  float angle_;
  float exponent_;
  ::google::protobuf::RepeatedPtrField< ::std::string> excludedmeshesids_;
  ::google::protobuf::RepeatedPtrField< ::std::string> includedonlymeshesids_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static YLight* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YCamera : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YCamera) */ {
 public:
  YCamera();
  virtual ~YCamera();

  YCamera(const YCamera& from);

  inline YCamera& operator=(const YCamera& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YCamera& default_instance();

  void Swap(YCamera* other);

  // implements Message ----------------------------------------------

  inline YCamera* New() const { return New(NULL); }

  YCamera* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const YCamera& from);
  void MergeFrom(const YCamera& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(YCamera* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float rotation = 3;
  int rotation_size() const;
  void clear_rotation();
  static const int kRotationFieldNumber = 3;
  float rotation(int index) const;
  void set_rotation(int index, float value);
  void add_rotation(float value);
  const ::google::protobuf::RepeatedField< float >&
      rotation() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_rotation();

  // repeated float target = 4;
  int target_size() const;
  void clear_target();
  static const int kTargetFieldNumber = 4;
  float target(int index) const;
  void set_target(int index, float value);
  void add_target(float value);
  const ::google::protobuf::RepeatedField< float >&
      target() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_target();

  // optional float fov = 5;
  void clear_fov();
  static const int kFovFieldNumber = 5;
  float fov() const;
  void set_fov(float value);

  // @@protoc_insertion_point(class_scope:y3d.YCamera)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedField< float > rotation_;
  mutable int _rotation_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > target_;
  mutable int _target_cached_byte_size_;
  float fov_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static YCamera* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YMesh : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YMesh) */ {
 public:
  YMesh();
  virtual ~YMesh();

  YMesh(const YMesh& from);

  inline YMesh& operator=(const YMesh& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YMesh& default_instance();

  void Swap(YMesh* other);

  // implements Message ----------------------------------------------

  inline YMesh* New() const { return New(NULL); }

  YMesh* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const YMesh& from);
  void MergeFrom(const YMesh& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(YMesh* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef YMesh_MeshType MeshType;
  static const MeshType Unknown =
    YMesh_MeshType_Unknown;
  static const MeshType Editable_Mesh =
    YMesh_MeshType_Editable_Mesh;
  static const MeshType Editable_Poly =
    YMesh_MeshType_Editable_Poly;
  static const MeshType Box =
    YMesh_MeshType_Box;
  static const MeshType Sphere =
    YMesh_MeshType_Sphere;
  static const MeshType GeoSphere =
    YMesh_MeshType_GeoSphere;
  static const MeshType Cylinder =
    YMesh_MeshType_Cylinder;
  static const MeshType Tube =
    YMesh_MeshType_Tube;
  static const MeshType Torus =
    YMesh_MeshType_Torus;
  static const MeshType Pyramid =
    YMesh_MeshType_Pyramid;
  static const MeshType Teapot =
    YMesh_MeshType_Teapot;
  static const MeshType Plane =
    YMesh_MeshType_Plane;
  static const MeshType Target =
    YMesh_MeshType_Target;
  static const MeshType Cone =
    YMesh_MeshType_Cone;
  static inline bool MeshType_IsValid(int value) {
    return YMesh_MeshType_IsValid(value);
  }
  static const MeshType MeshType_MIN =
    YMesh_MeshType_MeshType_MIN;
  static const MeshType MeshType_MAX =
    YMesh_MeshType_MeshType_MAX;
  static const int MeshType_ARRAYSIZE =
    YMesh_MeshType_MeshType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MeshType_descriptor() {
    return YMesh_MeshType_descriptor();
  }
  static inline const ::std::string& MeshType_Name(MeshType value) {
    return YMesh_MeshType_Name(value);
  }
  static inline bool MeshType_Parse(const ::std::string& name,
      MeshType* value) {
    return YMesh_MeshType_Parse(name, value);
  }

  typedef YMesh_XrefStatus XrefStatus;
  static const XrefStatus ORIGINAL =
    YMesh_XrefStatus_ORIGINAL;
  static const XrefStatus XREF_HIGHT =
    YMesh_XrefStatus_XREF_HIGHT;
  static const XrefStatus XREF_LOW =
    YMesh_XrefStatus_XREF_LOW;
  static const XrefStatus XREF_LOW_DISPLAY =
    YMesh_XrefStatus_XREF_LOW_DISPLAY;
  static const XrefStatus BOX =
    YMesh_XrefStatus_BOX;
  static const XrefStatus MERGED =
    YMesh_XrefStatus_MERGED;
  static const XrefStatus FINAL =
    YMesh_XrefStatus_FINAL;
  static inline bool XrefStatus_IsValid(int value) {
    return YMesh_XrefStatus_IsValid(value);
  }
  static const XrefStatus XrefStatus_MIN =
    YMesh_XrefStatus_XrefStatus_MIN;
  static const XrefStatus XrefStatus_MAX =
    YMesh_XrefStatus_XrefStatus_MAX;
  static const int XrefStatus_ARRAYSIZE =
    YMesh_XrefStatus_XrefStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  XrefStatus_descriptor() {
    return YMesh_XrefStatus_descriptor();
  }
  static inline const ::std::string& XrefStatus_Name(XrefStatus value) {
    return YMesh_XrefStatus_Name(value);
  }
  static inline bool XrefStatus_Parse(const ::std::string& name,
      XrefStatus* value) {
    return YMesh_XrefStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional int32 num_faces = 1;
  void clear_num_faces();
  static const int kNumFacesFieldNumber = 1;
  ::google::protobuf::int32 num_faces() const;
  void set_num_faces(::google::protobuf::int32 value);

  // optional .y3d.YBox3 bbox = 2;
  bool has_bbox() const;
  void clear_bbox();
  static const int kBboxFieldNumber = 2;
  const ::y3d::YBox3& bbox() const;
  ::y3d::YBox3* mutable_bbox();
  ::y3d::YBox3* release_bbox();
  void set_allocated_bbox(::y3d::YBox3* bbox);

  // optional string res_id = 3;
  void clear_res_id();
  static const int kResIdFieldNumber = 3;
  const ::std::string& res_id() const;
  void set_res_id(const ::std::string& value);
  void set_res_id(const char* value);
  void set_res_id(const char* value, size_t size);
  ::std::string* mutable_res_id();
  ::std::string* release_res_id();
  void set_allocated_res_id(::std::string* res_id);

  // optional .y3d.YMesh.XrefStatus xstatus = 5;
  void clear_xstatus();
  static const int kXstatusFieldNumber = 5;
  ::y3d::YMesh_XrefStatus xstatus() const;
  void set_xstatus(::y3d::YMesh_XrefStatus value);

  // optional .y3d.YMesh.MeshType mtype = 6;
  void clear_mtype();
  static const int kMtypeFieldNumber = 6;
  ::y3d::YMesh_MeshType mtype() const;
  void set_mtype(::y3d::YMesh_MeshType value);

  // optional string vername = 7;
  void clear_vername();
  static const int kVernameFieldNumber = 7;
  const ::std::string& vername() const;
  void set_vername(const ::std::string& value);
  void set_vername(const char* value);
  void set_vername(const char* value, size_t size);
  ::std::string* mutable_vername();
  ::std::string* release_vername();
  void set_allocated_vername(::std::string* vername);

  // @@protoc_insertion_point(class_scope:y3d.YMesh)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::y3d::YBox3* bbox_;
  ::google::protobuf::int32 num_faces_;
  int xstatus_;
  ::google::protobuf::internal::ArenaStringPtr res_id_;
  ::google::protobuf::internal::ArenaStringPtr vername_;
  int mtype_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static YMesh* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YObject : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YObject) */ {
 public:
  YObject();
  virtual ~YObject();

  YObject(const YObject& from);

  inline YObject& operator=(const YObject& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YObject& default_instance();

  enum DataCase {
    kLight = 10,
    kCamera = 11,
    kMesh = 12,
    DATA_NOT_SET = 0,
  };

  void Swap(YObject* other);

  // implements Message ----------------------------------------------

  inline YObject* New() const { return New(NULL); }

  YObject* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const YObject& from);
  void MergeFrom(const YObject& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(YObject* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .y3d.YPoint3 pos = 3;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 3;
  const ::y3d::YPoint3& pos() const;
  ::y3d::YPoint3* mutable_pos();
  ::y3d::YPoint3* release_pos();
  void set_allocated_pos(::y3d::YPoint3* pos);

  // map<string, .google.protobuf.Any> extra = 5;
  int extra_size() const;
  void clear_extra();
  static const int kExtraFieldNumber = 5;
  const ::google::protobuf::Map< ::std::string, ::google::protobuf::Any >&
      extra() const;
  ::google::protobuf::Map< ::std::string, ::google::protobuf::Any >*
      mutable_extra();

  // optional .y3d.ObjectType otype = 6;
  void clear_otype();
  static const int kOtypeFieldNumber = 6;
  ::y3d::ObjectType otype() const;
  void set_otype(::y3d::ObjectType value);

  // repeated string tags = 7;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 7;
  const ::std::string& tags(int index) const;
  ::std::string* mutable_tags(int index);
  void set_tags(int index, const ::std::string& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  ::std::string* add_tags();
  void add_tags(const ::std::string& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& tags() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tags();

  // optional int32 cate_id = 8;
  void clear_cate_id();
  static const int kCateIdFieldNumber = 8;
  ::google::protobuf::int32 cate_id() const;
  void set_cate_id(::google::protobuf::int32 value);

  // optional .y3d.YLight light = 10;
  bool has_light() const;
  void clear_light();
  static const int kLightFieldNumber = 10;
  const ::y3d::YLight& light() const;
  ::y3d::YLight* mutable_light();
  ::y3d::YLight* release_light();
  void set_allocated_light(::y3d::YLight* light);

  // optional .y3d.YCamera camera = 11;
  bool has_camera() const;
  void clear_camera();
  static const int kCameraFieldNumber = 11;
  const ::y3d::YCamera& camera() const;
  ::y3d::YCamera* mutable_camera();
  ::y3d::YCamera* release_camera();
  void set_allocated_camera(::y3d::YCamera* camera);

  // optional .y3d.YMesh mesh = 12;
  bool has_mesh() const;
  void clear_mesh();
  static const int kMeshFieldNumber = 12;
  const ::y3d::YMesh& mesh() const;
  ::y3d::YMesh* mutable_mesh();
  ::y3d::YMesh* release_mesh();
  void set_allocated_mesh(::y3d::YMesh* mesh);

  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:y3d.YObject)
 private:
  inline void set_has_light();
  inline void set_has_camera();
  inline void set_has_mesh();

  inline bool has_data() const;
  void clear_data();
  inline void clear_has_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::y3d::YPoint3* pos_;
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::google::protobuf::Any,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 >
      YObject_ExtraEntry;
  ::google::protobuf::internal::MapField<
      ::std::string, ::google::protobuf::Any,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > extra_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tags_;
  int otype_;
  ::google::protobuf::int32 cate_id_;
  union DataUnion {
    DataUnion() {}
    ::y3d::YLight* light_;
    ::y3d::YCamera* camera_;
    ::y3d::YMesh* mesh_;
  } data_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static YObject* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YArea : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YArea) */ {
 public:
  YArea();
  virtual ~YArea();

  YArea(const YArea& from);

  inline YArea& operator=(const YArea& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YArea& default_instance();

  void Swap(YArea* other);

  // implements Message ----------------------------------------------

  inline YArea* New() const { return New(NULL); }

  YArea* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const YArea& from);
  void MergeFrom(const YArea& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(YArea* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated .y3d.YGroup groups = 2;
  int groups_size() const;
  void clear_groups();
  static const int kGroupsFieldNumber = 2;
  const ::y3d::YGroup& groups(int index) const;
  ::y3d::YGroup* mutable_groups(int index);
  ::y3d::YGroup* add_groups();
  ::google::protobuf::RepeatedPtrField< ::y3d::YGroup >*
      mutable_groups();
  const ::google::protobuf::RepeatedPtrField< ::y3d::YGroup >&
      groups() const;

  // repeated .y3d.YObject objs = 3;
  int objs_size() const;
  void clear_objs();
  static const int kObjsFieldNumber = 3;
  const ::y3d::YObject& objs(int index) const;
  ::y3d::YObject* mutable_objs(int index);
  ::y3d::YObject* add_objs();
  ::google::protobuf::RepeatedPtrField< ::y3d::YObject >*
      mutable_objs();
  const ::google::protobuf::RepeatedPtrField< ::y3d::YObject >&
      objs() const;

  // map<string, .y3d.YGroupVer> gvers = 6;
  int gvers_size() const;
  void clear_gvers();
  static const int kGversFieldNumber = 6;
  const ::google::protobuf::Map< ::std::string, ::y3d::YGroupVer >&
      gvers() const;
  ::google::protobuf::Map< ::std::string, ::y3d::YGroupVer >*
      mutable_gvers();

  // @@protoc_insertion_point(class_scope:y3d.YArea)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::RepeatedPtrField< ::y3d::YGroup > groups_;
  ::google::protobuf::RepeatedPtrField< ::y3d::YObject > objs_;
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::y3d::YGroupVer,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 >
      YArea_GversEntry;
  ::google::protobuf::internal::MapField<
      ::std::string, ::y3d::YGroupVer,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > gvers_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static YArea* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YAreaList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YAreaList) */ {
 public:
  YAreaList();
  virtual ~YAreaList();

  YAreaList(const YAreaList& from);

  inline YAreaList& operator=(const YAreaList& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YAreaList& default_instance();

  void Swap(YAreaList* other);

  // implements Message ----------------------------------------------

  inline YAreaList* New() const { return New(NULL); }

  YAreaList* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const YAreaList& from);
  void MergeFrom(const YAreaList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(YAreaList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .y3d.YArea areas = 1;
  int areas_size() const;
  void clear_areas();
  static const int kAreasFieldNumber = 1;
  const ::y3d::YArea& areas(int index) const;
  ::y3d::YArea* mutable_areas(int index);
  ::y3d::YArea* add_areas();
  ::google::protobuf::RepeatedPtrField< ::y3d::YArea >*
      mutable_areas();
  const ::google::protobuf::RepeatedPtrField< ::y3d::YArea >&
      areas() const;

  // @@protoc_insertion_point(class_scope:y3d.YAreaList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::y3d::YArea > areas_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static YAreaList* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YLayer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YLayer) */ {
 public:
  YLayer();
  virtual ~YLayer();

  YLayer(const YLayer& from);

  inline YLayer& operator=(const YLayer& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YLayer& default_instance();

  void Swap(YLayer* other);

  // implements Message ----------------------------------------------

  inline YLayer* New() const { return New(NULL); }

  YLayer* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const YLayer& from);
  void MergeFrom(const YLayer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(YLayer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated .y3d.YGroup groups = 2;
  int groups_size() const;
  void clear_groups();
  static const int kGroupsFieldNumber = 2;
  const ::y3d::YGroup& groups(int index) const;
  ::y3d::YGroup* mutable_groups(int index);
  ::y3d::YGroup* add_groups();
  ::google::protobuf::RepeatedPtrField< ::y3d::YGroup >*
      mutable_groups();
  const ::google::protobuf::RepeatedPtrField< ::y3d::YGroup >&
      groups() const;

  // @@protoc_insertion_point(class_scope:y3d.YLayer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::RepeatedPtrField< ::y3d::YGroup > groups_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static YLayer* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YGroup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YGroup) */ {
 public:
  YGroup();
  virtual ~YGroup();

  YGroup(const YGroup& from);

  inline YGroup& operator=(const YGroup& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YGroup& default_instance();

  void Swap(YGroup* other);

  // implements Message ----------------------------------------------

  inline YGroup* New() const { return New(NULL); }

  YGroup* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const YGroup& from);
  void MergeFrom(const YGroup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(YGroup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated .y3d.YObject objs = 2;
  int objs_size() const;
  void clear_objs();
  static const int kObjsFieldNumber = 2;
  const ::y3d::YObject& objs(int index) const;
  ::y3d::YObject* mutable_objs(int index);
  ::y3d::YObject* add_objs();
  ::google::protobuf::RepeatedPtrField< ::y3d::YObject >*
      mutable_objs();
  const ::google::protobuf::RepeatedPtrField< ::y3d::YObject >&
      objs() const;

  // repeated .y3d.YGroup children = 3;
  int children_size() const;
  void clear_children();
  static const int kChildrenFieldNumber = 3;
  const ::y3d::YGroup& children(int index) const;
  ::y3d::YGroup* mutable_children(int index);
  ::y3d::YGroup* add_children();
  ::google::protobuf::RepeatedPtrField< ::y3d::YGroup >*
      mutable_children();
  const ::google::protobuf::RepeatedPtrField< ::y3d::YGroup >&
      children() const;

  // optional .y3d.GVerType gv_type = 4;
  void clear_gv_type();
  static const int kGvTypeFieldNumber = 4;
  ::y3d::GVerType gv_type() const;
  void set_gv_type(::y3d::GVerType value);

  // repeated string xref = 5;
  int xref_size() const;
  void clear_xref();
  static const int kXrefFieldNumber = 5;
  const ::std::string& xref(int index) const;
  ::std::string* mutable_xref(int index);
  void set_xref(int index, const ::std::string& value);
  void set_xref(int index, const char* value);
  void set_xref(int index, const char* value, size_t size);
  ::std::string* add_xref();
  void add_xref(const ::std::string& value);
  void add_xref(const char* value);
  void add_xref(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& xref() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_xref();

  // @@protoc_insertion_point(class_scope:y3d.YGroup)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::RepeatedPtrField< ::y3d::YObject > objs_;
  ::google::protobuf::RepeatedPtrField< ::y3d::YGroup > children_;
  ::google::protobuf::RepeatedPtrField< ::std::string> xref_;
  int gv_type_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static YGroup* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YGroupVer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YGroupVer) */ {
 public:
  YGroupVer();
  virtual ~YGroupVer();

  YGroupVer(const YGroupVer& from);

  inline YGroupVer& operator=(const YGroupVer& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YGroupVer& default_instance();

  void Swap(YGroupVer* other);

  // implements Message ----------------------------------------------

  inline YGroupVer* New() const { return New(NULL); }

  YGroupVer* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const YGroupVer& from);
  void MergeFrom(const YGroupVer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(YGroupVer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string vname = 1;
  void clear_vname();
  static const int kVnameFieldNumber = 1;
  const ::std::string& vname() const;
  void set_vname(const ::std::string& value);
  void set_vname(const char* value);
  void set_vname(const char* value, size_t size);
  ::std::string* mutable_vname();
  ::std::string* release_vname();
  void set_allocated_vname(::std::string* vname);

  // optional .y3d.YGroup groupData = 2;
  bool has_groupdata() const;
  void clear_groupdata();
  static const int kGroupDataFieldNumber = 2;
  const ::y3d::YGroup& groupdata() const;
  ::y3d::YGroup* mutable_groupdata();
  ::y3d::YGroup* release_groupdata();
  void set_allocated_groupdata(::y3d::YGroup* groupdata);

  // optional int32 step = 3;
  void clear_step();
  static const int kStepFieldNumber = 3;
  ::google::protobuf::int32 step() const;
  void set_step(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:y3d.YGroupVer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr vname_;
  ::y3d::YGroup* groupdata_;
  ::google::protobuf::int32 step_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static YGroupVer* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO FilterView : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.FilterView) */ {
 public:
  FilterView();
  virtual ~FilterView();

  FilterView(const FilterView& from);

  inline FilterView& operator=(const FilterView& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FilterView& default_instance();

  void Swap(FilterView* other);

  // implements Message ----------------------------------------------

  inline FilterView* New() const { return New(NULL); }

  FilterView* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FilterView& from);
  void MergeFrom(const FilterView& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FilterView* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .y3d.ObjectType otype = 1;
  void clear_otype();
  static const int kOtypeFieldNumber = 1;
  ::y3d::ObjectType otype() const;
  void set_otype(::y3d::ObjectType value);

  // optional int32 face_range = 2;
  void clear_face_range();
  static const int kFaceRangeFieldNumber = 2;
  ::google::protobuf::int32 face_range() const;
  void set_face_range(::google::protobuf::int32 value);

  // optional string search = 3;
  void clear_search();
  static const int kSearchFieldNumber = 3;
  const ::std::string& search() const;
  void set_search(const ::std::string& value);
  void set_search(const char* value);
  void set_search(const char* value, size_t size);
  ::std::string* mutable_search();
  ::std::string* release_search();
  void set_allocated_search(::std::string* search);

  // optional int32 aid = 4;
  void clear_aid();
  static const int kAidFieldNumber = 4;
  ::google::protobuf::int32 aid() const;
  void set_aid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:y3d.FilterView)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int otype_;
  ::google::protobuf::int32 face_range_;
  ::google::protobuf::internal::ArenaStringPtr search_;
  ::google::protobuf::int32 aid_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static FilterView* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO ProjectInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.ProjectInfo) */ {
 public:
  ProjectInfo();
  virtual ~ProjectInfo();

  ProjectInfo(const ProjectInfo& from);

  inline ProjectInfo& operator=(const ProjectInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProjectInfo& default_instance();

  void Swap(ProjectInfo* other);

  // implements Message ----------------------------------------------

  inline ProjectInfo* New() const { return New(NULL); }

  ProjectInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProjectInfo& from);
  void MergeFrom(const ProjectInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProjectInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string pname = 1;
  void clear_pname();
  static const int kPnameFieldNumber = 1;
  const ::std::string& pname() const;
  void set_pname(const ::std::string& value);
  void set_pname(const char* value);
  void set_pname(const char* value, size_t size);
  ::std::string* mutable_pname();
  ::std::string* release_pname();
  void set_allocated_pname(::std::string* pname);

  // optional string path = 2;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // optional .google.protobuf.Timestamp ts = 3;
  bool has_ts() const;
  void clear_ts();
  static const int kTsFieldNumber = 3;
  const ::google::protobuf::Timestamp& ts() const;
  ::google::protobuf::Timestamp* mutable_ts();
  ::google::protobuf::Timestamp* release_ts();
  void set_allocated_ts(::google::protobuf::Timestamp* ts);

  // optional .y3d.OptimizeOptions optimize_ops = 5;
  bool has_optimize_ops() const;
  void clear_optimize_ops();
  static const int kOptimizeOpsFieldNumber = 5;
  const ::y3d::OptimizeOptions& optimize_ops() const;
  ::y3d::OptimizeOptions* mutable_optimize_ops();
  ::y3d::OptimizeOptions* release_optimize_ops();
  void set_allocated_optimize_ops(::y3d::OptimizeOptions* optimize_ops);

  // repeated .y3d.FilterView fview = 6;
  int fview_size() const;
  void clear_fview();
  static const int kFviewFieldNumber = 6;
  const ::y3d::FilterView& fview(int index) const;
  ::y3d::FilterView* mutable_fview(int index);
  ::y3d::FilterView* add_fview();
  ::google::protobuf::RepeatedPtrField< ::y3d::FilterView >*
      mutable_fview();
  const ::google::protobuf::RepeatedPtrField< ::y3d::FilterView >&
      fview() const;

  // optional float optimize_ratio = 7;
  void clear_optimize_ratio();
  static const int kOptimizeRatioFieldNumber = 7;
  float optimize_ratio() const;
  void set_optimize_ratio(float value);

  // @@protoc_insertion_point(class_scope:y3d.ProjectInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr pname_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::Timestamp* ts_;
  ::y3d::OptimizeOptions* optimize_ops_;
  ::google::protobuf::RepeatedPtrField< ::y3d::FilterView > fview_;
  float optimize_ratio_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static ProjectInfo* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO SettingData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.SettingData) */ {
 public:
  SettingData();
  virtual ~SettingData();

  SettingData(const SettingData& from);

  inline SettingData& operator=(const SettingData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SettingData& default_instance();

  void Swap(SettingData* other);

  // implements Message ----------------------------------------------

  inline SettingData* New() const { return New(NULL); }

  SettingData* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SettingData& from);
  void MergeFrom(const SettingData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SettingData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // optional string aset_name = 1;
  void clear_aset_name();
  static const int kAsetNameFieldNumber = 1;
  const ::std::string& aset_name() const;
  void set_aset_name(const ::std::string& value);
  void set_aset_name(const char* value);
  void set_aset_name(const char* value, size_t size);
  ::std::string* mutable_aset_name();
  ::std::string* release_aset_name();
  void set_allocated_aset_name(::std::string* aset_name);

  // map<string, .google.protobuf.Any> data = 2;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::google::protobuf::Any >&
      data() const;
  ::google::protobuf::Map< ::std::string, ::google::protobuf::Any >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:y3d.SettingData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr aset_name_;
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::google::protobuf::Any,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 >
      SettingData_DataEntry;
  ::google::protobuf::internal::MapField<
      ::std::string, ::google::protobuf::Any,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > data_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static SettingData* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO PSetting : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.PSetting) */ {
 public:
  PSetting();
  virtual ~PSetting();

  PSetting(const PSetting& from);

  inline PSetting& operator=(const PSetting& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PSetting& default_instance();

  void Swap(PSetting* other);

  // implements Message ----------------------------------------------

  inline PSetting* New() const { return New(NULL); }

  PSetting* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PSetting& from);
  void MergeFrom(const PSetting& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PSetting* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .y3d.SettingData extra = 1;
  bool has_extra() const;
  void clear_extra();
  static const int kExtraFieldNumber = 1;
  const ::y3d::SettingData& extra() const;
  ::y3d::SettingData* mutable_extra();
  ::y3d::SettingData* release_extra();
  void set_allocated_extra(::y3d::SettingData* extra);

  // optional int32 max_recent = 2;
  void clear_max_recent();
  static const int kMaxRecentFieldNumber = 2;
  ::google::protobuf::int32 max_recent() const;
  void set_max_recent(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:y3d.PSetting)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::y3d::SettingData* extra_;
  ::google::protobuf::int32 max_recent_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static PSetting* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YSystem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YSystem) */ {
 public:
  YSystem();
  virtual ~YSystem();

  YSystem(const YSystem& from);

  inline YSystem& operator=(const YSystem& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YSystem& default_instance();

  void Swap(YSystem* other);

  // implements Message ----------------------------------------------

  inline YSystem* New() const { return New(NULL); }

  YSystem* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const YSystem& from);
  void MergeFrom(const YSystem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(YSystem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string working_folder = 1;
  void clear_working_folder();
  static const int kWorkingFolderFieldNumber = 1;
  const ::std::string& working_folder() const;
  void set_working_folder(const ::std::string& value);
  void set_working_folder(const char* value);
  void set_working_folder(const char* value, size_t size);
  ::std::string* mutable_working_folder();
  ::std::string* release_working_folder();
  void set_allocated_working_folder(::std::string* working_folder);

  // optional .y3d.ProjectInfo default_info = 2;
  bool has_default_info() const;
  void clear_default_info();
  static const int kDefaultInfoFieldNumber = 2;
  const ::y3d::ProjectInfo& default_info() const;
  ::y3d::ProjectInfo* mutable_default_info();
  ::y3d::ProjectInfo* release_default_info();
  void set_allocated_default_info(::y3d::ProjectInfo* default_info);

  // optional .y3d.PSetting default_setting = 3;
  bool has_default_setting() const;
  void clear_default_setting();
  static const int kDefaultSettingFieldNumber = 3;
  const ::y3d::PSetting& default_setting() const;
  ::y3d::PSetting* mutable_default_setting();
  ::y3d::PSetting* release_default_setting();
  void set_allocated_default_setting(::y3d::PSetting* default_setting);

  // repeated .y3d.ProjectInfo projects = 4;
  int projects_size() const;
  void clear_projects();
  static const int kProjectsFieldNumber = 4;
  const ::y3d::ProjectInfo& projects(int index) const;
  ::y3d::ProjectInfo* mutable_projects(int index);
  ::y3d::ProjectInfo* add_projects();
  ::google::protobuf::RepeatedPtrField< ::y3d::ProjectInfo >*
      mutable_projects();
  const ::google::protobuf::RepeatedPtrField< ::y3d::ProjectInfo >&
      projects() const;

  // @@protoc_insertion_point(class_scope:y3d.YSystem)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr working_folder_;
  ::y3d::ProjectInfo* default_info_;
  ::y3d::PSetting* default_setting_;
  ::google::protobuf::RepeatedPtrField< ::y3d::ProjectInfo > projects_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static YSystem* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO FRangeItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.FRangeItem) */ {
 public:
  FRangeItem();
  virtual ~FRangeItem();

  FRangeItem(const FRangeItem& from);

  inline FRangeItem& operator=(const FRangeItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FRangeItem& default_instance();

  void Swap(FRangeItem* other);

  // implements Message ----------------------------------------------

  inline FRangeItem* New() const { return New(NULL); }

  FRangeItem* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FRangeItem& from);
  void MergeFrom(const FRangeItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FRangeItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 f_start = 1;
  void clear_f_start();
  static const int kFStartFieldNumber = 1;
  ::google::protobuf::int32 f_start() const;
  void set_f_start(::google::protobuf::int32 value);

  // optional int32 f_end = 2;
  void clear_f_end();
  static const int kFEndFieldNumber = 2;
  ::google::protobuf::int32 f_end() const;
  void set_f_end(::google::protobuf::int32 value);

  // optional .y3d.YColor fr_color = 3;
  bool has_fr_color() const;
  void clear_fr_color();
  static const int kFrColorFieldNumber = 3;
  const ::y3d::YColor& fr_color() const;
  ::y3d::YColor* mutable_fr_color();
  ::y3d::YColor* release_fr_color();
  void set_allocated_fr_color(::y3d::YColor* fr_color);

  // optional float ratio = 4;
  void clear_ratio();
  static const int kRatioFieldNumber = 4;
  float ratio() const;
  void set_ratio(float value);

  // optional bool has_xref = 5;
  void clear_has_xref();
  static const int kHasXrefFieldNumber = 5;
  bool has_xref() const;
  void set_has_xref(bool value);

  // @@protoc_insertion_point(class_scope:y3d.FRangeItem)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int32 f_start_;
  ::google::protobuf::int32 f_end_;
  ::y3d::YColor* fr_color_;
  float ratio_;
  bool has_xref_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static FRangeItem* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO OptimizeOptions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.OptimizeOptions) */ {
 public:
  OptimizeOptions();
  virtual ~OptimizeOptions();

  OptimizeOptions(const OptimizeOptions& from);

  inline OptimizeOptions& operator=(const OptimizeOptions& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OptimizeOptions& default_instance();

  void Swap(OptimizeOptions* other);

  // implements Message ----------------------------------------------

  inline OptimizeOptions* New() const { return New(NULL); }

  OptimizeOptions* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OptimizeOptions& from);
  void MergeFrom(const OptimizeOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OptimizeOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool use_range = 1;
  void clear_use_range();
  static const int kUseRangeFieldNumber = 1;
  bool use_range() const;
  void set_use_range(bool value);

  // repeated .y3d.FRangeItem fr = 2;
  int fr_size() const;
  void clear_fr();
  static const int kFrFieldNumber = 2;
  const ::y3d::FRangeItem& fr(int index) const;
  ::y3d::FRangeItem* mutable_fr(int index);
  ::y3d::FRangeItem* add_fr();
  ::google::protobuf::RepeatedPtrField< ::y3d::FRangeItem >*
      mutable_fr();
  const ::google::protobuf::RepeatedPtrField< ::y3d::FRangeItem >&
      fr() const;

  // optional int32 min_hpoly = 3;
  void clear_min_hpoly();
  static const int kMinHpolyFieldNumber = 3;
  ::google::protobuf::int32 min_hpoly() const;
  void set_min_hpoly(::google::protobuf::int32 value);

  // optional int32 out_range_count = 4;
  void clear_out_range_count();
  static const int kOutRangeCountFieldNumber = 4;
  ::google::protobuf::int32 out_range_count() const;
  void set_out_range_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:y3d.OptimizeOptions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::y3d::FRangeItem > fr_;
  bool use_range_;
  ::google::protobuf::int32 min_hpoly_;
  ::google::protobuf::int32 out_range_count_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static OptimizeOptions* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO ResultReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.ResultReply) */ {
 public:
  ResultReply();
  virtual ~ResultReply();

  ResultReply(const ResultReply& from);

  inline ResultReply& operator=(const ResultReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResultReply& default_instance();

  void Swap(ResultReply* other);

  // implements Message ----------------------------------------------

  inline ResultReply* New() const { return New(NULL); }

  ResultReply* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResultReply& from);
  void MergeFrom(const ResultReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResultReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool error = 1;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  bool error() const;
  void set_error(bool value);

  // optional string message = 2;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:y3d.ResultReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  bool error_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static ResultReply* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO EmptyParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.EmptyParam) */ {
 public:
  EmptyParam();
  virtual ~EmptyParam();

  EmptyParam(const EmptyParam& from);

  inline EmptyParam& operator=(const EmptyParam& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmptyParam& default_instance();

  void Swap(EmptyParam* other);

  // implements Message ----------------------------------------------

  inline EmptyParam* New() const { return New(NULL); }

  EmptyParam* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EmptyParam& from);
  void MergeFrom(const EmptyParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EmptyParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:y3d.EmptyParam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static EmptyParam* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO RenameParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.RenameParam) */ {
 public:
  RenameParam();
  virtual ~RenameParam();

  RenameParam(const RenameParam& from);

  inline RenameParam& operator=(const RenameParam& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RenameParam& default_instance();

  void Swap(RenameParam* other);

  // implements Message ----------------------------------------------

  inline RenameParam* New() const { return New(NULL); }

  RenameParam* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RenameParam& from);
  void MergeFrom(const RenameParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RenameParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool use_select = 1;
  void clear_use_select();
  static const int kUseSelectFieldNumber = 1;
  bool use_select() const;
  void set_use_select(bool value);

  // @@protoc_insertion_point(class_scope:y3d.RenameParam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  bool use_select_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static RenameParam* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO Make4TestParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.Make4TestParam) */ {
 public:
  Make4TestParam();
  virtual ~Make4TestParam();

  Make4TestParam(const Make4TestParam& from);

  inline Make4TestParam& operator=(const Make4TestParam& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Make4TestParam& default_instance();

  void Swap(Make4TestParam* other);

  // implements Message ----------------------------------------------

  inline Make4TestParam* New() const { return New(NULL); }

  Make4TestParam* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Make4TestParam& from);
  void MergeFrom(const Make4TestParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Make4TestParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string oname = 1;
  void clear_oname();
  static const int kOnameFieldNumber = 1;
  const ::std::string& oname() const;
  void set_oname(const ::std::string& value);
  void set_oname(const char* value);
  void set_oname(const char* value, size_t size);
  ::std::string* mutable_oname();
  ::std::string* release_oname();
  void set_allocated_oname(::std::string* oname);

  // repeated .y3d.ELowpoly lowpoly = 2;
  int lowpoly_size() const;
  void clear_lowpoly();
  static const int kLowpolyFieldNumber = 2;
  const ::y3d::ELowpoly& lowpoly(int index) const;
  ::y3d::ELowpoly* mutable_lowpoly(int index);
  ::y3d::ELowpoly* add_lowpoly();
  ::google::protobuf::RepeatedPtrField< ::y3d::ELowpoly >*
      mutable_lowpoly();
  const ::google::protobuf::RepeatedPtrField< ::y3d::ELowpoly >&
      lowpoly() const;

  // @@protoc_insertion_point(class_scope:y3d.Make4TestParam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr oname_;
  ::google::protobuf::RepeatedPtrField< ::y3d::ELowpoly > lowpoly_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static Make4TestParam* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO OptimizeParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.OptimizeParam) */ {
 public:
  OptimizeParam();
  virtual ~OptimizeParam();

  OptimizeParam(const OptimizeParam& from);

  inline OptimizeParam& operator=(const OptimizeParam& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OptimizeParam& default_instance();

  void Swap(OptimizeParam* other);

  // implements Message ----------------------------------------------

  inline OptimizeParam* New() const { return New(NULL); }

  OptimizeParam* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OptimizeParam& from);
  void MergeFrom(const OptimizeParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OptimizeParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float ratio = 1;
  void clear_ratio();
  static const int kRatioFieldNumber = 1;
  float ratio() const;
  void set_ratio(float value);

  // @@protoc_insertion_point(class_scope:y3d.OptimizeParam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  float ratio_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static OptimizeParam* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO BatchOptimizeParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.BatchOptimizeParam) */ {
 public:
  BatchOptimizeParam();
  virtual ~BatchOptimizeParam();

  BatchOptimizeParam(const BatchOptimizeParam& from);

  inline BatchOptimizeParam& operator=(const BatchOptimizeParam& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchOptimizeParam& default_instance();

  void Swap(BatchOptimizeParam* other);

  // implements Message ----------------------------------------------

  inline BatchOptimizeParam* New() const { return New(NULL); }

  BatchOptimizeParam* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BatchOptimizeParam& from);
  void MergeFrom(const BatchOptimizeParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BatchOptimizeParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float ratio = 1;
  void clear_ratio();
  static const int kRatioFieldNumber = 1;
  float ratio() const;
  void set_ratio(float value);

  // optional string folder = 2;
  void clear_folder();
  static const int kFolderFieldNumber = 2;
  const ::std::string& folder() const;
  void set_folder(const ::std::string& value);
  void set_folder(const char* value);
  void set_folder(const char* value, size_t size);
  ::std::string* mutable_folder();
  ::std::string* release_folder();
  void set_allocated_folder(::std::string* folder);

  // optional string filename = 3;
  void clear_filename();
  static const int kFilenameFieldNumber = 3;
  const ::std::string& filename() const;
  void set_filename(const ::std::string& value);
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  ::std::string* mutable_filename();
  ::std::string* release_filename();
  void set_allocated_filename(::std::string* filename);

  // @@protoc_insertion_point(class_scope:y3d.BatchOptimizeParam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr folder_;
  ::google::protobuf::internal::ArenaStringPtr filename_;
  float ratio_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static BatchOptimizeParam* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO StringParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.StringParam) */ {
 public:
  StringParam();
  virtual ~StringParam();

  StringParam(const StringParam& from);

  inline StringParam& operator=(const StringParam& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StringParam& default_instance();

  void Swap(StringParam* other);

  // implements Message ----------------------------------------------

  inline StringParam* New() const { return New(NULL); }

  StringParam* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StringParam& from);
  void MergeFrom(const StringParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StringParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string str = 1;
  void clear_str();
  static const int kStrFieldNumber = 1;
  const ::std::string& str() const;
  void set_str(const ::std::string& value);
  void set_str(const char* value);
  void set_str(const char* value, size_t size);
  ::std::string* mutable_str();
  ::std::string* release_str();
  void set_allocated_str(::std::string* str);

  // @@protoc_insertion_point(class_scope:y3d.StringParam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr str_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static StringParam* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO TestParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.TestParam) */ {
 public:
  TestParam();
  virtual ~TestParam();

  TestParam(const TestParam& from);

  inline TestParam& operator=(const TestParam& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TestParam& default_instance();

  void Swap(TestParam* other);

  // implements Message ----------------------------------------------

  inline TestParam* New() const { return New(NULL); }

  TestParam* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TestParam& from);
  void MergeFrom(const TestParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TestParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string test_name = 1;
  void clear_test_name();
  static const int kTestNameFieldNumber = 1;
  const ::std::string& test_name() const;
  void set_test_name(const ::std::string& value);
  void set_test_name(const char* value);
  void set_test_name(const char* value, size_t size);
  ::std::string* mutable_test_name();
  ::std::string* release_test_name();
  void set_allocated_test_name(::std::string* test_name);

  // optional .google.protobuf.Any anything = 2;
  bool has_anything() const;
  void clear_anything();
  static const int kAnythingFieldNumber = 2;
  const ::google::protobuf::Any& anything() const;
  ::google::protobuf::Any* mutable_anything();
  ::google::protobuf::Any* release_anything();
  void set_allocated_anything(::google::protobuf::Any* anything);

  // @@protoc_insertion_point(class_scope:y3d.TestParam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr test_name_;
  ::google::protobuf::Any* anything_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static TestParam* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO NewProjectParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.NewProjectParam) */ {
 public:
  NewProjectParam();
  virtual ~NewProjectParam();

  NewProjectParam(const NewProjectParam& from);

  inline NewProjectParam& operator=(const NewProjectParam& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewProjectParam& default_instance();

  void Swap(NewProjectParam* other);

  // implements Message ----------------------------------------------

  inline NewProjectParam* New() const { return New(NULL); }

  NewProjectParam* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewProjectParam& from);
  void MergeFrom(const NewProjectParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NewProjectParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string fname = 1;
  void clear_fname();
  static const int kFnameFieldNumber = 1;
  const ::std::string& fname() const;
  void set_fname(const ::std::string& value);
  void set_fname(const char* value);
  void set_fname(const char* value, size_t size);
  ::std::string* mutable_fname();
  ::std::string* release_fname();
  void set_allocated_fname(::std::string* fname);

  // optional string folder = 2;
  void clear_folder();
  static const int kFolderFieldNumber = 2;
  const ::std::string& folder() const;
  void set_folder(const ::std::string& value);
  void set_folder(const char* value);
  void set_folder(const char* value, size_t size);
  ::std::string* mutable_folder();
  ::std::string* release_folder();
  void set_allocated_folder(::std::string* folder);

  // @@protoc_insertion_point(class_scope:y3d.NewProjectParam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr fname_;
  ::google::protobuf::internal::ArenaStringPtr folder_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static NewProjectParam* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO ResponseNProject : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.ResponseNProject) */ {
 public:
  ResponseNProject();
  virtual ~ResponseNProject();

  ResponseNProject(const ResponseNProject& from);

  inline ResponseNProject& operator=(const ResponseNProject& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseNProject& default_instance();

  void Swap(ResponseNProject* other);

  // implements Message ----------------------------------------------

  inline ResponseNProject* New() const { return New(NULL); }

  ResponseNProject* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseNProject& from);
  void MergeFrom(const ResponseNProject& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseNProject* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .y3d.ProjectInfo pInfo = 1;
  bool has_pinfo() const;
  void clear_pinfo();
  static const int kPInfoFieldNumber = 1;
  const ::y3d::ProjectInfo& pinfo() const;
  ::y3d::ProjectInfo* mutable_pinfo();
  ::y3d::ProjectInfo* release_pinfo();
  void set_allocated_pinfo(::y3d::ProjectInfo* pinfo);

  // optional .y3d.YAreaList yal = 2;
  bool has_yal() const;
  void clear_yal();
  static const int kYalFieldNumber = 2;
  const ::y3d::YAreaList& yal() const;
  ::y3d::YAreaList* mutable_yal();
  ::y3d::YAreaList* release_yal();
  void set_allocated_yal(::y3d::YAreaList* yal);

  // optional .y3d.YSystem sys = 3;
  bool has_sys() const;
  void clear_sys();
  static const int kSysFieldNumber = 3;
  const ::y3d::YSystem& sys() const;
  ::y3d::YSystem* mutable_sys();
  ::y3d::YSystem* release_sys();
  void set_allocated_sys(::y3d::YSystem* sys);

  // optional string err = 4;
  void clear_err();
  static const int kErrFieldNumber = 4;
  const ::std::string& err() const;
  void set_err(const ::std::string& value);
  void set_err(const char* value);
  void set_err(const char* value, size_t size);
  ::std::string* mutable_err();
  ::std::string* release_err();
  void set_allocated_err(::std::string* err);

  // @@protoc_insertion_point(class_scope:y3d.ResponseNProject)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::y3d::ProjectInfo* pinfo_;
  ::y3d::YAreaList* yal_;
  ::y3d::YSystem* sys_;
  ::google::protobuf::internal::ArenaStringPtr err_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static ResponseNProject* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO YEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.YEvent) */ {
 public:
  YEvent();
  virtual ~YEvent();

  YEvent(const YEvent& from);

  inline YEvent& operator=(const YEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YEvent& default_instance();

  enum EventCase {
    kNoevent = 1,
    kSelect = 2,
    kMove = 3,
    kRotate = 4,
    kDel = 5,
    kSelectMany = 6,
    EVENT_NOT_SET = 0,
  };

  void Swap(YEvent* other);

  // implements Message ----------------------------------------------

  inline YEvent* New() const { return New(NULL); }

  YEvent* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const YEvent& from);
  void MergeFrom(const YEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(YEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .y3d.ENone noevent = 1;
  bool has_noevent() const;
  void clear_noevent();
  static const int kNoeventFieldNumber = 1;
  const ::y3d::ENone& noevent() const;
  ::y3d::ENone* mutable_noevent();
  ::y3d::ENone* release_noevent();
  void set_allocated_noevent(::y3d::ENone* noevent);

  // optional .y3d.ESelect select = 2;
  bool has_select() const;
  void clear_select();
  static const int kSelectFieldNumber = 2;
  const ::y3d::ESelect& select() const;
  ::y3d::ESelect* mutable_select();
  ::y3d::ESelect* release_select();
  void set_allocated_select(::y3d::ESelect* select);

  // optional .y3d.EMove move = 3;
  bool has_move() const;
  void clear_move();
  static const int kMoveFieldNumber = 3;
  const ::y3d::EMove& move() const;
  ::y3d::EMove* mutable_move();
  ::y3d::EMove* release_move();
  void set_allocated_move(::y3d::EMove* move);

  // optional .y3d.ERotate rotate = 4;
  bool has_rotate() const;
  void clear_rotate();
  static const int kRotateFieldNumber = 4;
  const ::y3d::ERotate& rotate() const;
  ::y3d::ERotate* mutable_rotate();
  ::y3d::ERotate* release_rotate();
  void set_allocated_rotate(::y3d::ERotate* rotate);

  // optional .y3d.EDelete del = 5;
  bool has_del() const;
  void clear_del();
  static const int kDelFieldNumber = 5;
  const ::y3d::EDelete& del() const;
  ::y3d::EDelete* mutable_del();
  ::y3d::EDelete* release_del();
  void set_allocated_del(::y3d::EDelete* del);

  // optional .y3d.ESelectMany select_many = 6;
  bool has_select_many() const;
  void clear_select_many();
  static const int kSelectManyFieldNumber = 6;
  const ::y3d::ESelectMany& select_many() const;
  ::y3d::ESelectMany* mutable_select_many();
  ::y3d::ESelectMany* release_select_many();
  void set_allocated_select_many(::y3d::ESelectMany* select_many);

  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:y3d.YEvent)
 private:
  inline void set_has_noevent();
  inline void set_has_select();
  inline void set_has_move();
  inline void set_has_rotate();
  inline void set_has_del();
  inline void set_has_select_many();

  inline bool has_event() const;
  void clear_event();
  inline void clear_has_event();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union EventUnion {
    EventUnion() {}
    ::y3d::ENone* noevent_;
    ::y3d::ESelect* select_;
    ::y3d::EMove* move_;
    ::y3d::ERotate* rotate_;
    ::y3d::EDelete* del_;
    ::y3d::ESelectMany* select_many_;
  } event_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static YEvent* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO ENone : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.ENone) */ {
 public:
  ENone();
  virtual ~ENone();

  ENone(const ENone& from);

  inline ENone& operator=(const ENone& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ENone& default_instance();

  void Swap(ENone* other);

  // implements Message ----------------------------------------------

  inline ENone* New() const { return New(NULL); }

  ENone* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ENone& from);
  void MergeFrom(const ENone& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ENone* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:y3d.ENone)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static ENone* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO ESelect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.ESelect) */ {
 public:
  ESelect();
  virtual ~ESelect();

  ESelect(const ESelect& from);

  inline ESelect& operator=(const ESelect& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ESelect& default_instance();

  void Swap(ESelect* other);

  // implements Message ----------------------------------------------

  inline ESelect* New() const { return New(NULL); }

  ESelect* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ESelect& from);
  void MergeFrom(const ESelect& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ESelect* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional bool isolate = 2;
  void clear_isolate();
  static const int kIsolateFieldNumber = 2;
  bool isolate() const;
  void set_isolate(bool value);

  // @@protoc_insertion_point(class_scope:y3d.ESelect)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  bool isolate_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static ESelect* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO ESelectMany : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.ESelectMany) */ {
 public:
  ESelectMany();
  virtual ~ESelectMany();

  ESelectMany(const ESelectMany& from);

  inline ESelectMany& operator=(const ESelectMany& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ESelectMany& default_instance();

  void Swap(ESelectMany* other);

  // implements Message ----------------------------------------------

  inline ESelectMany* New() const { return New(NULL); }

  ESelectMany* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ESelectMany& from);
  void MergeFrom(const ESelectMany& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ESelectMany* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string name = 1;
  int name_size() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name(int index) const;
  ::std::string* mutable_name(int index);
  void set_name(int index, const ::std::string& value);
  void set_name(int index, const char* value);
  void set_name(int index, const char* value, size_t size);
  ::std::string* add_name();
  void add_name(const ::std::string& value);
  void add_name(const char* value);
  void add_name(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& name() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_name();

  // optional bool isolate = 2;
  void clear_isolate();
  static const int kIsolateFieldNumber = 2;
  bool isolate() const;
  void set_isolate(bool value);

  // @@protoc_insertion_point(class_scope:y3d.ESelectMany)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::std::string> name_;
  bool isolate_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static ESelectMany* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO EMove : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.EMove) */ {
 public:
  EMove();
  virtual ~EMove();

  EMove(const EMove& from);

  inline EMove& operator=(const EMove& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EMove& default_instance();

  void Swap(EMove* other);

  // implements Message ----------------------------------------------

  inline EMove* New() const { return New(NULL); }

  EMove* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EMove& from);
  void MergeFrom(const EMove& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EMove* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float point = 1;
  int point_size() const;
  void clear_point();
  static const int kPointFieldNumber = 1;
  float point(int index) const;
  void set_point(int index, float value);
  void add_point(float value);
  const ::google::protobuf::RepeatedField< float >&
      point() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_point();

  // @@protoc_insertion_point(class_scope:y3d.EMove)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedField< float > point_;
  mutable int _point_cached_byte_size_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static EMove* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO ERotate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.ERotate) */ {
 public:
  ERotate();
  virtual ~ERotate();

  ERotate(const ERotate& from);

  inline ERotate& operator=(const ERotate& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ERotate& default_instance();

  void Swap(ERotate* other);

  // implements Message ----------------------------------------------

  inline ERotate* New() const { return New(NULL); }

  ERotate* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ERotate& from);
  void MergeFrom(const ERotate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ERotate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float rotate = 1;
  int rotate_size() const;
  void clear_rotate();
  static const int kRotateFieldNumber = 1;
  float rotate(int index) const;
  void set_rotate(int index, float value);
  void add_rotate(float value);
  const ::google::protobuf::RepeatedField< float >&
      rotate() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_rotate();

  // @@protoc_insertion_point(class_scope:y3d.ERotate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedField< float > rotate_;
  mutable int _rotate_cached_byte_size_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static ERotate* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO EDelete : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.EDelete) */ {
 public:
  EDelete();
  virtual ~EDelete();

  EDelete(const EDelete& from);

  inline EDelete& operator=(const EDelete& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EDelete& default_instance();

  void Swap(EDelete* other);

  // implements Message ----------------------------------------------

  inline EDelete* New() const { return New(NULL); }

  EDelete* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EDelete& from);
  void MergeFrom(const EDelete& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EDelete* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:y3d.EDelete)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static EDelete* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO EIsolate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.EIsolate) */ {
 public:
  EIsolate();
  virtual ~EIsolate();

  EIsolate(const EIsolate& from);

  inline EIsolate& operator=(const EIsolate& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EIsolate& default_instance();

  void Swap(EIsolate* other);

  // implements Message ----------------------------------------------

  inline EIsolate* New() const { return New(NULL); }

  EIsolate* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EIsolate& from);
  void MergeFrom(const EIsolate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EIsolate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional bool endIsolate = 2;
  void clear_endisolate();
  static const int kEndIsolateFieldNumber = 2;
  bool endisolate() const;
  void set_endisolate(bool value);

  // @@protoc_insertion_point(class_scope:y3d.EIsolate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  bool endisolate_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static EIsolate* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO EUnwrap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.EUnwrap) */ {
 public:
  EUnwrap();
  virtual ~EUnwrap();

  EUnwrap(const EUnwrap& from);

  inline EUnwrap& operator=(const EUnwrap& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EUnwrap& default_instance();

  enum SettingCase {
    kMax3D = 3,
    kBlender = 4,
    SETTING_NOT_SET = 0,
  };

  void Swap(EUnwrap* other);

  // implements Message ----------------------------------------------

  inline EUnwrap* New() const { return New(NULL); }

  EUnwrap* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EUnwrap& from);
  void MergeFrom(const EUnwrap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EUnwrap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string oname = 1;
  void clear_oname();
  static const int kOnameFieldNumber = 1;
  const ::std::string& oname() const;
  void set_oname(const ::std::string& value);
  void set_oname(const char* value);
  void set_oname(const char* value, size_t size);
  ::std::string* mutable_oname();
  ::std::string* release_oname();
  void set_allocated_oname(::std::string* oname);

  // optional int32 channel = 2;
  void clear_channel();
  static const int kChannelFieldNumber = 2;
  ::google::protobuf::int32 channel() const;
  void set_channel(::google::protobuf::int32 value);

  // optional .y3d.MaxUnwrap max3d = 3;
  bool has_max3d() const;
  void clear_max3d();
  static const int kMax3DFieldNumber = 3;
  const ::y3d::MaxUnwrap& max3d() const;
  ::y3d::MaxUnwrap* mutable_max3d();
  ::y3d::MaxUnwrap* release_max3d();
  void set_allocated_max3d(::y3d::MaxUnwrap* max3d);

  // optional .y3d.BlenderUnwrap blender = 4;
  bool has_blender() const;
  void clear_blender();
  static const int kBlenderFieldNumber = 4;
  const ::y3d::BlenderUnwrap& blender() const;
  ::y3d::BlenderUnwrap* mutable_blender();
  ::y3d::BlenderUnwrap* release_blender();
  void set_allocated_blender(::y3d::BlenderUnwrap* blender);

  SettingCase setting_case() const;
  // @@protoc_insertion_point(class_scope:y3d.EUnwrap)
 private:
  inline void set_has_max3d();
  inline void set_has_blender();

  inline bool has_setting() const;
  void clear_setting();
  inline void clear_has_setting();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr oname_;
  ::google::protobuf::int32 channel_;
  union SettingUnion {
    SettingUnion() {}
    ::y3d::MaxUnwrap* max3d_;
    ::y3d::BlenderUnwrap* blender_;
  } setting_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static EUnwrap* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO BlenderUnwrap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.BlenderUnwrap) */ {
 public:
  BlenderUnwrap();
  virtual ~BlenderUnwrap();

  BlenderUnwrap(const BlenderUnwrap& from);

  inline BlenderUnwrap& operator=(const BlenderUnwrap& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlenderUnwrap& default_instance();

  void Swap(BlenderUnwrap* other);

  // implements Message ----------------------------------------------

  inline BlenderUnwrap* New() const { return New(NULL); }

  BlenderUnwrap* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlenderUnwrap& from);
  void MergeFrom(const BlenderUnwrap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BlenderUnwrap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:y3d.BlenderUnwrap)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static BlenderUnwrap* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO MaxUnwrap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.MaxUnwrap) */ {
 public:
  MaxUnwrap();
  virtual ~MaxUnwrap();

  MaxUnwrap(const MaxUnwrap& from);

  inline MaxUnwrap& operator=(const MaxUnwrap& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MaxUnwrap& default_instance();

  void Swap(MaxUnwrap* other);

  // implements Message ----------------------------------------------

  inline MaxUnwrap* New() const { return New(NULL); }

  MaxUnwrap* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MaxUnwrap& from);
  void MergeFrom(const MaxUnwrap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MaxUnwrap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float angle = 1;
  void clear_angle();
  static const int kAngleFieldNumber = 1;
  float angle() const;
  void set_angle(float value);

  // optional float spacing = 2;
  void clear_spacing();
  static const int kSpacingFieldNumber = 2;
  float spacing() const;
  void set_spacing(float value);

  // @@protoc_insertion_point(class_scope:y3d.MaxUnwrap)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  float angle_;
  float spacing_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static MaxUnwrap* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO EPacking : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.EPacking) */ {
 public:
  EPacking();
  virtual ~EPacking();

  EPacking(const EPacking& from);

  inline EPacking& operator=(const EPacking& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EPacking& default_instance();

  enum PackCase {
    kPackmax = 4,
    kPackrect = 5,
    PACK_NOT_SET = 0,
  };

  void Swap(EPacking* other);

  // implements Message ----------------------------------------------

  inline EPacking* New() const { return New(NULL); }

  EPacking* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EPacking& from);
  void MergeFrom(const EPacking& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EPacking* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string oname = 1;
  void clear_oname();
  static const int kOnameFieldNumber = 1;
  const ::std::string& oname() const;
  void set_oname(const ::std::string& value);
  void set_oname(const char* value);
  void set_oname(const char* value, size_t size);
  ::std::string* mutable_oname();
  ::std::string* release_oname();
  void set_allocated_oname(::std::string* oname);

  // optional string uvname = 2;
  void clear_uvname();
  static const int kUvnameFieldNumber = 2;
  const ::std::string& uvname() const;
  void set_uvname(const ::std::string& value);
  void set_uvname(const char* value);
  void set_uvname(const char* value, size_t size);
  ::std::string* mutable_uvname();
  ::std::string* release_uvname();
  void set_allocated_uvname(::std::string* uvname);

  // optional int32 tile_Size = 3;
  void clear_tile_size();
  static const int kTileSizeFieldNumber = 3;
  ::google::protobuf::int32 tile_size() const;
  void set_tile_size(::google::protobuf::int32 value);

  // optional .y3d.Pack3DMax packmax = 4;
  bool has_packmax() const;
  void clear_packmax();
  static const int kPackmaxFieldNumber = 4;
  const ::y3d::Pack3DMax& packmax() const;
  ::y3d::Pack3DMax* mutable_packmax();
  ::y3d::Pack3DMax* release_packmax();
  void set_allocated_packmax(::y3d::Pack3DMax* packmax);

  // optional .y3d.PackRect packrect = 5;
  bool has_packrect() const;
  void clear_packrect();
  static const int kPackrectFieldNumber = 5;
  const ::y3d::PackRect& packrect() const;
  ::y3d::PackRect* mutable_packrect();
  ::y3d::PackRect* release_packrect();
  void set_allocated_packrect(::y3d::PackRect* packrect);

  PackCase pack_case() const;
  // @@protoc_insertion_point(class_scope:y3d.EPacking)
 private:
  inline void set_has_packmax();
  inline void set_has_packrect();

  inline bool has_pack() const;
  void clear_pack();
  inline void clear_has_pack();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr oname_;
  ::google::protobuf::internal::ArenaStringPtr uvname_;
  ::google::protobuf::int32 tile_size_;
  union PackUnion {
    PackUnion() {}
    ::y3d::Pack3DMax* packmax_;
    ::y3d::PackRect* packrect_;
  } pack_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static EPacking* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO PackRect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.PackRect) */ {
 public:
  PackRect();
  virtual ~PackRect();

  PackRect(const PackRect& from);

  inline PackRect& operator=(const PackRect& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PackRect& default_instance();

  void Swap(PackRect* other);

  // implements Message ----------------------------------------------

  inline PackRect* New() const { return New(NULL); }

  PackRect* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PackRect& from);
  void MergeFrom(const PackRect& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PackRect* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 density = 1;
  void clear_density();
  static const int kDensityFieldNumber = 1;
  ::google::protobuf::int32 density() const;
  void set_density(::google::protobuf::int32 value);

  // optional float padding = 2;
  void clear_padding();
  static const int kPaddingFieldNumber = 2;
  float padding() const;
  void set_padding(float value);

  // @@protoc_insertion_point(class_scope:y3d.PackRect)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int32 density_;
  float padding_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static PackRect* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO Pack3DMax : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.Pack3DMax) */ {
 public:
  Pack3DMax();
  virtual ~Pack3DMax();

  Pack3DMax(const Pack3DMax& from);

  inline Pack3DMax& operator=(const Pack3DMax& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pack3DMax& default_instance();

  void Swap(Pack3DMax* other);

  // implements Message ----------------------------------------------

  inline Pack3DMax* New() const { return New(NULL); }

  Pack3DMax* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Pack3DMax& from);
  void MergeFrom(const Pack3DMax& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Pack3DMax* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 numTile = 1;
  void clear_numtile();
  static const int kNumTileFieldNumber = 1;
  ::google::protobuf::int32 numtile() const;
  void set_numtile(::google::protobuf::int32 value);

  // optional bool normalize = 2;
  void clear_normalize();
  static const int kNormalizeFieldNumber = 2;
  bool normalize() const;
  void set_normalize(bool value);

  // optional bool rotate_clusters = 3;
  void clear_rotate_clusters();
  static const int kRotateClustersFieldNumber = 3;
  bool rotate_clusters() const;
  void set_rotate_clusters(bool value);

  // optional bool fill_holes = 4;
  void clear_fill_holes();
  static const int kFillHolesFieldNumber = 4;
  bool fill_holes() const;
  void set_fill_holes(bool value);

  // optional bool padding = 5;
  void clear_padding();
  static const int kPaddingFieldNumber = 5;
  bool padding() const;
  void set_padding(bool value);

  // @@protoc_insertion_point(class_scope:y3d.Pack3DMax)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int32 numtile_;
  bool normalize_;
  bool rotate_clusters_;
  bool fill_holes_;
  bool padding_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static Pack3DMax* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO ELowpoly : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.ELowpoly) */ {
 public:
  ELowpoly();
  virtual ~ELowpoly();

  ELowpoly(const ELowpoly& from);

  inline ELowpoly& operator=(const ELowpoly& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ELowpoly& default_instance();

  enum LowtypeCase {
    kLp3Dmax = 2,
    kLpBlender = 3,
    kLpMeshlab = 4,
    LOWTYPE_NOT_SET = 0,
  };

  void Swap(ELowpoly* other);

  // implements Message ----------------------------------------------

  inline ELowpoly* New() const { return New(NULL); }

  ELowpoly* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ELowpoly& from);
  void MergeFrom(const ELowpoly& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ELowpoly* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string oname = 1;
  void clear_oname();
  static const int kOnameFieldNumber = 1;
  const ::std::string& oname() const;
  void set_oname(const ::std::string& value);
  void set_oname(const char* value);
  void set_oname(const char* value, size_t size);
  ::std::string* mutable_oname();
  ::std::string* release_oname();
  void set_allocated_oname(::std::string* oname);

  // optional .y3d.LPoly3DMax lp_3dmax = 2;
  bool has_lp_3dmax() const;
  void clear_lp_3dmax();
  static const int kLp3DmaxFieldNumber = 2;
  const ::y3d::LPoly3DMax& lp_3dmax() const;
  ::y3d::LPoly3DMax* mutable_lp_3dmax();
  ::y3d::LPoly3DMax* release_lp_3dmax();
  void set_allocated_lp_3dmax(::y3d::LPoly3DMax* lp_3dmax);

  // optional .y3d.LPolyBlender lp_blender = 3;
  bool has_lp_blender() const;
  void clear_lp_blender();
  static const int kLpBlenderFieldNumber = 3;
  const ::y3d::LPolyBlender& lp_blender() const;
  ::y3d::LPolyBlender* mutable_lp_blender();
  ::y3d::LPolyBlender* release_lp_blender();
  void set_allocated_lp_blender(::y3d::LPolyBlender* lp_blender);

  // optional .y3d.LPolyMeshlab lp_meshlab = 4;
  bool has_lp_meshlab() const;
  void clear_lp_meshlab();
  static const int kLpMeshlabFieldNumber = 4;
  const ::y3d::LPolyMeshlab& lp_meshlab() const;
  ::y3d::LPolyMeshlab* mutable_lp_meshlab();
  ::y3d::LPolyMeshlab* release_lp_meshlab();
  void set_allocated_lp_meshlab(::y3d::LPolyMeshlab* lp_meshlab);

  LowtypeCase lowtype_case() const;
  // @@protoc_insertion_point(class_scope:y3d.ELowpoly)
 private:
  inline void set_has_lp_3dmax();
  inline void set_has_lp_blender();
  inline void set_has_lp_meshlab();

  inline bool has_lowtype() const;
  void clear_lowtype();
  inline void clear_has_lowtype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr oname_;
  union LowtypeUnion {
    LowtypeUnion() {}
    ::y3d::LPoly3DMax* lp_3dmax_;
    ::y3d::LPolyBlender* lp_blender_;
    ::y3d::LPolyMeshlab* lp_meshlab_;
  } lowtype_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static ELowpoly* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO LPoly3DMax : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.LPoly3DMax) */ {
 public:
  LPoly3DMax();
  virtual ~LPoly3DMax();

  LPoly3DMax(const LPoly3DMax& from);

  inline LPoly3DMax& operator=(const LPoly3DMax& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LPoly3DMax& default_instance();

  void Swap(LPoly3DMax* other);

  // implements Message ----------------------------------------------

  inline LPoly3DMax* New() const { return New(NULL); }

  LPoly3DMax* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LPoly3DMax& from);
  void MergeFrom(const LPoly3DMax& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LPoly3DMax* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef LPoly3DMax_OpMode OpMode;
  static const OpMode CRUNCH_BORDERS =
    LPoly3DMax_OpMode_CRUNCH_BORDERS;
  static const OpMode PROTECT_BORDERS =
    LPoly3DMax_OpMode_PROTECT_BORDERS;
  static const OpMode EXCLUDE_BORDERS =
    LPoly3DMax_OpMode_EXCLUDE_BORDERS;
  static inline bool OpMode_IsValid(int value) {
    return LPoly3DMax_OpMode_IsValid(value);
  }
  static const OpMode OpMode_MIN =
    LPoly3DMax_OpMode_OpMode_MIN;
  static const OpMode OpMode_MAX =
    LPoly3DMax_OpMode_OpMode_MAX;
  static const int OpMode_ARRAYSIZE =
    LPoly3DMax_OpMode_OpMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OpMode_descriptor() {
    return LPoly3DMax_OpMode_descriptor();
  }
  static inline const ::std::string& OpMode_Name(OpMode value) {
    return LPoly3DMax_OpMode_Name(value);
  }
  static inline bool OpMode_Parse(const ::std::string& name,
      OpMode* value) {
    return LPoly3DMax_OpMode_Parse(name, value);
  }

  typedef LPoly3DMax_NormalMode NormalMode;
  static const NormalMode CRUNCH_NORMALS =
    LPoly3DMax_NormalMode_CRUNCH_NORMALS;
  static const NormalMode PROTECT_NORMALS =
    LPoly3DMax_NormalMode_PROTECT_NORMALS;
  static const NormalMode EXCLUDE_NORMALS =
    LPoly3DMax_NormalMode_EXCLUDE_NORMALS;
  static inline bool NormalMode_IsValid(int value) {
    return LPoly3DMax_NormalMode_IsValid(value);
  }
  static const NormalMode NormalMode_MIN =
    LPoly3DMax_NormalMode_NormalMode_MIN;
  static const NormalMode NormalMode_MAX =
    LPoly3DMax_NormalMode_NormalMode_MAX;
  static const int NormalMode_ARRAYSIZE =
    LPoly3DMax_NormalMode_NormalMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  NormalMode_descriptor() {
    return LPoly3DMax_NormalMode_descriptor();
  }
  static inline const ::std::string& NormalMode_Name(NormalMode value) {
    return LPoly3DMax_NormalMode_Name(value);
  }
  static inline bool NormalMode_Parse(const ::std::string& name,
      NormalMode* value) {
    return LPoly3DMax_NormalMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional float vertex_percent = 1;
  void clear_vertex_percent();
  static const int kVertexPercentFieldNumber = 1;
  float vertex_percent() const;
  void set_vertex_percent(float value);

  // optional int32 vertex_count = 2;
  void clear_vertex_count();
  static const int kVertexCountFieldNumber = 2;
  ::google::protobuf::int32 vertex_count() const;
  void set_vertex_count(::google::protobuf::int32 value);

  // optional .y3d.LPoly3DMax.OpMode optimization_mode = 3;
  void clear_optimization_mode();
  static const int kOptimizationModeFieldNumber = 3;
  ::y3d::LPoly3DMax_OpMode optimization_mode() const;
  void set_optimization_mode(::y3d::LPoly3DMax_OpMode value);

  // optional .y3d.LPoly3DMax.NormalMode normals = 4;
  void clear_normals();
  static const int kNormalsFieldNumber = 4;
  ::y3d::LPoly3DMax_NormalMode normals() const;
  void set_normals(::y3d::LPoly3DMax_NormalMode value);

  // optional bool favor_compact_faces = 5;
  void clear_favor_compact_faces();
  static const int kFavorCompactFacesFieldNumber = 5;
  bool favor_compact_faces() const;
  void set_favor_compact_faces(bool value);

  // optional bool prevent_flipped_normals = 6;
  void clear_prevent_flipped_normals();
  static const int kPreventFlippedNormalsFieldNumber = 6;
  bool prevent_flipped_normals() const;
  void set_prevent_flipped_normals(bool value);

  // optional bool lock_vertex_position = 7;
  void clear_lock_vertex_position();
  static const int kLockVertexPositionFieldNumber = 7;
  bool lock_vertex_position() const;
  void set_lock_vertex_position(bool value);

  // @@protoc_insertion_point(class_scope:y3d.LPoly3DMax)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  float vertex_percent_;
  ::google::protobuf::int32 vertex_count_;
  int optimization_mode_;
  int normals_;
  bool favor_compact_faces_;
  bool prevent_flipped_normals_;
  bool lock_vertex_position_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static LPoly3DMax* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO LPolyBlender : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.LPolyBlender) */ {
 public:
  LPolyBlender();
  virtual ~LPolyBlender();

  LPolyBlender(const LPolyBlender& from);

  inline LPolyBlender& operator=(const LPolyBlender& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LPolyBlender& default_instance();

  void Swap(LPolyBlender* other);

  // implements Message ----------------------------------------------

  inline LPolyBlender* New() const { return New(NULL); }

  LPolyBlender* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LPolyBlender& from);
  void MergeFrom(const LPolyBlender& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LPolyBlender* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float ratio = 1;
  void clear_ratio();
  static const int kRatioFieldNumber = 1;
  float ratio() const;
  void set_ratio(float value);

  // @@protoc_insertion_point(class_scope:y3d.LPolyBlender)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  float ratio_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static LPolyBlender* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO LPolyMeshlab : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.LPolyMeshlab) */ {
 public:
  LPolyMeshlab();
  virtual ~LPolyMeshlab();

  LPolyMeshlab(const LPolyMeshlab& from);

  inline LPolyMeshlab& operator=(const LPolyMeshlab& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LPolyMeshlab& default_instance();

  void Swap(LPolyMeshlab* other);

  // implements Message ----------------------------------------------

  inline LPolyMeshlab* New() const { return New(NULL); }

  LPolyMeshlab* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LPolyMeshlab& from);
  void MergeFrom(const LPolyMeshlab& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LPolyMeshlab* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:y3d.LPolyMeshlab)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static LPolyMeshlab* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO ENormal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.ENormal) */ {
 public:
  ENormal();
  virtual ~ENormal();

  ENormal(const ENormal& from);

  inline ENormal& operator=(const ENormal& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ENormal& default_instance();

  enum NtypeCase {
    kNormal3Dmax = 6,
    kNormalXnormal = 7,
    NTYPE_NOT_SET = 0,
  };

  void Swap(ENormal* other);

  // implements Message ----------------------------------------------

  inline ENormal* New() const { return New(NULL); }

  ENormal* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ENormal& from);
  void MergeFrom(const ENormal& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ENormal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string oname = 1;
  void clear_oname();
  static const int kOnameFieldNumber = 1;
  const ::std::string& oname() const;
  void set_oname(const ::std::string& value);
  void set_oname(const char* value);
  void set_oname(const char* value, size_t size);
  ::std::string* mutable_oname();
  ::std::string* release_oname();
  void set_allocated_oname(::std::string* oname);

  // optional string lowpoly = 2;
  void clear_lowpoly();
  static const int kLowpolyFieldNumber = 2;
  const ::std::string& lowpoly() const;
  void set_lowpoly(const ::std::string& value);
  void set_lowpoly(const char* value);
  void set_lowpoly(const char* value, size_t size);
  ::std::string* mutable_lowpoly();
  ::std::string* release_lowpoly();
  void set_allocated_lowpoly(::std::string* lowpoly);

  // optional string highpoly = 3;
  void clear_highpoly();
  static const int kHighpolyFieldNumber = 3;
  const ::std::string& highpoly() const;
  void set_highpoly(const ::std::string& value);
  void set_highpoly(const char* value);
  void set_highpoly(const char* value, size_t size);
  ::std::string* mutable_highpoly();
  ::std::string* release_highpoly();
  void set_allocated_highpoly(::std::string* highpoly);

  // optional uint32 tex_size = 4;
  void clear_tex_size();
  static const int kTexSizeFieldNumber = 4;
  ::google::protobuf::uint32 tex_size() const;
  void set_tex_size(::google::protobuf::uint32 value);

  // optional string out_tex = 5;
  void clear_out_tex();
  static const int kOutTexFieldNumber = 5;
  const ::std::string& out_tex() const;
  void set_out_tex(const ::std::string& value);
  void set_out_tex(const char* value);
  void set_out_tex(const char* value, size_t size);
  ::std::string* mutable_out_tex();
  ::std::string* release_out_tex();
  void set_allocated_out_tex(::std::string* out_tex);

  // optional .y3d.Normal3DMax normal_3dmax = 6;
  bool has_normal_3dmax() const;
  void clear_normal_3dmax();
  static const int kNormal3DmaxFieldNumber = 6;
  const ::y3d::Normal3DMax& normal_3dmax() const;
  ::y3d::Normal3DMax* mutable_normal_3dmax();
  ::y3d::Normal3DMax* release_normal_3dmax();
  void set_allocated_normal_3dmax(::y3d::Normal3DMax* normal_3dmax);

  // optional .xnormal.Settings normal_xnormal = 7;
  bool has_normal_xnormal() const;
  void clear_normal_xnormal();
  static const int kNormalXnormalFieldNumber = 7;
  const ::xnormal::Settings& normal_xnormal() const;
  ::xnormal::Settings* mutable_normal_xnormal();
  ::xnormal::Settings* release_normal_xnormal();
  void set_allocated_normal_xnormal(::xnormal::Settings* normal_xnormal);

  NtypeCase ntype_case() const;
  // @@protoc_insertion_point(class_scope:y3d.ENormal)
 private:
  inline void set_has_normal_3dmax();
  inline void set_has_normal_xnormal();

  inline bool has_ntype() const;
  void clear_ntype();
  inline void clear_has_ntype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr oname_;
  ::google::protobuf::internal::ArenaStringPtr lowpoly_;
  ::google::protobuf::internal::ArenaStringPtr highpoly_;
  ::google::protobuf::internal::ArenaStringPtr out_tex_;
  ::google::protobuf::uint32 tex_size_;
  union NtypeUnion {
    NtypeUnion() {}
    ::y3d::Normal3DMax* normal_3dmax_;
    ::xnormal::Settings* normal_xnormal_;
  } ntype_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static ENormal* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO Normal3DMax : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.Normal3DMax) */ {
 public:
  Normal3DMax();
  virtual ~Normal3DMax();

  Normal3DMax(const Normal3DMax& from);

  inline Normal3DMax& operator=(const Normal3DMax& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Normal3DMax& default_instance();

  void Swap(Normal3DMax* other);

  // implements Message ----------------------------------------------

  inline Normal3DMax* New() const { return New(NULL); }

  Normal3DMax* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Normal3DMax& from);
  void MergeFrom(const Normal3DMax& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Normal3DMax* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:y3d.Normal3DMax)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static Normal3DMax* default_instance_;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO ResponseEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.ResponseEvent) */ {
 public:
  ResponseEvent();
  virtual ~ResponseEvent();

  ResponseEvent(const ResponseEvent& from);

  inline ResponseEvent& operator=(const ResponseEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseEvent& default_instance();

  void Swap(ResponseEvent* other);

  // implements Message ----------------------------------------------

  inline ResponseEvent* New() const { return New(NULL); }

  ResponseEvent* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseEvent& from);
  void MergeFrom(const ResponseEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool error = 1;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  bool error() const;
  void set_error(bool value);

  // optional string msg = 2;
  void clear_msg();
  static const int kMsgFieldNumber = 2;
  const ::std::string& msg() const;
  void set_msg(const ::std::string& value);
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  ::std::string* mutable_msg();
  ::std::string* release_msg();
  void set_allocated_msg(::std::string* msg);

  // @@protoc_insertion_point(class_scope:y3d.ResponseEvent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr msg_;
  bool error_;
  mutable int _cached_size_;
  friend void Y3D_EXPORT_MACRO protobuf_AddDesc_y3d_2eproto();
  friend void protobuf_AssignDesc_y3d_2eproto();
  friend void protobuf_ShutdownFile_y3d_2eproto();

  void InitAsDefaultInstance();
  static ResponseEvent* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// YColor

// optional string name = 1;
inline void YColor::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YColor::name() const {
  // @@protoc_insertion_point(field_get:y3d.YColor.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YColor::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YColor.name)
}
inline void YColor::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YColor.name)
}
inline void YColor::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YColor.name)
}
inline ::std::string* YColor::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YColor.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YColor::release_name() {
  // @@protoc_insertion_point(field_release:y3d.YColor.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YColor::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:y3d.YColor.name)
}

// optional int32 argb = 2;
inline void YColor::clear_argb() {
  argb_ = 0;
}
inline ::google::protobuf::int32 YColor::argb() const {
  // @@protoc_insertion_point(field_get:y3d.YColor.argb)
  return argb_;
}
inline void YColor::set_argb(::google::protobuf::int32 value) {
  
  argb_ = value;
  // @@protoc_insertion_point(field_set:y3d.YColor.argb)
}

// -------------------------------------------------------------------

// YPoint3

// optional float x = 1;
inline void YPoint3::clear_x() {
  x_ = 0;
}
inline float YPoint3::x() const {
  // @@protoc_insertion_point(field_get:y3d.YPoint3.x)
  return x_;
}
inline void YPoint3::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:y3d.YPoint3.x)
}

// optional float y = 2;
inline void YPoint3::clear_y() {
  y_ = 0;
}
inline float YPoint3::y() const {
  // @@protoc_insertion_point(field_get:y3d.YPoint3.y)
  return y_;
}
inline void YPoint3::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:y3d.YPoint3.y)
}

// optional float z = 3;
inline void YPoint3::clear_z() {
  z_ = 0;
}
inline float YPoint3::z() const {
  // @@protoc_insertion_point(field_get:y3d.YPoint3.z)
  return z_;
}
inline void YPoint3::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:y3d.YPoint3.z)
}

// -------------------------------------------------------------------

// YBox3

// optional .y3d.YPoint3 pmin = 1;
inline bool YBox3::has_pmin() const {
  return !_is_default_instance_ && pmin_ != NULL;
}
inline void YBox3::clear_pmin() {
  if (GetArenaNoVirtual() == NULL && pmin_ != NULL) delete pmin_;
  pmin_ = NULL;
}
inline const ::y3d::YPoint3& YBox3::pmin() const {
  // @@protoc_insertion_point(field_get:y3d.YBox3.pmin)
  return pmin_ != NULL ? *pmin_ : *default_instance_->pmin_;
}
inline ::y3d::YPoint3* YBox3::mutable_pmin() {
  
  if (pmin_ == NULL) {
    pmin_ = new ::y3d::YPoint3;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YBox3.pmin)
  return pmin_;
}
inline ::y3d::YPoint3* YBox3::release_pmin() {
  // @@protoc_insertion_point(field_release:y3d.YBox3.pmin)
  
  ::y3d::YPoint3* temp = pmin_;
  pmin_ = NULL;
  return temp;
}
inline void YBox3::set_allocated_pmin(::y3d::YPoint3* pmin) {
  delete pmin_;
  pmin_ = pmin;
  if (pmin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YBox3.pmin)
}

// optional .y3d.YPoint3 pmax = 2;
inline bool YBox3::has_pmax() const {
  return !_is_default_instance_ && pmax_ != NULL;
}
inline void YBox3::clear_pmax() {
  if (GetArenaNoVirtual() == NULL && pmax_ != NULL) delete pmax_;
  pmax_ = NULL;
}
inline const ::y3d::YPoint3& YBox3::pmax() const {
  // @@protoc_insertion_point(field_get:y3d.YBox3.pmax)
  return pmax_ != NULL ? *pmax_ : *default_instance_->pmax_;
}
inline ::y3d::YPoint3* YBox3::mutable_pmax() {
  
  if (pmax_ == NULL) {
    pmax_ = new ::y3d::YPoint3;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YBox3.pmax)
  return pmax_;
}
inline ::y3d::YPoint3* YBox3::release_pmax() {
  // @@protoc_insertion_point(field_release:y3d.YBox3.pmax)
  
  ::y3d::YPoint3* temp = pmax_;
  pmax_ = NULL;
  return temp;
}
inline void YBox3::set_allocated_pmax(::y3d::YPoint3* pmax) {
  delete pmax_;
  pmax_ = pmax;
  if (pmax) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YBox3.pmax)
}

// -------------------------------------------------------------------

// YResource

// optional string rid = 1;
inline void YResource::clear_rid() {
  rid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YResource::rid() const {
  // @@protoc_insertion_point(field_get:y3d.YResource.rid)
  return rid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YResource::set_rid(const ::std::string& value) {
  
  rid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YResource.rid)
}
inline void YResource::set_rid(const char* value) {
  
  rid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YResource.rid)
}
inline void YResource::set_rid(const char* value, size_t size) {
  
  rid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YResource.rid)
}
inline ::std::string* YResource::mutable_rid() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YResource.rid)
  return rid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YResource::release_rid() {
  // @@protoc_insertion_point(field_release:y3d.YResource.rid)
  
  return rid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YResource::set_allocated_rid(::std::string* rid) {
  if (rid != NULL) {
    
  } else {
    
  }
  rid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rid);
  // @@protoc_insertion_point(field_set_allocated:y3d.YResource.rid)
}

// optional .y3d.YResource.ResourceType rtype = 2;
inline void YResource::clear_rtype() {
  rtype_ = 0;
}
inline ::y3d::YResource_ResourceType YResource::rtype() const {
  // @@protoc_insertion_point(field_get:y3d.YResource.rtype)
  return static_cast< ::y3d::YResource_ResourceType >(rtype_);
}
inline void YResource::set_rtype(::y3d::YResource_ResourceType value) {
  
  rtype_ = value;
  // @@protoc_insertion_point(field_set:y3d.YResource.rtype)
}

// optional string link = 3;
inline void YResource::clear_link() {
  link_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YResource::link() const {
  // @@protoc_insertion_point(field_get:y3d.YResource.link)
  return link_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YResource::set_link(const ::std::string& value) {
  
  link_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YResource.link)
}
inline void YResource::set_link(const char* value) {
  
  link_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YResource.link)
}
inline void YResource::set_link(const char* value, size_t size) {
  
  link_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YResource.link)
}
inline ::std::string* YResource::mutable_link() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YResource.link)
  return link_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YResource::release_link() {
  // @@protoc_insertion_point(field_release:y3d.YResource.link)
  
  return link_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YResource::set_allocated_link(::std::string* link) {
  if (link != NULL) {
    
  } else {
    
  }
  link_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), link);
  // @@protoc_insertion_point(field_set_allocated:y3d.YResource.link)
}

// -------------------------------------------------------------------

// YLight

// repeated float diffuse = 3;
inline int YLight::diffuse_size() const {
  return diffuse_.size();
}
inline void YLight::clear_diffuse() {
  diffuse_.Clear();
}
inline float YLight::diffuse(int index) const {
  // @@protoc_insertion_point(field_get:y3d.YLight.diffuse)
  return diffuse_.Get(index);
}
inline void YLight::set_diffuse(int index, float value) {
  diffuse_.Set(index, value);
  // @@protoc_insertion_point(field_set:y3d.YLight.diffuse)
}
inline void YLight::add_diffuse(float value) {
  diffuse_.Add(value);
  // @@protoc_insertion_point(field_add:y3d.YLight.diffuse)
}
inline const ::google::protobuf::RepeatedField< float >&
YLight::diffuse() const {
  // @@protoc_insertion_point(field_list:y3d.YLight.diffuse)
  return diffuse_;
}
inline ::google::protobuf::RepeatedField< float >*
YLight::mutable_diffuse() {
  // @@protoc_insertion_point(field_mutable_list:y3d.YLight.diffuse)
  return &diffuse_;
}

// repeated float specular = 4;
inline int YLight::specular_size() const {
  return specular_.size();
}
inline void YLight::clear_specular() {
  specular_.Clear();
}
inline float YLight::specular(int index) const {
  // @@protoc_insertion_point(field_get:y3d.YLight.specular)
  return specular_.Get(index);
}
inline void YLight::set_specular(int index, float value) {
  specular_.Set(index, value);
  // @@protoc_insertion_point(field_set:y3d.YLight.specular)
}
inline void YLight::add_specular(float value) {
  specular_.Add(value);
  // @@protoc_insertion_point(field_add:y3d.YLight.specular)
}
inline const ::google::protobuf::RepeatedField< float >&
YLight::specular() const {
  // @@protoc_insertion_point(field_list:y3d.YLight.specular)
  return specular_;
}
inline ::google::protobuf::RepeatedField< float >*
YLight::mutable_specular() {
  // @@protoc_insertion_point(field_mutable_list:y3d.YLight.specular)
  return &specular_;
}

// optional float intensity = 5;
inline void YLight::clear_intensity() {
  intensity_ = 0;
}
inline float YLight::intensity() const {
  // @@protoc_insertion_point(field_get:y3d.YLight.intensity)
  return intensity_;
}
inline void YLight::set_intensity(float value) {
  
  intensity_ = value;
  // @@protoc_insertion_point(field_set:y3d.YLight.intensity)
}

// optional float range = 6;
inline void YLight::clear_range() {
  range_ = 0;
}
inline float YLight::range() const {
  // @@protoc_insertion_point(field_get:y3d.YLight.range)
  return range_;
}
inline void YLight::set_range(float value) {
  
  range_ = value;
  // @@protoc_insertion_point(field_set:y3d.YLight.range)
}

// optional float angle = 7;
inline void YLight::clear_angle() {
  angle_ = 0;
}
inline float YLight::angle() const {
  // @@protoc_insertion_point(field_get:y3d.YLight.angle)
  return angle_;
}
inline void YLight::set_angle(float value) {
  
  angle_ = value;
  // @@protoc_insertion_point(field_set:y3d.YLight.angle)
}

// optional float exponent = 8;
inline void YLight::clear_exponent() {
  exponent_ = 0;
}
inline float YLight::exponent() const {
  // @@protoc_insertion_point(field_get:y3d.YLight.exponent)
  return exponent_;
}
inline void YLight::set_exponent(float value) {
  
  exponent_ = value;
  // @@protoc_insertion_point(field_set:y3d.YLight.exponent)
}

// repeated string excludedMeshesIds = 9;
inline int YLight::excludedmeshesids_size() const {
  return excludedmeshesids_.size();
}
inline void YLight::clear_excludedmeshesids() {
  excludedmeshesids_.Clear();
}
inline const ::std::string& YLight::excludedmeshesids(int index) const {
  // @@protoc_insertion_point(field_get:y3d.YLight.excludedMeshesIds)
  return excludedmeshesids_.Get(index);
}
inline ::std::string* YLight::mutable_excludedmeshesids(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.YLight.excludedMeshesIds)
  return excludedmeshesids_.Mutable(index);
}
inline void YLight::set_excludedmeshesids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:y3d.YLight.excludedMeshesIds)
  excludedmeshesids_.Mutable(index)->assign(value);
}
inline void YLight::set_excludedmeshesids(int index, const char* value) {
  excludedmeshesids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:y3d.YLight.excludedMeshesIds)
}
inline void YLight::set_excludedmeshesids(int index, const char* value, size_t size) {
  excludedmeshesids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:y3d.YLight.excludedMeshesIds)
}
inline ::std::string* YLight::add_excludedmeshesids() {
  // @@protoc_insertion_point(field_add_mutable:y3d.YLight.excludedMeshesIds)
  return excludedmeshesids_.Add();
}
inline void YLight::add_excludedmeshesids(const ::std::string& value) {
  excludedmeshesids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:y3d.YLight.excludedMeshesIds)
}
inline void YLight::add_excludedmeshesids(const char* value) {
  excludedmeshesids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:y3d.YLight.excludedMeshesIds)
}
inline void YLight::add_excludedmeshesids(const char* value, size_t size) {
  excludedmeshesids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:y3d.YLight.excludedMeshesIds)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
YLight::excludedmeshesids() const {
  // @@protoc_insertion_point(field_list:y3d.YLight.excludedMeshesIds)
  return excludedmeshesids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
YLight::mutable_excludedmeshesids() {
  // @@protoc_insertion_point(field_mutable_list:y3d.YLight.excludedMeshesIds)
  return &excludedmeshesids_;
}

// repeated string includedOnlyMeshesIds = 10;
inline int YLight::includedonlymeshesids_size() const {
  return includedonlymeshesids_.size();
}
inline void YLight::clear_includedonlymeshesids() {
  includedonlymeshesids_.Clear();
}
inline const ::std::string& YLight::includedonlymeshesids(int index) const {
  // @@protoc_insertion_point(field_get:y3d.YLight.includedOnlyMeshesIds)
  return includedonlymeshesids_.Get(index);
}
inline ::std::string* YLight::mutable_includedonlymeshesids(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.YLight.includedOnlyMeshesIds)
  return includedonlymeshesids_.Mutable(index);
}
inline void YLight::set_includedonlymeshesids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:y3d.YLight.includedOnlyMeshesIds)
  includedonlymeshesids_.Mutable(index)->assign(value);
}
inline void YLight::set_includedonlymeshesids(int index, const char* value) {
  includedonlymeshesids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:y3d.YLight.includedOnlyMeshesIds)
}
inline void YLight::set_includedonlymeshesids(int index, const char* value, size_t size) {
  includedonlymeshesids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:y3d.YLight.includedOnlyMeshesIds)
}
inline ::std::string* YLight::add_includedonlymeshesids() {
  // @@protoc_insertion_point(field_add_mutable:y3d.YLight.includedOnlyMeshesIds)
  return includedonlymeshesids_.Add();
}
inline void YLight::add_includedonlymeshesids(const ::std::string& value) {
  includedonlymeshesids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:y3d.YLight.includedOnlyMeshesIds)
}
inline void YLight::add_includedonlymeshesids(const char* value) {
  includedonlymeshesids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:y3d.YLight.includedOnlyMeshesIds)
}
inline void YLight::add_includedonlymeshesids(const char* value, size_t size) {
  includedonlymeshesids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:y3d.YLight.includedOnlyMeshesIds)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
YLight::includedonlymeshesids() const {
  // @@protoc_insertion_point(field_list:y3d.YLight.includedOnlyMeshesIds)
  return includedonlymeshesids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
YLight::mutable_includedonlymeshesids() {
  // @@protoc_insertion_point(field_mutable_list:y3d.YLight.includedOnlyMeshesIds)
  return &includedonlymeshesids_;
}

// -------------------------------------------------------------------

// YCamera

// repeated float rotation = 3;
inline int YCamera::rotation_size() const {
  return rotation_.size();
}
inline void YCamera::clear_rotation() {
  rotation_.Clear();
}
inline float YCamera::rotation(int index) const {
  // @@protoc_insertion_point(field_get:y3d.YCamera.rotation)
  return rotation_.Get(index);
}
inline void YCamera::set_rotation(int index, float value) {
  rotation_.Set(index, value);
  // @@protoc_insertion_point(field_set:y3d.YCamera.rotation)
}
inline void YCamera::add_rotation(float value) {
  rotation_.Add(value);
  // @@protoc_insertion_point(field_add:y3d.YCamera.rotation)
}
inline const ::google::protobuf::RepeatedField< float >&
YCamera::rotation() const {
  // @@protoc_insertion_point(field_list:y3d.YCamera.rotation)
  return rotation_;
}
inline ::google::protobuf::RepeatedField< float >*
YCamera::mutable_rotation() {
  // @@protoc_insertion_point(field_mutable_list:y3d.YCamera.rotation)
  return &rotation_;
}

// repeated float target = 4;
inline int YCamera::target_size() const {
  return target_.size();
}
inline void YCamera::clear_target() {
  target_.Clear();
}
inline float YCamera::target(int index) const {
  // @@protoc_insertion_point(field_get:y3d.YCamera.target)
  return target_.Get(index);
}
inline void YCamera::set_target(int index, float value) {
  target_.Set(index, value);
  // @@protoc_insertion_point(field_set:y3d.YCamera.target)
}
inline void YCamera::add_target(float value) {
  target_.Add(value);
  // @@protoc_insertion_point(field_add:y3d.YCamera.target)
}
inline const ::google::protobuf::RepeatedField< float >&
YCamera::target() const {
  // @@protoc_insertion_point(field_list:y3d.YCamera.target)
  return target_;
}
inline ::google::protobuf::RepeatedField< float >*
YCamera::mutable_target() {
  // @@protoc_insertion_point(field_mutable_list:y3d.YCamera.target)
  return &target_;
}

// optional float fov = 5;
inline void YCamera::clear_fov() {
  fov_ = 0;
}
inline float YCamera::fov() const {
  // @@protoc_insertion_point(field_get:y3d.YCamera.fov)
  return fov_;
}
inline void YCamera::set_fov(float value) {
  
  fov_ = value;
  // @@protoc_insertion_point(field_set:y3d.YCamera.fov)
}

// -------------------------------------------------------------------

// YMesh

// optional int32 num_faces = 1;
inline void YMesh::clear_num_faces() {
  num_faces_ = 0;
}
inline ::google::protobuf::int32 YMesh::num_faces() const {
  // @@protoc_insertion_point(field_get:y3d.YMesh.num_faces)
  return num_faces_;
}
inline void YMesh::set_num_faces(::google::protobuf::int32 value) {
  
  num_faces_ = value;
  // @@protoc_insertion_point(field_set:y3d.YMesh.num_faces)
}

// optional .y3d.YBox3 bbox = 2;
inline bool YMesh::has_bbox() const {
  return !_is_default_instance_ && bbox_ != NULL;
}
inline void YMesh::clear_bbox() {
  if (GetArenaNoVirtual() == NULL && bbox_ != NULL) delete bbox_;
  bbox_ = NULL;
}
inline const ::y3d::YBox3& YMesh::bbox() const {
  // @@protoc_insertion_point(field_get:y3d.YMesh.bbox)
  return bbox_ != NULL ? *bbox_ : *default_instance_->bbox_;
}
inline ::y3d::YBox3* YMesh::mutable_bbox() {
  
  if (bbox_ == NULL) {
    bbox_ = new ::y3d::YBox3;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YMesh.bbox)
  return bbox_;
}
inline ::y3d::YBox3* YMesh::release_bbox() {
  // @@protoc_insertion_point(field_release:y3d.YMesh.bbox)
  
  ::y3d::YBox3* temp = bbox_;
  bbox_ = NULL;
  return temp;
}
inline void YMesh::set_allocated_bbox(::y3d::YBox3* bbox) {
  delete bbox_;
  bbox_ = bbox;
  if (bbox) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YMesh.bbox)
}

// optional string res_id = 3;
inline void YMesh::clear_res_id() {
  res_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YMesh::res_id() const {
  // @@protoc_insertion_point(field_get:y3d.YMesh.res_id)
  return res_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YMesh::set_res_id(const ::std::string& value) {
  
  res_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YMesh.res_id)
}
inline void YMesh::set_res_id(const char* value) {
  
  res_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YMesh.res_id)
}
inline void YMesh::set_res_id(const char* value, size_t size) {
  
  res_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YMesh.res_id)
}
inline ::std::string* YMesh::mutable_res_id() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YMesh.res_id)
  return res_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YMesh::release_res_id() {
  // @@protoc_insertion_point(field_release:y3d.YMesh.res_id)
  
  return res_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YMesh::set_allocated_res_id(::std::string* res_id) {
  if (res_id != NULL) {
    
  } else {
    
  }
  res_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), res_id);
  // @@protoc_insertion_point(field_set_allocated:y3d.YMesh.res_id)
}

// optional .y3d.YMesh.XrefStatus xstatus = 5;
inline void YMesh::clear_xstatus() {
  xstatus_ = 0;
}
inline ::y3d::YMesh_XrefStatus YMesh::xstatus() const {
  // @@protoc_insertion_point(field_get:y3d.YMesh.xstatus)
  return static_cast< ::y3d::YMesh_XrefStatus >(xstatus_);
}
inline void YMesh::set_xstatus(::y3d::YMesh_XrefStatus value) {
  
  xstatus_ = value;
  // @@protoc_insertion_point(field_set:y3d.YMesh.xstatus)
}

// optional .y3d.YMesh.MeshType mtype = 6;
inline void YMesh::clear_mtype() {
  mtype_ = 0;
}
inline ::y3d::YMesh_MeshType YMesh::mtype() const {
  // @@protoc_insertion_point(field_get:y3d.YMesh.mtype)
  return static_cast< ::y3d::YMesh_MeshType >(mtype_);
}
inline void YMesh::set_mtype(::y3d::YMesh_MeshType value) {
  
  mtype_ = value;
  // @@protoc_insertion_point(field_set:y3d.YMesh.mtype)
}

// optional string vername = 7;
inline void YMesh::clear_vername() {
  vername_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YMesh::vername() const {
  // @@protoc_insertion_point(field_get:y3d.YMesh.vername)
  return vername_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YMesh::set_vername(const ::std::string& value) {
  
  vername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YMesh.vername)
}
inline void YMesh::set_vername(const char* value) {
  
  vername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YMesh.vername)
}
inline void YMesh::set_vername(const char* value, size_t size) {
  
  vername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YMesh.vername)
}
inline ::std::string* YMesh::mutable_vername() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YMesh.vername)
  return vername_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YMesh::release_vername() {
  // @@protoc_insertion_point(field_release:y3d.YMesh.vername)
  
  return vername_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YMesh::set_allocated_vername(::std::string* vername) {
  if (vername != NULL) {
    
  } else {
    
  }
  vername_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vername);
  // @@protoc_insertion_point(field_set_allocated:y3d.YMesh.vername)
}

// -------------------------------------------------------------------

// YObject

// optional string name = 1;
inline void YObject::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YObject::name() const {
  // @@protoc_insertion_point(field_get:y3d.YObject.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YObject::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YObject.name)
}
inline void YObject::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YObject.name)
}
inline void YObject::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YObject.name)
}
inline ::std::string* YObject::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YObject.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YObject::release_name() {
  // @@protoc_insertion_point(field_release:y3d.YObject.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YObject::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:y3d.YObject.name)
}

// optional .y3d.YPoint3 pos = 3;
inline bool YObject::has_pos() const {
  return !_is_default_instance_ && pos_ != NULL;
}
inline void YObject::clear_pos() {
  if (GetArenaNoVirtual() == NULL && pos_ != NULL) delete pos_;
  pos_ = NULL;
}
inline const ::y3d::YPoint3& YObject::pos() const {
  // @@protoc_insertion_point(field_get:y3d.YObject.pos)
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::y3d::YPoint3* YObject::mutable_pos() {
  
  if (pos_ == NULL) {
    pos_ = new ::y3d::YPoint3;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YObject.pos)
  return pos_;
}
inline ::y3d::YPoint3* YObject::release_pos() {
  // @@protoc_insertion_point(field_release:y3d.YObject.pos)
  
  ::y3d::YPoint3* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void YObject::set_allocated_pos(::y3d::YPoint3* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YObject.pos)
}

// map<string, .google.protobuf.Any> extra = 5;
inline int YObject::extra_size() const {
  return extra_.size();
}
inline void YObject::clear_extra() {
  extra_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::google::protobuf::Any >&
YObject::extra() const {
  // @@protoc_insertion_point(field_map:y3d.YObject.extra)
  return extra_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::google::protobuf::Any >*
YObject::mutable_extra() {
  // @@protoc_insertion_point(field_mutable_map:y3d.YObject.extra)
  return extra_.MutableMap();
}

// optional .y3d.ObjectType otype = 6;
inline void YObject::clear_otype() {
  otype_ = 0;
}
inline ::y3d::ObjectType YObject::otype() const {
  // @@protoc_insertion_point(field_get:y3d.YObject.otype)
  return static_cast< ::y3d::ObjectType >(otype_);
}
inline void YObject::set_otype(::y3d::ObjectType value) {
  
  otype_ = value;
  // @@protoc_insertion_point(field_set:y3d.YObject.otype)
}

// repeated string tags = 7;
inline int YObject::tags_size() const {
  return tags_.size();
}
inline void YObject::clear_tags() {
  tags_.Clear();
}
inline const ::std::string& YObject::tags(int index) const {
  // @@protoc_insertion_point(field_get:y3d.YObject.tags)
  return tags_.Get(index);
}
inline ::std::string* YObject::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.YObject.tags)
  return tags_.Mutable(index);
}
inline void YObject::set_tags(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:y3d.YObject.tags)
  tags_.Mutable(index)->assign(value);
}
inline void YObject::set_tags(int index, const char* value) {
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:y3d.YObject.tags)
}
inline void YObject::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:y3d.YObject.tags)
}
inline ::std::string* YObject::add_tags() {
  // @@protoc_insertion_point(field_add_mutable:y3d.YObject.tags)
  return tags_.Add();
}
inline void YObject::add_tags(const ::std::string& value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:y3d.YObject.tags)
}
inline void YObject::add_tags(const char* value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:y3d.YObject.tags)
}
inline void YObject::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:y3d.YObject.tags)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
YObject::tags() const {
  // @@protoc_insertion_point(field_list:y3d.YObject.tags)
  return tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
YObject::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:y3d.YObject.tags)
  return &tags_;
}

// optional int32 cate_id = 8;
inline void YObject::clear_cate_id() {
  cate_id_ = 0;
}
inline ::google::protobuf::int32 YObject::cate_id() const {
  // @@protoc_insertion_point(field_get:y3d.YObject.cate_id)
  return cate_id_;
}
inline void YObject::set_cate_id(::google::protobuf::int32 value) {
  
  cate_id_ = value;
  // @@protoc_insertion_point(field_set:y3d.YObject.cate_id)
}

// optional .y3d.YLight light = 10;
inline bool YObject::has_light() const {
  return data_case() == kLight;
}
inline void YObject::set_has_light() {
  _oneof_case_[0] = kLight;
}
inline void YObject::clear_light() {
  if (has_light()) {
    delete data_.light_;
    clear_has_data();
  }
}
inline  const ::y3d::YLight& YObject::light() const {
  // @@protoc_insertion_point(field_get:y3d.YObject.light)
  return has_light()
      ? *data_.light_
      : ::y3d::YLight::default_instance();
}
inline ::y3d::YLight* YObject::mutable_light() {
  if (!has_light()) {
    clear_data();
    set_has_light();
    data_.light_ = new ::y3d::YLight;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YObject.light)
  return data_.light_;
}
inline ::y3d::YLight* YObject::release_light() {
  // @@protoc_insertion_point(field_release:y3d.YObject.light)
  if (has_light()) {
    clear_has_data();
    ::y3d::YLight* temp = data_.light_;
    data_.light_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void YObject::set_allocated_light(::y3d::YLight* light) {
  clear_data();
  if (light) {
    set_has_light();
    data_.light_ = light;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YObject.light)
}

// optional .y3d.YCamera camera = 11;
inline bool YObject::has_camera() const {
  return data_case() == kCamera;
}
inline void YObject::set_has_camera() {
  _oneof_case_[0] = kCamera;
}
inline void YObject::clear_camera() {
  if (has_camera()) {
    delete data_.camera_;
    clear_has_data();
  }
}
inline  const ::y3d::YCamera& YObject::camera() const {
  // @@protoc_insertion_point(field_get:y3d.YObject.camera)
  return has_camera()
      ? *data_.camera_
      : ::y3d::YCamera::default_instance();
}
inline ::y3d::YCamera* YObject::mutable_camera() {
  if (!has_camera()) {
    clear_data();
    set_has_camera();
    data_.camera_ = new ::y3d::YCamera;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YObject.camera)
  return data_.camera_;
}
inline ::y3d::YCamera* YObject::release_camera() {
  // @@protoc_insertion_point(field_release:y3d.YObject.camera)
  if (has_camera()) {
    clear_has_data();
    ::y3d::YCamera* temp = data_.camera_;
    data_.camera_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void YObject::set_allocated_camera(::y3d::YCamera* camera) {
  clear_data();
  if (camera) {
    set_has_camera();
    data_.camera_ = camera;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YObject.camera)
}

// optional .y3d.YMesh mesh = 12;
inline bool YObject::has_mesh() const {
  return data_case() == kMesh;
}
inline void YObject::set_has_mesh() {
  _oneof_case_[0] = kMesh;
}
inline void YObject::clear_mesh() {
  if (has_mesh()) {
    delete data_.mesh_;
    clear_has_data();
  }
}
inline  const ::y3d::YMesh& YObject::mesh() const {
  // @@protoc_insertion_point(field_get:y3d.YObject.mesh)
  return has_mesh()
      ? *data_.mesh_
      : ::y3d::YMesh::default_instance();
}
inline ::y3d::YMesh* YObject::mutable_mesh() {
  if (!has_mesh()) {
    clear_data();
    set_has_mesh();
    data_.mesh_ = new ::y3d::YMesh;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YObject.mesh)
  return data_.mesh_;
}
inline ::y3d::YMesh* YObject::release_mesh() {
  // @@protoc_insertion_point(field_release:y3d.YObject.mesh)
  if (has_mesh()) {
    clear_has_data();
    ::y3d::YMesh* temp = data_.mesh_;
    data_.mesh_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void YObject::set_allocated_mesh(::y3d::YMesh* mesh) {
  clear_data();
  if (mesh) {
    set_has_mesh();
    data_.mesh_ = mesh;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YObject.mesh)
}

inline bool YObject::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void YObject::clear_has_data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline YObject::DataCase YObject::data_case() const {
  return YObject::DataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// YArea

// optional string name = 1;
inline void YArea::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YArea::name() const {
  // @@protoc_insertion_point(field_get:y3d.YArea.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YArea::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YArea.name)
}
inline void YArea::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YArea.name)
}
inline void YArea::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YArea.name)
}
inline ::std::string* YArea::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YArea.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YArea::release_name() {
  // @@protoc_insertion_point(field_release:y3d.YArea.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YArea::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:y3d.YArea.name)
}

// repeated .y3d.YGroup groups = 2;
inline int YArea::groups_size() const {
  return groups_.size();
}
inline void YArea::clear_groups() {
  groups_.Clear();
}
inline const ::y3d::YGroup& YArea::groups(int index) const {
  // @@protoc_insertion_point(field_get:y3d.YArea.groups)
  return groups_.Get(index);
}
inline ::y3d::YGroup* YArea::mutable_groups(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.YArea.groups)
  return groups_.Mutable(index);
}
inline ::y3d::YGroup* YArea::add_groups() {
  // @@protoc_insertion_point(field_add:y3d.YArea.groups)
  return groups_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::y3d::YGroup >*
YArea::mutable_groups() {
  // @@protoc_insertion_point(field_mutable_list:y3d.YArea.groups)
  return &groups_;
}
inline const ::google::protobuf::RepeatedPtrField< ::y3d::YGroup >&
YArea::groups() const {
  // @@protoc_insertion_point(field_list:y3d.YArea.groups)
  return groups_;
}

// repeated .y3d.YObject objs = 3;
inline int YArea::objs_size() const {
  return objs_.size();
}
inline void YArea::clear_objs() {
  objs_.Clear();
}
inline const ::y3d::YObject& YArea::objs(int index) const {
  // @@protoc_insertion_point(field_get:y3d.YArea.objs)
  return objs_.Get(index);
}
inline ::y3d::YObject* YArea::mutable_objs(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.YArea.objs)
  return objs_.Mutable(index);
}
inline ::y3d::YObject* YArea::add_objs() {
  // @@protoc_insertion_point(field_add:y3d.YArea.objs)
  return objs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::y3d::YObject >*
YArea::mutable_objs() {
  // @@protoc_insertion_point(field_mutable_list:y3d.YArea.objs)
  return &objs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::y3d::YObject >&
YArea::objs() const {
  // @@protoc_insertion_point(field_list:y3d.YArea.objs)
  return objs_;
}

// map<string, .y3d.YGroupVer> gvers = 6;
inline int YArea::gvers_size() const {
  return gvers_.size();
}
inline void YArea::clear_gvers() {
  gvers_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::y3d::YGroupVer >&
YArea::gvers() const {
  // @@protoc_insertion_point(field_map:y3d.YArea.gvers)
  return gvers_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::y3d::YGroupVer >*
YArea::mutable_gvers() {
  // @@protoc_insertion_point(field_mutable_map:y3d.YArea.gvers)
  return gvers_.MutableMap();
}

// -------------------------------------------------------------------

// YAreaList

// repeated .y3d.YArea areas = 1;
inline int YAreaList::areas_size() const {
  return areas_.size();
}
inline void YAreaList::clear_areas() {
  areas_.Clear();
}
inline const ::y3d::YArea& YAreaList::areas(int index) const {
  // @@protoc_insertion_point(field_get:y3d.YAreaList.areas)
  return areas_.Get(index);
}
inline ::y3d::YArea* YAreaList::mutable_areas(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.YAreaList.areas)
  return areas_.Mutable(index);
}
inline ::y3d::YArea* YAreaList::add_areas() {
  // @@protoc_insertion_point(field_add:y3d.YAreaList.areas)
  return areas_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::y3d::YArea >*
YAreaList::mutable_areas() {
  // @@protoc_insertion_point(field_mutable_list:y3d.YAreaList.areas)
  return &areas_;
}
inline const ::google::protobuf::RepeatedPtrField< ::y3d::YArea >&
YAreaList::areas() const {
  // @@protoc_insertion_point(field_list:y3d.YAreaList.areas)
  return areas_;
}

// -------------------------------------------------------------------

// YLayer

// optional string name = 1;
inline void YLayer::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YLayer::name() const {
  // @@protoc_insertion_point(field_get:y3d.YLayer.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YLayer::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YLayer.name)
}
inline void YLayer::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YLayer.name)
}
inline void YLayer::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YLayer.name)
}
inline ::std::string* YLayer::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YLayer.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YLayer::release_name() {
  // @@protoc_insertion_point(field_release:y3d.YLayer.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YLayer::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:y3d.YLayer.name)
}

// repeated .y3d.YGroup groups = 2;
inline int YLayer::groups_size() const {
  return groups_.size();
}
inline void YLayer::clear_groups() {
  groups_.Clear();
}
inline const ::y3d::YGroup& YLayer::groups(int index) const {
  // @@protoc_insertion_point(field_get:y3d.YLayer.groups)
  return groups_.Get(index);
}
inline ::y3d::YGroup* YLayer::mutable_groups(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.YLayer.groups)
  return groups_.Mutable(index);
}
inline ::y3d::YGroup* YLayer::add_groups() {
  // @@protoc_insertion_point(field_add:y3d.YLayer.groups)
  return groups_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::y3d::YGroup >*
YLayer::mutable_groups() {
  // @@protoc_insertion_point(field_mutable_list:y3d.YLayer.groups)
  return &groups_;
}
inline const ::google::protobuf::RepeatedPtrField< ::y3d::YGroup >&
YLayer::groups() const {
  // @@protoc_insertion_point(field_list:y3d.YLayer.groups)
  return groups_;
}

// -------------------------------------------------------------------

// YGroup

// optional string name = 1;
inline void YGroup::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YGroup::name() const {
  // @@protoc_insertion_point(field_get:y3d.YGroup.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YGroup::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YGroup.name)
}
inline void YGroup::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YGroup.name)
}
inline void YGroup::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YGroup.name)
}
inline ::std::string* YGroup::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YGroup.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YGroup::release_name() {
  // @@protoc_insertion_point(field_release:y3d.YGroup.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YGroup::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:y3d.YGroup.name)
}

// repeated .y3d.YObject objs = 2;
inline int YGroup::objs_size() const {
  return objs_.size();
}
inline void YGroup::clear_objs() {
  objs_.Clear();
}
inline const ::y3d::YObject& YGroup::objs(int index) const {
  // @@protoc_insertion_point(field_get:y3d.YGroup.objs)
  return objs_.Get(index);
}
inline ::y3d::YObject* YGroup::mutable_objs(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.YGroup.objs)
  return objs_.Mutable(index);
}
inline ::y3d::YObject* YGroup::add_objs() {
  // @@protoc_insertion_point(field_add:y3d.YGroup.objs)
  return objs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::y3d::YObject >*
YGroup::mutable_objs() {
  // @@protoc_insertion_point(field_mutable_list:y3d.YGroup.objs)
  return &objs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::y3d::YObject >&
YGroup::objs() const {
  // @@protoc_insertion_point(field_list:y3d.YGroup.objs)
  return objs_;
}

// repeated .y3d.YGroup children = 3;
inline int YGroup::children_size() const {
  return children_.size();
}
inline void YGroup::clear_children() {
  children_.Clear();
}
inline const ::y3d::YGroup& YGroup::children(int index) const {
  // @@protoc_insertion_point(field_get:y3d.YGroup.children)
  return children_.Get(index);
}
inline ::y3d::YGroup* YGroup::mutable_children(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.YGroup.children)
  return children_.Mutable(index);
}
inline ::y3d::YGroup* YGroup::add_children() {
  // @@protoc_insertion_point(field_add:y3d.YGroup.children)
  return children_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::y3d::YGroup >*
YGroup::mutable_children() {
  // @@protoc_insertion_point(field_mutable_list:y3d.YGroup.children)
  return &children_;
}
inline const ::google::protobuf::RepeatedPtrField< ::y3d::YGroup >&
YGroup::children() const {
  // @@protoc_insertion_point(field_list:y3d.YGroup.children)
  return children_;
}

// optional .y3d.GVerType gv_type = 4;
inline void YGroup::clear_gv_type() {
  gv_type_ = 0;
}
inline ::y3d::GVerType YGroup::gv_type() const {
  // @@protoc_insertion_point(field_get:y3d.YGroup.gv_type)
  return static_cast< ::y3d::GVerType >(gv_type_);
}
inline void YGroup::set_gv_type(::y3d::GVerType value) {
  
  gv_type_ = value;
  // @@protoc_insertion_point(field_set:y3d.YGroup.gv_type)
}

// repeated string xref = 5;
inline int YGroup::xref_size() const {
  return xref_.size();
}
inline void YGroup::clear_xref() {
  xref_.Clear();
}
inline const ::std::string& YGroup::xref(int index) const {
  // @@protoc_insertion_point(field_get:y3d.YGroup.xref)
  return xref_.Get(index);
}
inline ::std::string* YGroup::mutable_xref(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.YGroup.xref)
  return xref_.Mutable(index);
}
inline void YGroup::set_xref(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:y3d.YGroup.xref)
  xref_.Mutable(index)->assign(value);
}
inline void YGroup::set_xref(int index, const char* value) {
  xref_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:y3d.YGroup.xref)
}
inline void YGroup::set_xref(int index, const char* value, size_t size) {
  xref_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:y3d.YGroup.xref)
}
inline ::std::string* YGroup::add_xref() {
  // @@protoc_insertion_point(field_add_mutable:y3d.YGroup.xref)
  return xref_.Add();
}
inline void YGroup::add_xref(const ::std::string& value) {
  xref_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:y3d.YGroup.xref)
}
inline void YGroup::add_xref(const char* value) {
  xref_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:y3d.YGroup.xref)
}
inline void YGroup::add_xref(const char* value, size_t size) {
  xref_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:y3d.YGroup.xref)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
YGroup::xref() const {
  // @@protoc_insertion_point(field_list:y3d.YGroup.xref)
  return xref_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
YGroup::mutable_xref() {
  // @@protoc_insertion_point(field_mutable_list:y3d.YGroup.xref)
  return &xref_;
}

// -------------------------------------------------------------------

// YGroupVer

// optional string vname = 1;
inline void YGroupVer::clear_vname() {
  vname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YGroupVer::vname() const {
  // @@protoc_insertion_point(field_get:y3d.YGroupVer.vname)
  return vname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YGroupVer::set_vname(const ::std::string& value) {
  
  vname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YGroupVer.vname)
}
inline void YGroupVer::set_vname(const char* value) {
  
  vname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YGroupVer.vname)
}
inline void YGroupVer::set_vname(const char* value, size_t size) {
  
  vname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YGroupVer.vname)
}
inline ::std::string* YGroupVer::mutable_vname() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YGroupVer.vname)
  return vname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YGroupVer::release_vname() {
  // @@protoc_insertion_point(field_release:y3d.YGroupVer.vname)
  
  return vname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YGroupVer::set_allocated_vname(::std::string* vname) {
  if (vname != NULL) {
    
  } else {
    
  }
  vname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vname);
  // @@protoc_insertion_point(field_set_allocated:y3d.YGroupVer.vname)
}

// optional .y3d.YGroup groupData = 2;
inline bool YGroupVer::has_groupdata() const {
  return !_is_default_instance_ && groupdata_ != NULL;
}
inline void YGroupVer::clear_groupdata() {
  if (GetArenaNoVirtual() == NULL && groupdata_ != NULL) delete groupdata_;
  groupdata_ = NULL;
}
inline const ::y3d::YGroup& YGroupVer::groupdata() const {
  // @@protoc_insertion_point(field_get:y3d.YGroupVer.groupData)
  return groupdata_ != NULL ? *groupdata_ : *default_instance_->groupdata_;
}
inline ::y3d::YGroup* YGroupVer::mutable_groupdata() {
  
  if (groupdata_ == NULL) {
    groupdata_ = new ::y3d::YGroup;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YGroupVer.groupData)
  return groupdata_;
}
inline ::y3d::YGroup* YGroupVer::release_groupdata() {
  // @@protoc_insertion_point(field_release:y3d.YGroupVer.groupData)
  
  ::y3d::YGroup* temp = groupdata_;
  groupdata_ = NULL;
  return temp;
}
inline void YGroupVer::set_allocated_groupdata(::y3d::YGroup* groupdata) {
  delete groupdata_;
  groupdata_ = groupdata;
  if (groupdata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YGroupVer.groupData)
}

// optional int32 step = 3;
inline void YGroupVer::clear_step() {
  step_ = 0;
}
inline ::google::protobuf::int32 YGroupVer::step() const {
  // @@protoc_insertion_point(field_get:y3d.YGroupVer.step)
  return step_;
}
inline void YGroupVer::set_step(::google::protobuf::int32 value) {
  
  step_ = value;
  // @@protoc_insertion_point(field_set:y3d.YGroupVer.step)
}

// -------------------------------------------------------------------

// FilterView

// optional .y3d.ObjectType otype = 1;
inline void FilterView::clear_otype() {
  otype_ = 0;
}
inline ::y3d::ObjectType FilterView::otype() const {
  // @@protoc_insertion_point(field_get:y3d.FilterView.otype)
  return static_cast< ::y3d::ObjectType >(otype_);
}
inline void FilterView::set_otype(::y3d::ObjectType value) {
  
  otype_ = value;
  // @@protoc_insertion_point(field_set:y3d.FilterView.otype)
}

// optional int32 face_range = 2;
inline void FilterView::clear_face_range() {
  face_range_ = 0;
}
inline ::google::protobuf::int32 FilterView::face_range() const {
  // @@protoc_insertion_point(field_get:y3d.FilterView.face_range)
  return face_range_;
}
inline void FilterView::set_face_range(::google::protobuf::int32 value) {
  
  face_range_ = value;
  // @@protoc_insertion_point(field_set:y3d.FilterView.face_range)
}

// optional string search = 3;
inline void FilterView::clear_search() {
  search_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FilterView::search() const {
  // @@protoc_insertion_point(field_get:y3d.FilterView.search)
  return search_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FilterView::set_search(const ::std::string& value) {
  
  search_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.FilterView.search)
}
inline void FilterView::set_search(const char* value) {
  
  search_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.FilterView.search)
}
inline void FilterView::set_search(const char* value, size_t size) {
  
  search_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.FilterView.search)
}
inline ::std::string* FilterView::mutable_search() {
  
  // @@protoc_insertion_point(field_mutable:y3d.FilterView.search)
  return search_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FilterView::release_search() {
  // @@protoc_insertion_point(field_release:y3d.FilterView.search)
  
  return search_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FilterView::set_allocated_search(::std::string* search) {
  if (search != NULL) {
    
  } else {
    
  }
  search_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), search);
  // @@protoc_insertion_point(field_set_allocated:y3d.FilterView.search)
}

// optional int32 aid = 4;
inline void FilterView::clear_aid() {
  aid_ = 0;
}
inline ::google::protobuf::int32 FilterView::aid() const {
  // @@protoc_insertion_point(field_get:y3d.FilterView.aid)
  return aid_;
}
inline void FilterView::set_aid(::google::protobuf::int32 value) {
  
  aid_ = value;
  // @@protoc_insertion_point(field_set:y3d.FilterView.aid)
}

// -------------------------------------------------------------------

// ProjectInfo

// optional string pname = 1;
inline void ProjectInfo::clear_pname() {
  pname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProjectInfo::pname() const {
  // @@protoc_insertion_point(field_get:y3d.ProjectInfo.pname)
  return pname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProjectInfo::set_pname(const ::std::string& value) {
  
  pname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.ProjectInfo.pname)
}
inline void ProjectInfo::set_pname(const char* value) {
  
  pname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.ProjectInfo.pname)
}
inline void ProjectInfo::set_pname(const char* value, size_t size) {
  
  pname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.ProjectInfo.pname)
}
inline ::std::string* ProjectInfo::mutable_pname() {
  
  // @@protoc_insertion_point(field_mutable:y3d.ProjectInfo.pname)
  return pname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProjectInfo::release_pname() {
  // @@protoc_insertion_point(field_release:y3d.ProjectInfo.pname)
  
  return pname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProjectInfo::set_allocated_pname(::std::string* pname) {
  if (pname != NULL) {
    
  } else {
    
  }
  pname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pname);
  // @@protoc_insertion_point(field_set_allocated:y3d.ProjectInfo.pname)
}

// optional string path = 2;
inline void ProjectInfo::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProjectInfo::path() const {
  // @@protoc_insertion_point(field_get:y3d.ProjectInfo.path)
  return path_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProjectInfo::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.ProjectInfo.path)
}
inline void ProjectInfo::set_path(const char* value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.ProjectInfo.path)
}
inline void ProjectInfo::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.ProjectInfo.path)
}
inline ::std::string* ProjectInfo::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:y3d.ProjectInfo.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProjectInfo::release_path() {
  // @@protoc_insertion_point(field_release:y3d.ProjectInfo.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProjectInfo::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:y3d.ProjectInfo.path)
}

// optional .google.protobuf.Timestamp ts = 3;
inline bool ProjectInfo::has_ts() const {
  return !_is_default_instance_ && ts_ != NULL;
}
inline void ProjectInfo::clear_ts() {
  if (GetArenaNoVirtual() == NULL && ts_ != NULL) delete ts_;
  ts_ = NULL;
}
inline const ::google::protobuf::Timestamp& ProjectInfo::ts() const {
  // @@protoc_insertion_point(field_get:y3d.ProjectInfo.ts)
  return ts_ != NULL ? *ts_ : *default_instance_->ts_;
}
inline ::google::protobuf::Timestamp* ProjectInfo::mutable_ts() {
  
  if (ts_ == NULL) {
    ts_ = new ::google::protobuf::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:y3d.ProjectInfo.ts)
  return ts_;
}
inline ::google::protobuf::Timestamp* ProjectInfo::release_ts() {
  // @@protoc_insertion_point(field_release:y3d.ProjectInfo.ts)
  
  ::google::protobuf::Timestamp* temp = ts_;
  ts_ = NULL;
  return temp;
}
inline void ProjectInfo::set_allocated_ts(::google::protobuf::Timestamp* ts) {
  delete ts_;
  if (ts != NULL && ts->GetArena() != NULL) {
    ::google::protobuf::Timestamp* new_ts = new ::google::protobuf::Timestamp;
    new_ts->CopyFrom(*ts);
    ts = new_ts;
  }
  ts_ = ts;
  if (ts) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.ProjectInfo.ts)
}

// optional .y3d.OptimizeOptions optimize_ops = 5;
inline bool ProjectInfo::has_optimize_ops() const {
  return !_is_default_instance_ && optimize_ops_ != NULL;
}
inline void ProjectInfo::clear_optimize_ops() {
  if (GetArenaNoVirtual() == NULL && optimize_ops_ != NULL) delete optimize_ops_;
  optimize_ops_ = NULL;
}
inline const ::y3d::OptimizeOptions& ProjectInfo::optimize_ops() const {
  // @@protoc_insertion_point(field_get:y3d.ProjectInfo.optimize_ops)
  return optimize_ops_ != NULL ? *optimize_ops_ : *default_instance_->optimize_ops_;
}
inline ::y3d::OptimizeOptions* ProjectInfo::mutable_optimize_ops() {
  
  if (optimize_ops_ == NULL) {
    optimize_ops_ = new ::y3d::OptimizeOptions;
  }
  // @@protoc_insertion_point(field_mutable:y3d.ProjectInfo.optimize_ops)
  return optimize_ops_;
}
inline ::y3d::OptimizeOptions* ProjectInfo::release_optimize_ops() {
  // @@protoc_insertion_point(field_release:y3d.ProjectInfo.optimize_ops)
  
  ::y3d::OptimizeOptions* temp = optimize_ops_;
  optimize_ops_ = NULL;
  return temp;
}
inline void ProjectInfo::set_allocated_optimize_ops(::y3d::OptimizeOptions* optimize_ops) {
  delete optimize_ops_;
  optimize_ops_ = optimize_ops;
  if (optimize_ops) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.ProjectInfo.optimize_ops)
}

// repeated .y3d.FilterView fview = 6;
inline int ProjectInfo::fview_size() const {
  return fview_.size();
}
inline void ProjectInfo::clear_fview() {
  fview_.Clear();
}
inline const ::y3d::FilterView& ProjectInfo::fview(int index) const {
  // @@protoc_insertion_point(field_get:y3d.ProjectInfo.fview)
  return fview_.Get(index);
}
inline ::y3d::FilterView* ProjectInfo::mutable_fview(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.ProjectInfo.fview)
  return fview_.Mutable(index);
}
inline ::y3d::FilterView* ProjectInfo::add_fview() {
  // @@protoc_insertion_point(field_add:y3d.ProjectInfo.fview)
  return fview_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::y3d::FilterView >*
ProjectInfo::mutable_fview() {
  // @@protoc_insertion_point(field_mutable_list:y3d.ProjectInfo.fview)
  return &fview_;
}
inline const ::google::protobuf::RepeatedPtrField< ::y3d::FilterView >&
ProjectInfo::fview() const {
  // @@protoc_insertion_point(field_list:y3d.ProjectInfo.fview)
  return fview_;
}

// optional float optimize_ratio = 7;
inline void ProjectInfo::clear_optimize_ratio() {
  optimize_ratio_ = 0;
}
inline float ProjectInfo::optimize_ratio() const {
  // @@protoc_insertion_point(field_get:y3d.ProjectInfo.optimize_ratio)
  return optimize_ratio_;
}
inline void ProjectInfo::set_optimize_ratio(float value) {
  
  optimize_ratio_ = value;
  // @@protoc_insertion_point(field_set:y3d.ProjectInfo.optimize_ratio)
}

// -------------------------------------------------------------------

// SettingData

// optional string aset_name = 1;
inline void SettingData::clear_aset_name() {
  aset_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SettingData::aset_name() const {
  // @@protoc_insertion_point(field_get:y3d.SettingData.aset_name)
  return aset_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SettingData::set_aset_name(const ::std::string& value) {
  
  aset_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.SettingData.aset_name)
}
inline void SettingData::set_aset_name(const char* value) {
  
  aset_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.SettingData.aset_name)
}
inline void SettingData::set_aset_name(const char* value, size_t size) {
  
  aset_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.SettingData.aset_name)
}
inline ::std::string* SettingData::mutable_aset_name() {
  
  // @@protoc_insertion_point(field_mutable:y3d.SettingData.aset_name)
  return aset_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SettingData::release_aset_name() {
  // @@protoc_insertion_point(field_release:y3d.SettingData.aset_name)
  
  return aset_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SettingData::set_allocated_aset_name(::std::string* aset_name) {
  if (aset_name != NULL) {
    
  } else {
    
  }
  aset_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), aset_name);
  // @@protoc_insertion_point(field_set_allocated:y3d.SettingData.aset_name)
}

// map<string, .google.protobuf.Any> data = 2;
inline int SettingData::data_size() const {
  return data_.size();
}
inline void SettingData::clear_data() {
  data_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::google::protobuf::Any >&
SettingData::data() const {
  // @@protoc_insertion_point(field_map:y3d.SettingData.data)
  return data_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::google::protobuf::Any >*
SettingData::mutable_data() {
  // @@protoc_insertion_point(field_mutable_map:y3d.SettingData.data)
  return data_.MutableMap();
}

// -------------------------------------------------------------------

// PSetting

// optional .y3d.SettingData extra = 1;
inline bool PSetting::has_extra() const {
  return !_is_default_instance_ && extra_ != NULL;
}
inline void PSetting::clear_extra() {
  if (GetArenaNoVirtual() == NULL && extra_ != NULL) delete extra_;
  extra_ = NULL;
}
inline const ::y3d::SettingData& PSetting::extra() const {
  // @@protoc_insertion_point(field_get:y3d.PSetting.extra)
  return extra_ != NULL ? *extra_ : *default_instance_->extra_;
}
inline ::y3d::SettingData* PSetting::mutable_extra() {
  
  if (extra_ == NULL) {
    extra_ = new ::y3d::SettingData;
  }
  // @@protoc_insertion_point(field_mutable:y3d.PSetting.extra)
  return extra_;
}
inline ::y3d::SettingData* PSetting::release_extra() {
  // @@protoc_insertion_point(field_release:y3d.PSetting.extra)
  
  ::y3d::SettingData* temp = extra_;
  extra_ = NULL;
  return temp;
}
inline void PSetting::set_allocated_extra(::y3d::SettingData* extra) {
  delete extra_;
  extra_ = extra;
  if (extra) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.PSetting.extra)
}

// optional int32 max_recent = 2;
inline void PSetting::clear_max_recent() {
  max_recent_ = 0;
}
inline ::google::protobuf::int32 PSetting::max_recent() const {
  // @@protoc_insertion_point(field_get:y3d.PSetting.max_recent)
  return max_recent_;
}
inline void PSetting::set_max_recent(::google::protobuf::int32 value) {
  
  max_recent_ = value;
  // @@protoc_insertion_point(field_set:y3d.PSetting.max_recent)
}

// -------------------------------------------------------------------

// YSystem

// optional string working_folder = 1;
inline void YSystem::clear_working_folder() {
  working_folder_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& YSystem::working_folder() const {
  // @@protoc_insertion_point(field_get:y3d.YSystem.working_folder)
  return working_folder_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YSystem::set_working_folder(const ::std::string& value) {
  
  working_folder_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.YSystem.working_folder)
}
inline void YSystem::set_working_folder(const char* value) {
  
  working_folder_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.YSystem.working_folder)
}
inline void YSystem::set_working_folder(const char* value, size_t size) {
  
  working_folder_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.YSystem.working_folder)
}
inline ::std::string* YSystem::mutable_working_folder() {
  
  // @@protoc_insertion_point(field_mutable:y3d.YSystem.working_folder)
  return working_folder_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YSystem::release_working_folder() {
  // @@protoc_insertion_point(field_release:y3d.YSystem.working_folder)
  
  return working_folder_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YSystem::set_allocated_working_folder(::std::string* working_folder) {
  if (working_folder != NULL) {
    
  } else {
    
  }
  working_folder_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), working_folder);
  // @@protoc_insertion_point(field_set_allocated:y3d.YSystem.working_folder)
}

// optional .y3d.ProjectInfo default_info = 2;
inline bool YSystem::has_default_info() const {
  return !_is_default_instance_ && default_info_ != NULL;
}
inline void YSystem::clear_default_info() {
  if (GetArenaNoVirtual() == NULL && default_info_ != NULL) delete default_info_;
  default_info_ = NULL;
}
inline const ::y3d::ProjectInfo& YSystem::default_info() const {
  // @@protoc_insertion_point(field_get:y3d.YSystem.default_info)
  return default_info_ != NULL ? *default_info_ : *default_instance_->default_info_;
}
inline ::y3d::ProjectInfo* YSystem::mutable_default_info() {
  
  if (default_info_ == NULL) {
    default_info_ = new ::y3d::ProjectInfo;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YSystem.default_info)
  return default_info_;
}
inline ::y3d::ProjectInfo* YSystem::release_default_info() {
  // @@protoc_insertion_point(field_release:y3d.YSystem.default_info)
  
  ::y3d::ProjectInfo* temp = default_info_;
  default_info_ = NULL;
  return temp;
}
inline void YSystem::set_allocated_default_info(::y3d::ProjectInfo* default_info) {
  delete default_info_;
  default_info_ = default_info;
  if (default_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YSystem.default_info)
}

// optional .y3d.PSetting default_setting = 3;
inline bool YSystem::has_default_setting() const {
  return !_is_default_instance_ && default_setting_ != NULL;
}
inline void YSystem::clear_default_setting() {
  if (GetArenaNoVirtual() == NULL && default_setting_ != NULL) delete default_setting_;
  default_setting_ = NULL;
}
inline const ::y3d::PSetting& YSystem::default_setting() const {
  // @@protoc_insertion_point(field_get:y3d.YSystem.default_setting)
  return default_setting_ != NULL ? *default_setting_ : *default_instance_->default_setting_;
}
inline ::y3d::PSetting* YSystem::mutable_default_setting() {
  
  if (default_setting_ == NULL) {
    default_setting_ = new ::y3d::PSetting;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YSystem.default_setting)
  return default_setting_;
}
inline ::y3d::PSetting* YSystem::release_default_setting() {
  // @@protoc_insertion_point(field_release:y3d.YSystem.default_setting)
  
  ::y3d::PSetting* temp = default_setting_;
  default_setting_ = NULL;
  return temp;
}
inline void YSystem::set_allocated_default_setting(::y3d::PSetting* default_setting) {
  delete default_setting_;
  default_setting_ = default_setting;
  if (default_setting) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YSystem.default_setting)
}

// repeated .y3d.ProjectInfo projects = 4;
inline int YSystem::projects_size() const {
  return projects_.size();
}
inline void YSystem::clear_projects() {
  projects_.Clear();
}
inline const ::y3d::ProjectInfo& YSystem::projects(int index) const {
  // @@protoc_insertion_point(field_get:y3d.YSystem.projects)
  return projects_.Get(index);
}
inline ::y3d::ProjectInfo* YSystem::mutable_projects(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.YSystem.projects)
  return projects_.Mutable(index);
}
inline ::y3d::ProjectInfo* YSystem::add_projects() {
  // @@protoc_insertion_point(field_add:y3d.YSystem.projects)
  return projects_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::y3d::ProjectInfo >*
YSystem::mutable_projects() {
  // @@protoc_insertion_point(field_mutable_list:y3d.YSystem.projects)
  return &projects_;
}
inline const ::google::protobuf::RepeatedPtrField< ::y3d::ProjectInfo >&
YSystem::projects() const {
  // @@protoc_insertion_point(field_list:y3d.YSystem.projects)
  return projects_;
}

// -------------------------------------------------------------------

// FRangeItem

// optional int32 f_start = 1;
inline void FRangeItem::clear_f_start() {
  f_start_ = 0;
}
inline ::google::protobuf::int32 FRangeItem::f_start() const {
  // @@protoc_insertion_point(field_get:y3d.FRangeItem.f_start)
  return f_start_;
}
inline void FRangeItem::set_f_start(::google::protobuf::int32 value) {
  
  f_start_ = value;
  // @@protoc_insertion_point(field_set:y3d.FRangeItem.f_start)
}

// optional int32 f_end = 2;
inline void FRangeItem::clear_f_end() {
  f_end_ = 0;
}
inline ::google::protobuf::int32 FRangeItem::f_end() const {
  // @@protoc_insertion_point(field_get:y3d.FRangeItem.f_end)
  return f_end_;
}
inline void FRangeItem::set_f_end(::google::protobuf::int32 value) {
  
  f_end_ = value;
  // @@protoc_insertion_point(field_set:y3d.FRangeItem.f_end)
}

// optional .y3d.YColor fr_color = 3;
inline bool FRangeItem::has_fr_color() const {
  return !_is_default_instance_ && fr_color_ != NULL;
}
inline void FRangeItem::clear_fr_color() {
  if (GetArenaNoVirtual() == NULL && fr_color_ != NULL) delete fr_color_;
  fr_color_ = NULL;
}
inline const ::y3d::YColor& FRangeItem::fr_color() const {
  // @@protoc_insertion_point(field_get:y3d.FRangeItem.fr_color)
  return fr_color_ != NULL ? *fr_color_ : *default_instance_->fr_color_;
}
inline ::y3d::YColor* FRangeItem::mutable_fr_color() {
  
  if (fr_color_ == NULL) {
    fr_color_ = new ::y3d::YColor;
  }
  // @@protoc_insertion_point(field_mutable:y3d.FRangeItem.fr_color)
  return fr_color_;
}
inline ::y3d::YColor* FRangeItem::release_fr_color() {
  // @@protoc_insertion_point(field_release:y3d.FRangeItem.fr_color)
  
  ::y3d::YColor* temp = fr_color_;
  fr_color_ = NULL;
  return temp;
}
inline void FRangeItem::set_allocated_fr_color(::y3d::YColor* fr_color) {
  delete fr_color_;
  fr_color_ = fr_color;
  if (fr_color) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.FRangeItem.fr_color)
}

// optional float ratio = 4;
inline void FRangeItem::clear_ratio() {
  ratio_ = 0;
}
inline float FRangeItem::ratio() const {
  // @@protoc_insertion_point(field_get:y3d.FRangeItem.ratio)
  return ratio_;
}
inline void FRangeItem::set_ratio(float value) {
  
  ratio_ = value;
  // @@protoc_insertion_point(field_set:y3d.FRangeItem.ratio)
}

// optional bool has_xref = 5;
inline void FRangeItem::clear_has_xref() {
  has_xref_ = false;
}
inline bool FRangeItem::has_xref() const {
  // @@protoc_insertion_point(field_get:y3d.FRangeItem.has_xref)
  return has_xref_;
}
inline void FRangeItem::set_has_xref(bool value) {
  
  has_xref_ = value;
  // @@protoc_insertion_point(field_set:y3d.FRangeItem.has_xref)
}

// -------------------------------------------------------------------

// OptimizeOptions

// optional bool use_range = 1;
inline void OptimizeOptions::clear_use_range() {
  use_range_ = false;
}
inline bool OptimizeOptions::use_range() const {
  // @@protoc_insertion_point(field_get:y3d.OptimizeOptions.use_range)
  return use_range_;
}
inline void OptimizeOptions::set_use_range(bool value) {
  
  use_range_ = value;
  // @@protoc_insertion_point(field_set:y3d.OptimizeOptions.use_range)
}

// repeated .y3d.FRangeItem fr = 2;
inline int OptimizeOptions::fr_size() const {
  return fr_.size();
}
inline void OptimizeOptions::clear_fr() {
  fr_.Clear();
}
inline const ::y3d::FRangeItem& OptimizeOptions::fr(int index) const {
  // @@protoc_insertion_point(field_get:y3d.OptimizeOptions.fr)
  return fr_.Get(index);
}
inline ::y3d::FRangeItem* OptimizeOptions::mutable_fr(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.OptimizeOptions.fr)
  return fr_.Mutable(index);
}
inline ::y3d::FRangeItem* OptimizeOptions::add_fr() {
  // @@protoc_insertion_point(field_add:y3d.OptimizeOptions.fr)
  return fr_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::y3d::FRangeItem >*
OptimizeOptions::mutable_fr() {
  // @@protoc_insertion_point(field_mutable_list:y3d.OptimizeOptions.fr)
  return &fr_;
}
inline const ::google::protobuf::RepeatedPtrField< ::y3d::FRangeItem >&
OptimizeOptions::fr() const {
  // @@protoc_insertion_point(field_list:y3d.OptimizeOptions.fr)
  return fr_;
}

// optional int32 min_hpoly = 3;
inline void OptimizeOptions::clear_min_hpoly() {
  min_hpoly_ = 0;
}
inline ::google::protobuf::int32 OptimizeOptions::min_hpoly() const {
  // @@protoc_insertion_point(field_get:y3d.OptimizeOptions.min_hpoly)
  return min_hpoly_;
}
inline void OptimizeOptions::set_min_hpoly(::google::protobuf::int32 value) {
  
  min_hpoly_ = value;
  // @@protoc_insertion_point(field_set:y3d.OptimizeOptions.min_hpoly)
}

// optional int32 out_range_count = 4;
inline void OptimizeOptions::clear_out_range_count() {
  out_range_count_ = 0;
}
inline ::google::protobuf::int32 OptimizeOptions::out_range_count() const {
  // @@protoc_insertion_point(field_get:y3d.OptimizeOptions.out_range_count)
  return out_range_count_;
}
inline void OptimizeOptions::set_out_range_count(::google::protobuf::int32 value) {
  
  out_range_count_ = value;
  // @@protoc_insertion_point(field_set:y3d.OptimizeOptions.out_range_count)
}

// -------------------------------------------------------------------

// ResultReply

// optional bool error = 1;
inline void ResultReply::clear_error() {
  error_ = false;
}
inline bool ResultReply::error() const {
  // @@protoc_insertion_point(field_get:y3d.ResultReply.error)
  return error_;
}
inline void ResultReply::set_error(bool value) {
  
  error_ = value;
  // @@protoc_insertion_point(field_set:y3d.ResultReply.error)
}

// optional string message = 2;
inline void ResultReply::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResultReply::message() const {
  // @@protoc_insertion_point(field_get:y3d.ResultReply.message)
  return message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResultReply::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.ResultReply.message)
}
inline void ResultReply::set_message(const char* value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.ResultReply.message)
}
inline void ResultReply::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.ResultReply.message)
}
inline ::std::string* ResultReply::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:y3d.ResultReply.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResultReply::release_message() {
  // @@protoc_insertion_point(field_release:y3d.ResultReply.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResultReply::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:y3d.ResultReply.message)
}

// -------------------------------------------------------------------

// EmptyParam

// -------------------------------------------------------------------

// RenameParam

// optional bool use_select = 1;
inline void RenameParam::clear_use_select() {
  use_select_ = false;
}
inline bool RenameParam::use_select() const {
  // @@protoc_insertion_point(field_get:y3d.RenameParam.use_select)
  return use_select_;
}
inline void RenameParam::set_use_select(bool value) {
  
  use_select_ = value;
  // @@protoc_insertion_point(field_set:y3d.RenameParam.use_select)
}

// -------------------------------------------------------------------

// Make4TestParam

// optional string oname = 1;
inline void Make4TestParam::clear_oname() {
  oname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Make4TestParam::oname() const {
  // @@protoc_insertion_point(field_get:y3d.Make4TestParam.oname)
  return oname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Make4TestParam::set_oname(const ::std::string& value) {
  
  oname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.Make4TestParam.oname)
}
inline void Make4TestParam::set_oname(const char* value) {
  
  oname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.Make4TestParam.oname)
}
inline void Make4TestParam::set_oname(const char* value, size_t size) {
  
  oname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.Make4TestParam.oname)
}
inline ::std::string* Make4TestParam::mutable_oname() {
  
  // @@protoc_insertion_point(field_mutable:y3d.Make4TestParam.oname)
  return oname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Make4TestParam::release_oname() {
  // @@protoc_insertion_point(field_release:y3d.Make4TestParam.oname)
  
  return oname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Make4TestParam::set_allocated_oname(::std::string* oname) {
  if (oname != NULL) {
    
  } else {
    
  }
  oname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), oname);
  // @@protoc_insertion_point(field_set_allocated:y3d.Make4TestParam.oname)
}

// repeated .y3d.ELowpoly lowpoly = 2;
inline int Make4TestParam::lowpoly_size() const {
  return lowpoly_.size();
}
inline void Make4TestParam::clear_lowpoly() {
  lowpoly_.Clear();
}
inline const ::y3d::ELowpoly& Make4TestParam::lowpoly(int index) const {
  // @@protoc_insertion_point(field_get:y3d.Make4TestParam.lowpoly)
  return lowpoly_.Get(index);
}
inline ::y3d::ELowpoly* Make4TestParam::mutable_lowpoly(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.Make4TestParam.lowpoly)
  return lowpoly_.Mutable(index);
}
inline ::y3d::ELowpoly* Make4TestParam::add_lowpoly() {
  // @@protoc_insertion_point(field_add:y3d.Make4TestParam.lowpoly)
  return lowpoly_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::y3d::ELowpoly >*
Make4TestParam::mutable_lowpoly() {
  // @@protoc_insertion_point(field_mutable_list:y3d.Make4TestParam.lowpoly)
  return &lowpoly_;
}
inline const ::google::protobuf::RepeatedPtrField< ::y3d::ELowpoly >&
Make4TestParam::lowpoly() const {
  // @@protoc_insertion_point(field_list:y3d.Make4TestParam.lowpoly)
  return lowpoly_;
}

// -------------------------------------------------------------------

// OptimizeParam

// optional float ratio = 1;
inline void OptimizeParam::clear_ratio() {
  ratio_ = 0;
}
inline float OptimizeParam::ratio() const {
  // @@protoc_insertion_point(field_get:y3d.OptimizeParam.ratio)
  return ratio_;
}
inline void OptimizeParam::set_ratio(float value) {
  
  ratio_ = value;
  // @@protoc_insertion_point(field_set:y3d.OptimizeParam.ratio)
}

// -------------------------------------------------------------------

// BatchOptimizeParam

// optional float ratio = 1;
inline void BatchOptimizeParam::clear_ratio() {
  ratio_ = 0;
}
inline float BatchOptimizeParam::ratio() const {
  // @@protoc_insertion_point(field_get:y3d.BatchOptimizeParam.ratio)
  return ratio_;
}
inline void BatchOptimizeParam::set_ratio(float value) {
  
  ratio_ = value;
  // @@protoc_insertion_point(field_set:y3d.BatchOptimizeParam.ratio)
}

// optional string folder = 2;
inline void BatchOptimizeParam::clear_folder() {
  folder_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BatchOptimizeParam::folder() const {
  // @@protoc_insertion_point(field_get:y3d.BatchOptimizeParam.folder)
  return folder_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BatchOptimizeParam::set_folder(const ::std::string& value) {
  
  folder_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.BatchOptimizeParam.folder)
}
inline void BatchOptimizeParam::set_folder(const char* value) {
  
  folder_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.BatchOptimizeParam.folder)
}
inline void BatchOptimizeParam::set_folder(const char* value, size_t size) {
  
  folder_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.BatchOptimizeParam.folder)
}
inline ::std::string* BatchOptimizeParam::mutable_folder() {
  
  // @@protoc_insertion_point(field_mutable:y3d.BatchOptimizeParam.folder)
  return folder_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BatchOptimizeParam::release_folder() {
  // @@protoc_insertion_point(field_release:y3d.BatchOptimizeParam.folder)
  
  return folder_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BatchOptimizeParam::set_allocated_folder(::std::string* folder) {
  if (folder != NULL) {
    
  } else {
    
  }
  folder_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), folder);
  // @@protoc_insertion_point(field_set_allocated:y3d.BatchOptimizeParam.folder)
}

// optional string filename = 3;
inline void BatchOptimizeParam::clear_filename() {
  filename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BatchOptimizeParam::filename() const {
  // @@protoc_insertion_point(field_get:y3d.BatchOptimizeParam.filename)
  return filename_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BatchOptimizeParam::set_filename(const ::std::string& value) {
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.BatchOptimizeParam.filename)
}
inline void BatchOptimizeParam::set_filename(const char* value) {
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.BatchOptimizeParam.filename)
}
inline void BatchOptimizeParam::set_filename(const char* value, size_t size) {
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.BatchOptimizeParam.filename)
}
inline ::std::string* BatchOptimizeParam::mutable_filename() {
  
  // @@protoc_insertion_point(field_mutable:y3d.BatchOptimizeParam.filename)
  return filename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BatchOptimizeParam::release_filename() {
  // @@protoc_insertion_point(field_release:y3d.BatchOptimizeParam.filename)
  
  return filename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BatchOptimizeParam::set_allocated_filename(::std::string* filename) {
  if (filename != NULL) {
    
  } else {
    
  }
  filename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:y3d.BatchOptimizeParam.filename)
}

// -------------------------------------------------------------------

// StringParam

// optional string str = 1;
inline void StringParam::clear_str() {
  str_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StringParam::str() const {
  // @@protoc_insertion_point(field_get:y3d.StringParam.str)
  return str_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StringParam::set_str(const ::std::string& value) {
  
  str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.StringParam.str)
}
inline void StringParam::set_str(const char* value) {
  
  str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.StringParam.str)
}
inline void StringParam::set_str(const char* value, size_t size) {
  
  str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.StringParam.str)
}
inline ::std::string* StringParam::mutable_str() {
  
  // @@protoc_insertion_point(field_mutable:y3d.StringParam.str)
  return str_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StringParam::release_str() {
  // @@protoc_insertion_point(field_release:y3d.StringParam.str)
  
  return str_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StringParam::set_allocated_str(::std::string* str) {
  if (str != NULL) {
    
  } else {
    
  }
  str_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), str);
  // @@protoc_insertion_point(field_set_allocated:y3d.StringParam.str)
}

// -------------------------------------------------------------------

// TestParam

// optional string test_name = 1;
inline void TestParam::clear_test_name() {
  test_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TestParam::test_name() const {
  // @@protoc_insertion_point(field_get:y3d.TestParam.test_name)
  return test_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TestParam::set_test_name(const ::std::string& value) {
  
  test_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.TestParam.test_name)
}
inline void TestParam::set_test_name(const char* value) {
  
  test_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.TestParam.test_name)
}
inline void TestParam::set_test_name(const char* value, size_t size) {
  
  test_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.TestParam.test_name)
}
inline ::std::string* TestParam::mutable_test_name() {
  
  // @@protoc_insertion_point(field_mutable:y3d.TestParam.test_name)
  return test_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TestParam::release_test_name() {
  // @@protoc_insertion_point(field_release:y3d.TestParam.test_name)
  
  return test_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TestParam::set_allocated_test_name(::std::string* test_name) {
  if (test_name != NULL) {
    
  } else {
    
  }
  test_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), test_name);
  // @@protoc_insertion_point(field_set_allocated:y3d.TestParam.test_name)
}

// optional .google.protobuf.Any anything = 2;
inline bool TestParam::has_anything() const {
  return !_is_default_instance_ && anything_ != NULL;
}
inline void TestParam::clear_anything() {
  if (GetArenaNoVirtual() == NULL && anything_ != NULL) delete anything_;
  anything_ = NULL;
}
inline const ::google::protobuf::Any& TestParam::anything() const {
  // @@protoc_insertion_point(field_get:y3d.TestParam.anything)
  return anything_ != NULL ? *anything_ : *default_instance_->anything_;
}
inline ::google::protobuf::Any* TestParam::mutable_anything() {
  
  if (anything_ == NULL) {
    anything_ = new ::google::protobuf::Any;
  }
  // @@protoc_insertion_point(field_mutable:y3d.TestParam.anything)
  return anything_;
}
inline ::google::protobuf::Any* TestParam::release_anything() {
  // @@protoc_insertion_point(field_release:y3d.TestParam.anything)
  
  ::google::protobuf::Any* temp = anything_;
  anything_ = NULL;
  return temp;
}
inline void TestParam::set_allocated_anything(::google::protobuf::Any* anything) {
  delete anything_;
  anything_ = anything;
  if (anything) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.TestParam.anything)
}

// -------------------------------------------------------------------

// NewProjectParam

// optional string fname = 1;
inline void NewProjectParam::clear_fname() {
  fname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NewProjectParam::fname() const {
  // @@protoc_insertion_point(field_get:y3d.NewProjectParam.fname)
  return fname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewProjectParam::set_fname(const ::std::string& value) {
  
  fname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.NewProjectParam.fname)
}
inline void NewProjectParam::set_fname(const char* value) {
  
  fname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.NewProjectParam.fname)
}
inline void NewProjectParam::set_fname(const char* value, size_t size) {
  
  fname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.NewProjectParam.fname)
}
inline ::std::string* NewProjectParam::mutable_fname() {
  
  // @@protoc_insertion_point(field_mutable:y3d.NewProjectParam.fname)
  return fname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewProjectParam::release_fname() {
  // @@protoc_insertion_point(field_release:y3d.NewProjectParam.fname)
  
  return fname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewProjectParam::set_allocated_fname(::std::string* fname) {
  if (fname != NULL) {
    
  } else {
    
  }
  fname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fname);
  // @@protoc_insertion_point(field_set_allocated:y3d.NewProjectParam.fname)
}

// optional string folder = 2;
inline void NewProjectParam::clear_folder() {
  folder_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NewProjectParam::folder() const {
  // @@protoc_insertion_point(field_get:y3d.NewProjectParam.folder)
  return folder_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewProjectParam::set_folder(const ::std::string& value) {
  
  folder_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.NewProjectParam.folder)
}
inline void NewProjectParam::set_folder(const char* value) {
  
  folder_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.NewProjectParam.folder)
}
inline void NewProjectParam::set_folder(const char* value, size_t size) {
  
  folder_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.NewProjectParam.folder)
}
inline ::std::string* NewProjectParam::mutable_folder() {
  
  // @@protoc_insertion_point(field_mutable:y3d.NewProjectParam.folder)
  return folder_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewProjectParam::release_folder() {
  // @@protoc_insertion_point(field_release:y3d.NewProjectParam.folder)
  
  return folder_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewProjectParam::set_allocated_folder(::std::string* folder) {
  if (folder != NULL) {
    
  } else {
    
  }
  folder_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), folder);
  // @@protoc_insertion_point(field_set_allocated:y3d.NewProjectParam.folder)
}

// -------------------------------------------------------------------

// ResponseNProject

// optional .y3d.ProjectInfo pInfo = 1;
inline bool ResponseNProject::has_pinfo() const {
  return !_is_default_instance_ && pinfo_ != NULL;
}
inline void ResponseNProject::clear_pinfo() {
  if (GetArenaNoVirtual() == NULL && pinfo_ != NULL) delete pinfo_;
  pinfo_ = NULL;
}
inline const ::y3d::ProjectInfo& ResponseNProject::pinfo() const {
  // @@protoc_insertion_point(field_get:y3d.ResponseNProject.pInfo)
  return pinfo_ != NULL ? *pinfo_ : *default_instance_->pinfo_;
}
inline ::y3d::ProjectInfo* ResponseNProject::mutable_pinfo() {
  
  if (pinfo_ == NULL) {
    pinfo_ = new ::y3d::ProjectInfo;
  }
  // @@protoc_insertion_point(field_mutable:y3d.ResponseNProject.pInfo)
  return pinfo_;
}
inline ::y3d::ProjectInfo* ResponseNProject::release_pinfo() {
  // @@protoc_insertion_point(field_release:y3d.ResponseNProject.pInfo)
  
  ::y3d::ProjectInfo* temp = pinfo_;
  pinfo_ = NULL;
  return temp;
}
inline void ResponseNProject::set_allocated_pinfo(::y3d::ProjectInfo* pinfo) {
  delete pinfo_;
  pinfo_ = pinfo;
  if (pinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.ResponseNProject.pInfo)
}

// optional .y3d.YAreaList yal = 2;
inline bool ResponseNProject::has_yal() const {
  return !_is_default_instance_ && yal_ != NULL;
}
inline void ResponseNProject::clear_yal() {
  if (GetArenaNoVirtual() == NULL && yal_ != NULL) delete yal_;
  yal_ = NULL;
}
inline const ::y3d::YAreaList& ResponseNProject::yal() const {
  // @@protoc_insertion_point(field_get:y3d.ResponseNProject.yal)
  return yal_ != NULL ? *yal_ : *default_instance_->yal_;
}
inline ::y3d::YAreaList* ResponseNProject::mutable_yal() {
  
  if (yal_ == NULL) {
    yal_ = new ::y3d::YAreaList;
  }
  // @@protoc_insertion_point(field_mutable:y3d.ResponseNProject.yal)
  return yal_;
}
inline ::y3d::YAreaList* ResponseNProject::release_yal() {
  // @@protoc_insertion_point(field_release:y3d.ResponseNProject.yal)
  
  ::y3d::YAreaList* temp = yal_;
  yal_ = NULL;
  return temp;
}
inline void ResponseNProject::set_allocated_yal(::y3d::YAreaList* yal) {
  delete yal_;
  yal_ = yal;
  if (yal) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.ResponseNProject.yal)
}

// optional .y3d.YSystem sys = 3;
inline bool ResponseNProject::has_sys() const {
  return !_is_default_instance_ && sys_ != NULL;
}
inline void ResponseNProject::clear_sys() {
  if (GetArenaNoVirtual() == NULL && sys_ != NULL) delete sys_;
  sys_ = NULL;
}
inline const ::y3d::YSystem& ResponseNProject::sys() const {
  // @@protoc_insertion_point(field_get:y3d.ResponseNProject.sys)
  return sys_ != NULL ? *sys_ : *default_instance_->sys_;
}
inline ::y3d::YSystem* ResponseNProject::mutable_sys() {
  
  if (sys_ == NULL) {
    sys_ = new ::y3d::YSystem;
  }
  // @@protoc_insertion_point(field_mutable:y3d.ResponseNProject.sys)
  return sys_;
}
inline ::y3d::YSystem* ResponseNProject::release_sys() {
  // @@protoc_insertion_point(field_release:y3d.ResponseNProject.sys)
  
  ::y3d::YSystem* temp = sys_;
  sys_ = NULL;
  return temp;
}
inline void ResponseNProject::set_allocated_sys(::y3d::YSystem* sys) {
  delete sys_;
  sys_ = sys;
  if (sys) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.ResponseNProject.sys)
}

// optional string err = 4;
inline void ResponseNProject::clear_err() {
  err_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseNProject::err() const {
  // @@protoc_insertion_point(field_get:y3d.ResponseNProject.err)
  return err_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseNProject::set_err(const ::std::string& value) {
  
  err_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.ResponseNProject.err)
}
inline void ResponseNProject::set_err(const char* value) {
  
  err_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.ResponseNProject.err)
}
inline void ResponseNProject::set_err(const char* value, size_t size) {
  
  err_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.ResponseNProject.err)
}
inline ::std::string* ResponseNProject::mutable_err() {
  
  // @@protoc_insertion_point(field_mutable:y3d.ResponseNProject.err)
  return err_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseNProject::release_err() {
  // @@protoc_insertion_point(field_release:y3d.ResponseNProject.err)
  
  return err_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseNProject::set_allocated_err(::std::string* err) {
  if (err != NULL) {
    
  } else {
    
  }
  err_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), err);
  // @@protoc_insertion_point(field_set_allocated:y3d.ResponseNProject.err)
}

// -------------------------------------------------------------------

// YEvent

// optional .y3d.ENone noevent = 1;
inline bool YEvent::has_noevent() const {
  return event_case() == kNoevent;
}
inline void YEvent::set_has_noevent() {
  _oneof_case_[0] = kNoevent;
}
inline void YEvent::clear_noevent() {
  if (has_noevent()) {
    delete event_.noevent_;
    clear_has_event();
  }
}
inline  const ::y3d::ENone& YEvent::noevent() const {
  // @@protoc_insertion_point(field_get:y3d.YEvent.noevent)
  return has_noevent()
      ? *event_.noevent_
      : ::y3d::ENone::default_instance();
}
inline ::y3d::ENone* YEvent::mutable_noevent() {
  if (!has_noevent()) {
    clear_event();
    set_has_noevent();
    event_.noevent_ = new ::y3d::ENone;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YEvent.noevent)
  return event_.noevent_;
}
inline ::y3d::ENone* YEvent::release_noevent() {
  // @@protoc_insertion_point(field_release:y3d.YEvent.noevent)
  if (has_noevent()) {
    clear_has_event();
    ::y3d::ENone* temp = event_.noevent_;
    event_.noevent_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void YEvent::set_allocated_noevent(::y3d::ENone* noevent) {
  clear_event();
  if (noevent) {
    set_has_noevent();
    event_.noevent_ = noevent;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YEvent.noevent)
}

// optional .y3d.ESelect select = 2;
inline bool YEvent::has_select() const {
  return event_case() == kSelect;
}
inline void YEvent::set_has_select() {
  _oneof_case_[0] = kSelect;
}
inline void YEvent::clear_select() {
  if (has_select()) {
    delete event_.select_;
    clear_has_event();
  }
}
inline  const ::y3d::ESelect& YEvent::select() const {
  // @@protoc_insertion_point(field_get:y3d.YEvent.select)
  return has_select()
      ? *event_.select_
      : ::y3d::ESelect::default_instance();
}
inline ::y3d::ESelect* YEvent::mutable_select() {
  if (!has_select()) {
    clear_event();
    set_has_select();
    event_.select_ = new ::y3d::ESelect;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YEvent.select)
  return event_.select_;
}
inline ::y3d::ESelect* YEvent::release_select() {
  // @@protoc_insertion_point(field_release:y3d.YEvent.select)
  if (has_select()) {
    clear_has_event();
    ::y3d::ESelect* temp = event_.select_;
    event_.select_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void YEvent::set_allocated_select(::y3d::ESelect* select) {
  clear_event();
  if (select) {
    set_has_select();
    event_.select_ = select;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YEvent.select)
}

// optional .y3d.EMove move = 3;
inline bool YEvent::has_move() const {
  return event_case() == kMove;
}
inline void YEvent::set_has_move() {
  _oneof_case_[0] = kMove;
}
inline void YEvent::clear_move() {
  if (has_move()) {
    delete event_.move_;
    clear_has_event();
  }
}
inline  const ::y3d::EMove& YEvent::move() const {
  // @@protoc_insertion_point(field_get:y3d.YEvent.move)
  return has_move()
      ? *event_.move_
      : ::y3d::EMove::default_instance();
}
inline ::y3d::EMove* YEvent::mutable_move() {
  if (!has_move()) {
    clear_event();
    set_has_move();
    event_.move_ = new ::y3d::EMove;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YEvent.move)
  return event_.move_;
}
inline ::y3d::EMove* YEvent::release_move() {
  // @@protoc_insertion_point(field_release:y3d.YEvent.move)
  if (has_move()) {
    clear_has_event();
    ::y3d::EMove* temp = event_.move_;
    event_.move_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void YEvent::set_allocated_move(::y3d::EMove* move) {
  clear_event();
  if (move) {
    set_has_move();
    event_.move_ = move;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YEvent.move)
}

// optional .y3d.ERotate rotate = 4;
inline bool YEvent::has_rotate() const {
  return event_case() == kRotate;
}
inline void YEvent::set_has_rotate() {
  _oneof_case_[0] = kRotate;
}
inline void YEvent::clear_rotate() {
  if (has_rotate()) {
    delete event_.rotate_;
    clear_has_event();
  }
}
inline  const ::y3d::ERotate& YEvent::rotate() const {
  // @@protoc_insertion_point(field_get:y3d.YEvent.rotate)
  return has_rotate()
      ? *event_.rotate_
      : ::y3d::ERotate::default_instance();
}
inline ::y3d::ERotate* YEvent::mutable_rotate() {
  if (!has_rotate()) {
    clear_event();
    set_has_rotate();
    event_.rotate_ = new ::y3d::ERotate;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YEvent.rotate)
  return event_.rotate_;
}
inline ::y3d::ERotate* YEvent::release_rotate() {
  // @@protoc_insertion_point(field_release:y3d.YEvent.rotate)
  if (has_rotate()) {
    clear_has_event();
    ::y3d::ERotate* temp = event_.rotate_;
    event_.rotate_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void YEvent::set_allocated_rotate(::y3d::ERotate* rotate) {
  clear_event();
  if (rotate) {
    set_has_rotate();
    event_.rotate_ = rotate;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YEvent.rotate)
}

// optional .y3d.EDelete del = 5;
inline bool YEvent::has_del() const {
  return event_case() == kDel;
}
inline void YEvent::set_has_del() {
  _oneof_case_[0] = kDel;
}
inline void YEvent::clear_del() {
  if (has_del()) {
    delete event_.del_;
    clear_has_event();
  }
}
inline  const ::y3d::EDelete& YEvent::del() const {
  // @@protoc_insertion_point(field_get:y3d.YEvent.del)
  return has_del()
      ? *event_.del_
      : ::y3d::EDelete::default_instance();
}
inline ::y3d::EDelete* YEvent::mutable_del() {
  if (!has_del()) {
    clear_event();
    set_has_del();
    event_.del_ = new ::y3d::EDelete;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YEvent.del)
  return event_.del_;
}
inline ::y3d::EDelete* YEvent::release_del() {
  // @@protoc_insertion_point(field_release:y3d.YEvent.del)
  if (has_del()) {
    clear_has_event();
    ::y3d::EDelete* temp = event_.del_;
    event_.del_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void YEvent::set_allocated_del(::y3d::EDelete* del) {
  clear_event();
  if (del) {
    set_has_del();
    event_.del_ = del;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YEvent.del)
}

// optional .y3d.ESelectMany select_many = 6;
inline bool YEvent::has_select_many() const {
  return event_case() == kSelectMany;
}
inline void YEvent::set_has_select_many() {
  _oneof_case_[0] = kSelectMany;
}
inline void YEvent::clear_select_many() {
  if (has_select_many()) {
    delete event_.select_many_;
    clear_has_event();
  }
}
inline  const ::y3d::ESelectMany& YEvent::select_many() const {
  // @@protoc_insertion_point(field_get:y3d.YEvent.select_many)
  return has_select_many()
      ? *event_.select_many_
      : ::y3d::ESelectMany::default_instance();
}
inline ::y3d::ESelectMany* YEvent::mutable_select_many() {
  if (!has_select_many()) {
    clear_event();
    set_has_select_many();
    event_.select_many_ = new ::y3d::ESelectMany;
  }
  // @@protoc_insertion_point(field_mutable:y3d.YEvent.select_many)
  return event_.select_many_;
}
inline ::y3d::ESelectMany* YEvent::release_select_many() {
  // @@protoc_insertion_point(field_release:y3d.YEvent.select_many)
  if (has_select_many()) {
    clear_has_event();
    ::y3d::ESelectMany* temp = event_.select_many_;
    event_.select_many_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void YEvent::set_allocated_select_many(::y3d::ESelectMany* select_many) {
  clear_event();
  if (select_many) {
    set_has_select_many();
    event_.select_many_ = select_many;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.YEvent.select_many)
}

inline bool YEvent::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void YEvent::clear_has_event() {
  _oneof_case_[0] = EVENT_NOT_SET;
}
inline YEvent::EventCase YEvent::event_case() const {
  return YEvent::EventCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ENone

// -------------------------------------------------------------------

// ESelect

// optional string name = 1;
inline void ESelect::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ESelect::name() const {
  // @@protoc_insertion_point(field_get:y3d.ESelect.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ESelect::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.ESelect.name)
}
inline void ESelect::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.ESelect.name)
}
inline void ESelect::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.ESelect.name)
}
inline ::std::string* ESelect::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:y3d.ESelect.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ESelect::release_name() {
  // @@protoc_insertion_point(field_release:y3d.ESelect.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ESelect::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:y3d.ESelect.name)
}

// optional bool isolate = 2;
inline void ESelect::clear_isolate() {
  isolate_ = false;
}
inline bool ESelect::isolate() const {
  // @@protoc_insertion_point(field_get:y3d.ESelect.isolate)
  return isolate_;
}
inline void ESelect::set_isolate(bool value) {
  
  isolate_ = value;
  // @@protoc_insertion_point(field_set:y3d.ESelect.isolate)
}

// -------------------------------------------------------------------

// ESelectMany

// repeated string name = 1;
inline int ESelectMany::name_size() const {
  return name_.size();
}
inline void ESelectMany::clear_name() {
  name_.Clear();
}
inline const ::std::string& ESelectMany::name(int index) const {
  // @@protoc_insertion_point(field_get:y3d.ESelectMany.name)
  return name_.Get(index);
}
inline ::std::string* ESelectMany::mutable_name(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.ESelectMany.name)
  return name_.Mutable(index);
}
inline void ESelectMany::set_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:y3d.ESelectMany.name)
  name_.Mutable(index)->assign(value);
}
inline void ESelectMany::set_name(int index, const char* value) {
  name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:y3d.ESelectMany.name)
}
inline void ESelectMany::set_name(int index, const char* value, size_t size) {
  name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:y3d.ESelectMany.name)
}
inline ::std::string* ESelectMany::add_name() {
  // @@protoc_insertion_point(field_add_mutable:y3d.ESelectMany.name)
  return name_.Add();
}
inline void ESelectMany::add_name(const ::std::string& value) {
  name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:y3d.ESelectMany.name)
}
inline void ESelectMany::add_name(const char* value) {
  name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:y3d.ESelectMany.name)
}
inline void ESelectMany::add_name(const char* value, size_t size) {
  name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:y3d.ESelectMany.name)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ESelectMany::name() const {
  // @@protoc_insertion_point(field_list:y3d.ESelectMany.name)
  return name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ESelectMany::mutable_name() {
  // @@protoc_insertion_point(field_mutable_list:y3d.ESelectMany.name)
  return &name_;
}

// optional bool isolate = 2;
inline void ESelectMany::clear_isolate() {
  isolate_ = false;
}
inline bool ESelectMany::isolate() const {
  // @@protoc_insertion_point(field_get:y3d.ESelectMany.isolate)
  return isolate_;
}
inline void ESelectMany::set_isolate(bool value) {
  
  isolate_ = value;
  // @@protoc_insertion_point(field_set:y3d.ESelectMany.isolate)
}

// -------------------------------------------------------------------

// EMove

// repeated float point = 1;
inline int EMove::point_size() const {
  return point_.size();
}
inline void EMove::clear_point() {
  point_.Clear();
}
inline float EMove::point(int index) const {
  // @@protoc_insertion_point(field_get:y3d.EMove.point)
  return point_.Get(index);
}
inline void EMove::set_point(int index, float value) {
  point_.Set(index, value);
  // @@protoc_insertion_point(field_set:y3d.EMove.point)
}
inline void EMove::add_point(float value) {
  point_.Add(value);
  // @@protoc_insertion_point(field_add:y3d.EMove.point)
}
inline const ::google::protobuf::RepeatedField< float >&
EMove::point() const {
  // @@protoc_insertion_point(field_list:y3d.EMove.point)
  return point_;
}
inline ::google::protobuf::RepeatedField< float >*
EMove::mutable_point() {
  // @@protoc_insertion_point(field_mutable_list:y3d.EMove.point)
  return &point_;
}

// -------------------------------------------------------------------

// ERotate

// repeated float rotate = 1;
inline int ERotate::rotate_size() const {
  return rotate_.size();
}
inline void ERotate::clear_rotate() {
  rotate_.Clear();
}
inline float ERotate::rotate(int index) const {
  // @@protoc_insertion_point(field_get:y3d.ERotate.rotate)
  return rotate_.Get(index);
}
inline void ERotate::set_rotate(int index, float value) {
  rotate_.Set(index, value);
  // @@protoc_insertion_point(field_set:y3d.ERotate.rotate)
}
inline void ERotate::add_rotate(float value) {
  rotate_.Add(value);
  // @@protoc_insertion_point(field_add:y3d.ERotate.rotate)
}
inline const ::google::protobuf::RepeatedField< float >&
ERotate::rotate() const {
  // @@protoc_insertion_point(field_list:y3d.ERotate.rotate)
  return rotate_;
}
inline ::google::protobuf::RepeatedField< float >*
ERotate::mutable_rotate() {
  // @@protoc_insertion_point(field_mutable_list:y3d.ERotate.rotate)
  return &rotate_;
}

// -------------------------------------------------------------------

// EDelete

// optional string name = 1;
inline void EDelete::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EDelete::name() const {
  // @@protoc_insertion_point(field_get:y3d.EDelete.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EDelete::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.EDelete.name)
}
inline void EDelete::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.EDelete.name)
}
inline void EDelete::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.EDelete.name)
}
inline ::std::string* EDelete::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:y3d.EDelete.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EDelete::release_name() {
  // @@protoc_insertion_point(field_release:y3d.EDelete.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EDelete::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:y3d.EDelete.name)
}

// -------------------------------------------------------------------

// EIsolate

// optional string name = 1;
inline void EIsolate::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EIsolate::name() const {
  // @@protoc_insertion_point(field_get:y3d.EIsolate.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EIsolate::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.EIsolate.name)
}
inline void EIsolate::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.EIsolate.name)
}
inline void EIsolate::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.EIsolate.name)
}
inline ::std::string* EIsolate::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:y3d.EIsolate.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EIsolate::release_name() {
  // @@protoc_insertion_point(field_release:y3d.EIsolate.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EIsolate::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:y3d.EIsolate.name)
}

// optional bool endIsolate = 2;
inline void EIsolate::clear_endisolate() {
  endisolate_ = false;
}
inline bool EIsolate::endisolate() const {
  // @@protoc_insertion_point(field_get:y3d.EIsolate.endIsolate)
  return endisolate_;
}
inline void EIsolate::set_endisolate(bool value) {
  
  endisolate_ = value;
  // @@protoc_insertion_point(field_set:y3d.EIsolate.endIsolate)
}

// -------------------------------------------------------------------

// EUnwrap

// optional string oname = 1;
inline void EUnwrap::clear_oname() {
  oname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EUnwrap::oname() const {
  // @@protoc_insertion_point(field_get:y3d.EUnwrap.oname)
  return oname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EUnwrap::set_oname(const ::std::string& value) {
  
  oname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.EUnwrap.oname)
}
inline void EUnwrap::set_oname(const char* value) {
  
  oname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.EUnwrap.oname)
}
inline void EUnwrap::set_oname(const char* value, size_t size) {
  
  oname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.EUnwrap.oname)
}
inline ::std::string* EUnwrap::mutable_oname() {
  
  // @@protoc_insertion_point(field_mutable:y3d.EUnwrap.oname)
  return oname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EUnwrap::release_oname() {
  // @@protoc_insertion_point(field_release:y3d.EUnwrap.oname)
  
  return oname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EUnwrap::set_allocated_oname(::std::string* oname) {
  if (oname != NULL) {
    
  } else {
    
  }
  oname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), oname);
  // @@protoc_insertion_point(field_set_allocated:y3d.EUnwrap.oname)
}

// optional int32 channel = 2;
inline void EUnwrap::clear_channel() {
  channel_ = 0;
}
inline ::google::protobuf::int32 EUnwrap::channel() const {
  // @@protoc_insertion_point(field_get:y3d.EUnwrap.channel)
  return channel_;
}
inline void EUnwrap::set_channel(::google::protobuf::int32 value) {
  
  channel_ = value;
  // @@protoc_insertion_point(field_set:y3d.EUnwrap.channel)
}

// optional .y3d.MaxUnwrap max3d = 3;
inline bool EUnwrap::has_max3d() const {
  return setting_case() == kMax3D;
}
inline void EUnwrap::set_has_max3d() {
  _oneof_case_[0] = kMax3D;
}
inline void EUnwrap::clear_max3d() {
  if (has_max3d()) {
    delete setting_.max3d_;
    clear_has_setting();
  }
}
inline  const ::y3d::MaxUnwrap& EUnwrap::max3d() const {
  // @@protoc_insertion_point(field_get:y3d.EUnwrap.max3d)
  return has_max3d()
      ? *setting_.max3d_
      : ::y3d::MaxUnwrap::default_instance();
}
inline ::y3d::MaxUnwrap* EUnwrap::mutable_max3d() {
  if (!has_max3d()) {
    clear_setting();
    set_has_max3d();
    setting_.max3d_ = new ::y3d::MaxUnwrap;
  }
  // @@protoc_insertion_point(field_mutable:y3d.EUnwrap.max3d)
  return setting_.max3d_;
}
inline ::y3d::MaxUnwrap* EUnwrap::release_max3d() {
  // @@protoc_insertion_point(field_release:y3d.EUnwrap.max3d)
  if (has_max3d()) {
    clear_has_setting();
    ::y3d::MaxUnwrap* temp = setting_.max3d_;
    setting_.max3d_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void EUnwrap::set_allocated_max3d(::y3d::MaxUnwrap* max3d) {
  clear_setting();
  if (max3d) {
    set_has_max3d();
    setting_.max3d_ = max3d;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.EUnwrap.max3d)
}

// optional .y3d.BlenderUnwrap blender = 4;
inline bool EUnwrap::has_blender() const {
  return setting_case() == kBlender;
}
inline void EUnwrap::set_has_blender() {
  _oneof_case_[0] = kBlender;
}
inline void EUnwrap::clear_blender() {
  if (has_blender()) {
    delete setting_.blender_;
    clear_has_setting();
  }
}
inline  const ::y3d::BlenderUnwrap& EUnwrap::blender() const {
  // @@protoc_insertion_point(field_get:y3d.EUnwrap.blender)
  return has_blender()
      ? *setting_.blender_
      : ::y3d::BlenderUnwrap::default_instance();
}
inline ::y3d::BlenderUnwrap* EUnwrap::mutable_blender() {
  if (!has_blender()) {
    clear_setting();
    set_has_blender();
    setting_.blender_ = new ::y3d::BlenderUnwrap;
  }
  // @@protoc_insertion_point(field_mutable:y3d.EUnwrap.blender)
  return setting_.blender_;
}
inline ::y3d::BlenderUnwrap* EUnwrap::release_blender() {
  // @@protoc_insertion_point(field_release:y3d.EUnwrap.blender)
  if (has_blender()) {
    clear_has_setting();
    ::y3d::BlenderUnwrap* temp = setting_.blender_;
    setting_.blender_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void EUnwrap::set_allocated_blender(::y3d::BlenderUnwrap* blender) {
  clear_setting();
  if (blender) {
    set_has_blender();
    setting_.blender_ = blender;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.EUnwrap.blender)
}

inline bool EUnwrap::has_setting() const {
  return setting_case() != SETTING_NOT_SET;
}
inline void EUnwrap::clear_has_setting() {
  _oneof_case_[0] = SETTING_NOT_SET;
}
inline EUnwrap::SettingCase EUnwrap::setting_case() const {
  return EUnwrap::SettingCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// BlenderUnwrap

// -------------------------------------------------------------------

// MaxUnwrap

// optional float angle = 1;
inline void MaxUnwrap::clear_angle() {
  angle_ = 0;
}
inline float MaxUnwrap::angle() const {
  // @@protoc_insertion_point(field_get:y3d.MaxUnwrap.angle)
  return angle_;
}
inline void MaxUnwrap::set_angle(float value) {
  
  angle_ = value;
  // @@protoc_insertion_point(field_set:y3d.MaxUnwrap.angle)
}

// optional float spacing = 2;
inline void MaxUnwrap::clear_spacing() {
  spacing_ = 0;
}
inline float MaxUnwrap::spacing() const {
  // @@protoc_insertion_point(field_get:y3d.MaxUnwrap.spacing)
  return spacing_;
}
inline void MaxUnwrap::set_spacing(float value) {
  
  spacing_ = value;
  // @@protoc_insertion_point(field_set:y3d.MaxUnwrap.spacing)
}

// -------------------------------------------------------------------

// EPacking

// optional string oname = 1;
inline void EPacking::clear_oname() {
  oname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EPacking::oname() const {
  // @@protoc_insertion_point(field_get:y3d.EPacking.oname)
  return oname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EPacking::set_oname(const ::std::string& value) {
  
  oname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.EPacking.oname)
}
inline void EPacking::set_oname(const char* value) {
  
  oname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.EPacking.oname)
}
inline void EPacking::set_oname(const char* value, size_t size) {
  
  oname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.EPacking.oname)
}
inline ::std::string* EPacking::mutable_oname() {
  
  // @@protoc_insertion_point(field_mutable:y3d.EPacking.oname)
  return oname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EPacking::release_oname() {
  // @@protoc_insertion_point(field_release:y3d.EPacking.oname)
  
  return oname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EPacking::set_allocated_oname(::std::string* oname) {
  if (oname != NULL) {
    
  } else {
    
  }
  oname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), oname);
  // @@protoc_insertion_point(field_set_allocated:y3d.EPacking.oname)
}

// optional string uvname = 2;
inline void EPacking::clear_uvname() {
  uvname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EPacking::uvname() const {
  // @@protoc_insertion_point(field_get:y3d.EPacking.uvname)
  return uvname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EPacking::set_uvname(const ::std::string& value) {
  
  uvname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.EPacking.uvname)
}
inline void EPacking::set_uvname(const char* value) {
  
  uvname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.EPacking.uvname)
}
inline void EPacking::set_uvname(const char* value, size_t size) {
  
  uvname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.EPacking.uvname)
}
inline ::std::string* EPacking::mutable_uvname() {
  
  // @@protoc_insertion_point(field_mutable:y3d.EPacking.uvname)
  return uvname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EPacking::release_uvname() {
  // @@protoc_insertion_point(field_release:y3d.EPacking.uvname)
  
  return uvname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EPacking::set_allocated_uvname(::std::string* uvname) {
  if (uvname != NULL) {
    
  } else {
    
  }
  uvname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uvname);
  // @@protoc_insertion_point(field_set_allocated:y3d.EPacking.uvname)
}

// optional int32 tile_Size = 3;
inline void EPacking::clear_tile_size() {
  tile_size_ = 0;
}
inline ::google::protobuf::int32 EPacking::tile_size() const {
  // @@protoc_insertion_point(field_get:y3d.EPacking.tile_Size)
  return tile_size_;
}
inline void EPacking::set_tile_size(::google::protobuf::int32 value) {
  
  tile_size_ = value;
  // @@protoc_insertion_point(field_set:y3d.EPacking.tile_Size)
}

// optional .y3d.Pack3DMax packmax = 4;
inline bool EPacking::has_packmax() const {
  return pack_case() == kPackmax;
}
inline void EPacking::set_has_packmax() {
  _oneof_case_[0] = kPackmax;
}
inline void EPacking::clear_packmax() {
  if (has_packmax()) {
    delete pack_.packmax_;
    clear_has_pack();
  }
}
inline  const ::y3d::Pack3DMax& EPacking::packmax() const {
  // @@protoc_insertion_point(field_get:y3d.EPacking.packmax)
  return has_packmax()
      ? *pack_.packmax_
      : ::y3d::Pack3DMax::default_instance();
}
inline ::y3d::Pack3DMax* EPacking::mutable_packmax() {
  if (!has_packmax()) {
    clear_pack();
    set_has_packmax();
    pack_.packmax_ = new ::y3d::Pack3DMax;
  }
  // @@protoc_insertion_point(field_mutable:y3d.EPacking.packmax)
  return pack_.packmax_;
}
inline ::y3d::Pack3DMax* EPacking::release_packmax() {
  // @@protoc_insertion_point(field_release:y3d.EPacking.packmax)
  if (has_packmax()) {
    clear_has_pack();
    ::y3d::Pack3DMax* temp = pack_.packmax_;
    pack_.packmax_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void EPacking::set_allocated_packmax(::y3d::Pack3DMax* packmax) {
  clear_pack();
  if (packmax) {
    set_has_packmax();
    pack_.packmax_ = packmax;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.EPacking.packmax)
}

// optional .y3d.PackRect packrect = 5;
inline bool EPacking::has_packrect() const {
  return pack_case() == kPackrect;
}
inline void EPacking::set_has_packrect() {
  _oneof_case_[0] = kPackrect;
}
inline void EPacking::clear_packrect() {
  if (has_packrect()) {
    delete pack_.packrect_;
    clear_has_pack();
  }
}
inline  const ::y3d::PackRect& EPacking::packrect() const {
  // @@protoc_insertion_point(field_get:y3d.EPacking.packrect)
  return has_packrect()
      ? *pack_.packrect_
      : ::y3d::PackRect::default_instance();
}
inline ::y3d::PackRect* EPacking::mutable_packrect() {
  if (!has_packrect()) {
    clear_pack();
    set_has_packrect();
    pack_.packrect_ = new ::y3d::PackRect;
  }
  // @@protoc_insertion_point(field_mutable:y3d.EPacking.packrect)
  return pack_.packrect_;
}
inline ::y3d::PackRect* EPacking::release_packrect() {
  // @@protoc_insertion_point(field_release:y3d.EPacking.packrect)
  if (has_packrect()) {
    clear_has_pack();
    ::y3d::PackRect* temp = pack_.packrect_;
    pack_.packrect_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void EPacking::set_allocated_packrect(::y3d::PackRect* packrect) {
  clear_pack();
  if (packrect) {
    set_has_packrect();
    pack_.packrect_ = packrect;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.EPacking.packrect)
}

inline bool EPacking::has_pack() const {
  return pack_case() != PACK_NOT_SET;
}
inline void EPacking::clear_has_pack() {
  _oneof_case_[0] = PACK_NOT_SET;
}
inline EPacking::PackCase EPacking::pack_case() const {
  return EPacking::PackCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PackRect

// optional int32 density = 1;
inline void PackRect::clear_density() {
  density_ = 0;
}
inline ::google::protobuf::int32 PackRect::density() const {
  // @@protoc_insertion_point(field_get:y3d.PackRect.density)
  return density_;
}
inline void PackRect::set_density(::google::protobuf::int32 value) {
  
  density_ = value;
  // @@protoc_insertion_point(field_set:y3d.PackRect.density)
}

// optional float padding = 2;
inline void PackRect::clear_padding() {
  padding_ = 0;
}
inline float PackRect::padding() const {
  // @@protoc_insertion_point(field_get:y3d.PackRect.padding)
  return padding_;
}
inline void PackRect::set_padding(float value) {
  
  padding_ = value;
  // @@protoc_insertion_point(field_set:y3d.PackRect.padding)
}

// -------------------------------------------------------------------

// Pack3DMax

// optional int32 numTile = 1;
inline void Pack3DMax::clear_numtile() {
  numtile_ = 0;
}
inline ::google::protobuf::int32 Pack3DMax::numtile() const {
  // @@protoc_insertion_point(field_get:y3d.Pack3DMax.numTile)
  return numtile_;
}
inline void Pack3DMax::set_numtile(::google::protobuf::int32 value) {
  
  numtile_ = value;
  // @@protoc_insertion_point(field_set:y3d.Pack3DMax.numTile)
}

// optional bool normalize = 2;
inline void Pack3DMax::clear_normalize() {
  normalize_ = false;
}
inline bool Pack3DMax::normalize() const {
  // @@protoc_insertion_point(field_get:y3d.Pack3DMax.normalize)
  return normalize_;
}
inline void Pack3DMax::set_normalize(bool value) {
  
  normalize_ = value;
  // @@protoc_insertion_point(field_set:y3d.Pack3DMax.normalize)
}

// optional bool rotate_clusters = 3;
inline void Pack3DMax::clear_rotate_clusters() {
  rotate_clusters_ = false;
}
inline bool Pack3DMax::rotate_clusters() const {
  // @@protoc_insertion_point(field_get:y3d.Pack3DMax.rotate_clusters)
  return rotate_clusters_;
}
inline void Pack3DMax::set_rotate_clusters(bool value) {
  
  rotate_clusters_ = value;
  // @@protoc_insertion_point(field_set:y3d.Pack3DMax.rotate_clusters)
}

// optional bool fill_holes = 4;
inline void Pack3DMax::clear_fill_holes() {
  fill_holes_ = false;
}
inline bool Pack3DMax::fill_holes() const {
  // @@protoc_insertion_point(field_get:y3d.Pack3DMax.fill_holes)
  return fill_holes_;
}
inline void Pack3DMax::set_fill_holes(bool value) {
  
  fill_holes_ = value;
  // @@protoc_insertion_point(field_set:y3d.Pack3DMax.fill_holes)
}

// optional bool padding = 5;
inline void Pack3DMax::clear_padding() {
  padding_ = false;
}
inline bool Pack3DMax::padding() const {
  // @@protoc_insertion_point(field_get:y3d.Pack3DMax.padding)
  return padding_;
}
inline void Pack3DMax::set_padding(bool value) {
  
  padding_ = value;
  // @@protoc_insertion_point(field_set:y3d.Pack3DMax.padding)
}

// -------------------------------------------------------------------

// ELowpoly

// optional string oname = 1;
inline void ELowpoly::clear_oname() {
  oname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ELowpoly::oname() const {
  // @@protoc_insertion_point(field_get:y3d.ELowpoly.oname)
  return oname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ELowpoly::set_oname(const ::std::string& value) {
  
  oname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.ELowpoly.oname)
}
inline void ELowpoly::set_oname(const char* value) {
  
  oname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.ELowpoly.oname)
}
inline void ELowpoly::set_oname(const char* value, size_t size) {
  
  oname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.ELowpoly.oname)
}
inline ::std::string* ELowpoly::mutable_oname() {
  
  // @@protoc_insertion_point(field_mutable:y3d.ELowpoly.oname)
  return oname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ELowpoly::release_oname() {
  // @@protoc_insertion_point(field_release:y3d.ELowpoly.oname)
  
  return oname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ELowpoly::set_allocated_oname(::std::string* oname) {
  if (oname != NULL) {
    
  } else {
    
  }
  oname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), oname);
  // @@protoc_insertion_point(field_set_allocated:y3d.ELowpoly.oname)
}

// optional .y3d.LPoly3DMax lp_3dmax = 2;
inline bool ELowpoly::has_lp_3dmax() const {
  return lowtype_case() == kLp3Dmax;
}
inline void ELowpoly::set_has_lp_3dmax() {
  _oneof_case_[0] = kLp3Dmax;
}
inline void ELowpoly::clear_lp_3dmax() {
  if (has_lp_3dmax()) {
    delete lowtype_.lp_3dmax_;
    clear_has_lowtype();
  }
}
inline  const ::y3d::LPoly3DMax& ELowpoly::lp_3dmax() const {
  // @@protoc_insertion_point(field_get:y3d.ELowpoly.lp_3dmax)
  return has_lp_3dmax()
      ? *lowtype_.lp_3dmax_
      : ::y3d::LPoly3DMax::default_instance();
}
inline ::y3d::LPoly3DMax* ELowpoly::mutable_lp_3dmax() {
  if (!has_lp_3dmax()) {
    clear_lowtype();
    set_has_lp_3dmax();
    lowtype_.lp_3dmax_ = new ::y3d::LPoly3DMax;
  }
  // @@protoc_insertion_point(field_mutable:y3d.ELowpoly.lp_3dmax)
  return lowtype_.lp_3dmax_;
}
inline ::y3d::LPoly3DMax* ELowpoly::release_lp_3dmax() {
  // @@protoc_insertion_point(field_release:y3d.ELowpoly.lp_3dmax)
  if (has_lp_3dmax()) {
    clear_has_lowtype();
    ::y3d::LPoly3DMax* temp = lowtype_.lp_3dmax_;
    lowtype_.lp_3dmax_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ELowpoly::set_allocated_lp_3dmax(::y3d::LPoly3DMax* lp_3dmax) {
  clear_lowtype();
  if (lp_3dmax) {
    set_has_lp_3dmax();
    lowtype_.lp_3dmax_ = lp_3dmax;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.ELowpoly.lp_3dmax)
}

// optional .y3d.LPolyBlender lp_blender = 3;
inline bool ELowpoly::has_lp_blender() const {
  return lowtype_case() == kLpBlender;
}
inline void ELowpoly::set_has_lp_blender() {
  _oneof_case_[0] = kLpBlender;
}
inline void ELowpoly::clear_lp_blender() {
  if (has_lp_blender()) {
    delete lowtype_.lp_blender_;
    clear_has_lowtype();
  }
}
inline  const ::y3d::LPolyBlender& ELowpoly::lp_blender() const {
  // @@protoc_insertion_point(field_get:y3d.ELowpoly.lp_blender)
  return has_lp_blender()
      ? *lowtype_.lp_blender_
      : ::y3d::LPolyBlender::default_instance();
}
inline ::y3d::LPolyBlender* ELowpoly::mutable_lp_blender() {
  if (!has_lp_blender()) {
    clear_lowtype();
    set_has_lp_blender();
    lowtype_.lp_blender_ = new ::y3d::LPolyBlender;
  }
  // @@protoc_insertion_point(field_mutable:y3d.ELowpoly.lp_blender)
  return lowtype_.lp_blender_;
}
inline ::y3d::LPolyBlender* ELowpoly::release_lp_blender() {
  // @@protoc_insertion_point(field_release:y3d.ELowpoly.lp_blender)
  if (has_lp_blender()) {
    clear_has_lowtype();
    ::y3d::LPolyBlender* temp = lowtype_.lp_blender_;
    lowtype_.lp_blender_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ELowpoly::set_allocated_lp_blender(::y3d::LPolyBlender* lp_blender) {
  clear_lowtype();
  if (lp_blender) {
    set_has_lp_blender();
    lowtype_.lp_blender_ = lp_blender;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.ELowpoly.lp_blender)
}

// optional .y3d.LPolyMeshlab lp_meshlab = 4;
inline bool ELowpoly::has_lp_meshlab() const {
  return lowtype_case() == kLpMeshlab;
}
inline void ELowpoly::set_has_lp_meshlab() {
  _oneof_case_[0] = kLpMeshlab;
}
inline void ELowpoly::clear_lp_meshlab() {
  if (has_lp_meshlab()) {
    delete lowtype_.lp_meshlab_;
    clear_has_lowtype();
  }
}
inline  const ::y3d::LPolyMeshlab& ELowpoly::lp_meshlab() const {
  // @@protoc_insertion_point(field_get:y3d.ELowpoly.lp_meshlab)
  return has_lp_meshlab()
      ? *lowtype_.lp_meshlab_
      : ::y3d::LPolyMeshlab::default_instance();
}
inline ::y3d::LPolyMeshlab* ELowpoly::mutable_lp_meshlab() {
  if (!has_lp_meshlab()) {
    clear_lowtype();
    set_has_lp_meshlab();
    lowtype_.lp_meshlab_ = new ::y3d::LPolyMeshlab;
  }
  // @@protoc_insertion_point(field_mutable:y3d.ELowpoly.lp_meshlab)
  return lowtype_.lp_meshlab_;
}
inline ::y3d::LPolyMeshlab* ELowpoly::release_lp_meshlab() {
  // @@protoc_insertion_point(field_release:y3d.ELowpoly.lp_meshlab)
  if (has_lp_meshlab()) {
    clear_has_lowtype();
    ::y3d::LPolyMeshlab* temp = lowtype_.lp_meshlab_;
    lowtype_.lp_meshlab_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ELowpoly::set_allocated_lp_meshlab(::y3d::LPolyMeshlab* lp_meshlab) {
  clear_lowtype();
  if (lp_meshlab) {
    set_has_lp_meshlab();
    lowtype_.lp_meshlab_ = lp_meshlab;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.ELowpoly.lp_meshlab)
}

inline bool ELowpoly::has_lowtype() const {
  return lowtype_case() != LOWTYPE_NOT_SET;
}
inline void ELowpoly::clear_has_lowtype() {
  _oneof_case_[0] = LOWTYPE_NOT_SET;
}
inline ELowpoly::LowtypeCase ELowpoly::lowtype_case() const {
  return ELowpoly::LowtypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LPoly3DMax

// optional float vertex_percent = 1;
inline void LPoly3DMax::clear_vertex_percent() {
  vertex_percent_ = 0;
}
inline float LPoly3DMax::vertex_percent() const {
  // @@protoc_insertion_point(field_get:y3d.LPoly3DMax.vertex_percent)
  return vertex_percent_;
}
inline void LPoly3DMax::set_vertex_percent(float value) {
  
  vertex_percent_ = value;
  // @@protoc_insertion_point(field_set:y3d.LPoly3DMax.vertex_percent)
}

// optional int32 vertex_count = 2;
inline void LPoly3DMax::clear_vertex_count() {
  vertex_count_ = 0;
}
inline ::google::protobuf::int32 LPoly3DMax::vertex_count() const {
  // @@protoc_insertion_point(field_get:y3d.LPoly3DMax.vertex_count)
  return vertex_count_;
}
inline void LPoly3DMax::set_vertex_count(::google::protobuf::int32 value) {
  
  vertex_count_ = value;
  // @@protoc_insertion_point(field_set:y3d.LPoly3DMax.vertex_count)
}

// optional .y3d.LPoly3DMax.OpMode optimization_mode = 3;
inline void LPoly3DMax::clear_optimization_mode() {
  optimization_mode_ = 0;
}
inline ::y3d::LPoly3DMax_OpMode LPoly3DMax::optimization_mode() const {
  // @@protoc_insertion_point(field_get:y3d.LPoly3DMax.optimization_mode)
  return static_cast< ::y3d::LPoly3DMax_OpMode >(optimization_mode_);
}
inline void LPoly3DMax::set_optimization_mode(::y3d::LPoly3DMax_OpMode value) {
  
  optimization_mode_ = value;
  // @@protoc_insertion_point(field_set:y3d.LPoly3DMax.optimization_mode)
}

// optional .y3d.LPoly3DMax.NormalMode normals = 4;
inline void LPoly3DMax::clear_normals() {
  normals_ = 0;
}
inline ::y3d::LPoly3DMax_NormalMode LPoly3DMax::normals() const {
  // @@protoc_insertion_point(field_get:y3d.LPoly3DMax.normals)
  return static_cast< ::y3d::LPoly3DMax_NormalMode >(normals_);
}
inline void LPoly3DMax::set_normals(::y3d::LPoly3DMax_NormalMode value) {
  
  normals_ = value;
  // @@protoc_insertion_point(field_set:y3d.LPoly3DMax.normals)
}

// optional bool favor_compact_faces = 5;
inline void LPoly3DMax::clear_favor_compact_faces() {
  favor_compact_faces_ = false;
}
inline bool LPoly3DMax::favor_compact_faces() const {
  // @@protoc_insertion_point(field_get:y3d.LPoly3DMax.favor_compact_faces)
  return favor_compact_faces_;
}
inline void LPoly3DMax::set_favor_compact_faces(bool value) {
  
  favor_compact_faces_ = value;
  // @@protoc_insertion_point(field_set:y3d.LPoly3DMax.favor_compact_faces)
}

// optional bool prevent_flipped_normals = 6;
inline void LPoly3DMax::clear_prevent_flipped_normals() {
  prevent_flipped_normals_ = false;
}
inline bool LPoly3DMax::prevent_flipped_normals() const {
  // @@protoc_insertion_point(field_get:y3d.LPoly3DMax.prevent_flipped_normals)
  return prevent_flipped_normals_;
}
inline void LPoly3DMax::set_prevent_flipped_normals(bool value) {
  
  prevent_flipped_normals_ = value;
  // @@protoc_insertion_point(field_set:y3d.LPoly3DMax.prevent_flipped_normals)
}

// optional bool lock_vertex_position = 7;
inline void LPoly3DMax::clear_lock_vertex_position() {
  lock_vertex_position_ = false;
}
inline bool LPoly3DMax::lock_vertex_position() const {
  // @@protoc_insertion_point(field_get:y3d.LPoly3DMax.lock_vertex_position)
  return lock_vertex_position_;
}
inline void LPoly3DMax::set_lock_vertex_position(bool value) {
  
  lock_vertex_position_ = value;
  // @@protoc_insertion_point(field_set:y3d.LPoly3DMax.lock_vertex_position)
}

// -------------------------------------------------------------------

// LPolyBlender

// optional float ratio = 1;
inline void LPolyBlender::clear_ratio() {
  ratio_ = 0;
}
inline float LPolyBlender::ratio() const {
  // @@protoc_insertion_point(field_get:y3d.LPolyBlender.ratio)
  return ratio_;
}
inline void LPolyBlender::set_ratio(float value) {
  
  ratio_ = value;
  // @@protoc_insertion_point(field_set:y3d.LPolyBlender.ratio)
}

// -------------------------------------------------------------------

// LPolyMeshlab

// -------------------------------------------------------------------

// ENormal

// optional string oname = 1;
inline void ENormal::clear_oname() {
  oname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ENormal::oname() const {
  // @@protoc_insertion_point(field_get:y3d.ENormal.oname)
  return oname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ENormal::set_oname(const ::std::string& value) {
  
  oname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.ENormal.oname)
}
inline void ENormal::set_oname(const char* value) {
  
  oname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.ENormal.oname)
}
inline void ENormal::set_oname(const char* value, size_t size) {
  
  oname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.ENormal.oname)
}
inline ::std::string* ENormal::mutable_oname() {
  
  // @@protoc_insertion_point(field_mutable:y3d.ENormal.oname)
  return oname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ENormal::release_oname() {
  // @@protoc_insertion_point(field_release:y3d.ENormal.oname)
  
  return oname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ENormal::set_allocated_oname(::std::string* oname) {
  if (oname != NULL) {
    
  } else {
    
  }
  oname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), oname);
  // @@protoc_insertion_point(field_set_allocated:y3d.ENormal.oname)
}

// optional string lowpoly = 2;
inline void ENormal::clear_lowpoly() {
  lowpoly_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ENormal::lowpoly() const {
  // @@protoc_insertion_point(field_get:y3d.ENormal.lowpoly)
  return lowpoly_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ENormal::set_lowpoly(const ::std::string& value) {
  
  lowpoly_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.ENormal.lowpoly)
}
inline void ENormal::set_lowpoly(const char* value) {
  
  lowpoly_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.ENormal.lowpoly)
}
inline void ENormal::set_lowpoly(const char* value, size_t size) {
  
  lowpoly_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.ENormal.lowpoly)
}
inline ::std::string* ENormal::mutable_lowpoly() {
  
  // @@protoc_insertion_point(field_mutable:y3d.ENormal.lowpoly)
  return lowpoly_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ENormal::release_lowpoly() {
  // @@protoc_insertion_point(field_release:y3d.ENormal.lowpoly)
  
  return lowpoly_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ENormal::set_allocated_lowpoly(::std::string* lowpoly) {
  if (lowpoly != NULL) {
    
  } else {
    
  }
  lowpoly_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lowpoly);
  // @@protoc_insertion_point(field_set_allocated:y3d.ENormal.lowpoly)
}

// optional string highpoly = 3;
inline void ENormal::clear_highpoly() {
  highpoly_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ENormal::highpoly() const {
  // @@protoc_insertion_point(field_get:y3d.ENormal.highpoly)
  return highpoly_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ENormal::set_highpoly(const ::std::string& value) {
  
  highpoly_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.ENormal.highpoly)
}
inline void ENormal::set_highpoly(const char* value) {
  
  highpoly_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.ENormal.highpoly)
}
inline void ENormal::set_highpoly(const char* value, size_t size) {
  
  highpoly_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.ENormal.highpoly)
}
inline ::std::string* ENormal::mutable_highpoly() {
  
  // @@protoc_insertion_point(field_mutable:y3d.ENormal.highpoly)
  return highpoly_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ENormal::release_highpoly() {
  // @@protoc_insertion_point(field_release:y3d.ENormal.highpoly)
  
  return highpoly_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ENormal::set_allocated_highpoly(::std::string* highpoly) {
  if (highpoly != NULL) {
    
  } else {
    
  }
  highpoly_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), highpoly);
  // @@protoc_insertion_point(field_set_allocated:y3d.ENormal.highpoly)
}

// optional uint32 tex_size = 4;
inline void ENormal::clear_tex_size() {
  tex_size_ = 0u;
}
inline ::google::protobuf::uint32 ENormal::tex_size() const {
  // @@protoc_insertion_point(field_get:y3d.ENormal.tex_size)
  return tex_size_;
}
inline void ENormal::set_tex_size(::google::protobuf::uint32 value) {
  
  tex_size_ = value;
  // @@protoc_insertion_point(field_set:y3d.ENormal.tex_size)
}

// optional string out_tex = 5;
inline void ENormal::clear_out_tex() {
  out_tex_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ENormal::out_tex() const {
  // @@protoc_insertion_point(field_get:y3d.ENormal.out_tex)
  return out_tex_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ENormal::set_out_tex(const ::std::string& value) {
  
  out_tex_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.ENormal.out_tex)
}
inline void ENormal::set_out_tex(const char* value) {
  
  out_tex_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.ENormal.out_tex)
}
inline void ENormal::set_out_tex(const char* value, size_t size) {
  
  out_tex_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.ENormal.out_tex)
}
inline ::std::string* ENormal::mutable_out_tex() {
  
  // @@protoc_insertion_point(field_mutable:y3d.ENormal.out_tex)
  return out_tex_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ENormal::release_out_tex() {
  // @@protoc_insertion_point(field_release:y3d.ENormal.out_tex)
  
  return out_tex_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ENormal::set_allocated_out_tex(::std::string* out_tex) {
  if (out_tex != NULL) {
    
  } else {
    
  }
  out_tex_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), out_tex);
  // @@protoc_insertion_point(field_set_allocated:y3d.ENormal.out_tex)
}

// optional .y3d.Normal3DMax normal_3dmax = 6;
inline bool ENormal::has_normal_3dmax() const {
  return ntype_case() == kNormal3Dmax;
}
inline void ENormal::set_has_normal_3dmax() {
  _oneof_case_[0] = kNormal3Dmax;
}
inline void ENormal::clear_normal_3dmax() {
  if (has_normal_3dmax()) {
    delete ntype_.normal_3dmax_;
    clear_has_ntype();
  }
}
inline  const ::y3d::Normal3DMax& ENormal::normal_3dmax() const {
  // @@protoc_insertion_point(field_get:y3d.ENormal.normal_3dmax)
  return has_normal_3dmax()
      ? *ntype_.normal_3dmax_
      : ::y3d::Normal3DMax::default_instance();
}
inline ::y3d::Normal3DMax* ENormal::mutable_normal_3dmax() {
  if (!has_normal_3dmax()) {
    clear_ntype();
    set_has_normal_3dmax();
    ntype_.normal_3dmax_ = new ::y3d::Normal3DMax;
  }
  // @@protoc_insertion_point(field_mutable:y3d.ENormal.normal_3dmax)
  return ntype_.normal_3dmax_;
}
inline ::y3d::Normal3DMax* ENormal::release_normal_3dmax() {
  // @@protoc_insertion_point(field_release:y3d.ENormal.normal_3dmax)
  if (has_normal_3dmax()) {
    clear_has_ntype();
    ::y3d::Normal3DMax* temp = ntype_.normal_3dmax_;
    ntype_.normal_3dmax_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ENormal::set_allocated_normal_3dmax(::y3d::Normal3DMax* normal_3dmax) {
  clear_ntype();
  if (normal_3dmax) {
    set_has_normal_3dmax();
    ntype_.normal_3dmax_ = normal_3dmax;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.ENormal.normal_3dmax)
}

// optional .xnormal.Settings normal_xnormal = 7;
inline bool ENormal::has_normal_xnormal() const {
  return ntype_case() == kNormalXnormal;
}
inline void ENormal::set_has_normal_xnormal() {
  _oneof_case_[0] = kNormalXnormal;
}
inline void ENormal::clear_normal_xnormal() {
  if (has_normal_xnormal()) {
    delete ntype_.normal_xnormal_;
    clear_has_ntype();
  }
}
inline  const ::xnormal::Settings& ENormal::normal_xnormal() const {
  // @@protoc_insertion_point(field_get:y3d.ENormal.normal_xnormal)
  return has_normal_xnormal()
      ? *ntype_.normal_xnormal_
      : ::xnormal::Settings::default_instance();
}
inline ::xnormal::Settings* ENormal::mutable_normal_xnormal() {
  if (!has_normal_xnormal()) {
    clear_ntype();
    set_has_normal_xnormal();
    ntype_.normal_xnormal_ = new ::xnormal::Settings;
  }
  // @@protoc_insertion_point(field_mutable:y3d.ENormal.normal_xnormal)
  return ntype_.normal_xnormal_;
}
inline ::xnormal::Settings* ENormal::release_normal_xnormal() {
  // @@protoc_insertion_point(field_release:y3d.ENormal.normal_xnormal)
  if (has_normal_xnormal()) {
    clear_has_ntype();
    ::xnormal::Settings* temp = ntype_.normal_xnormal_;
    ntype_.normal_xnormal_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ENormal::set_allocated_normal_xnormal(::xnormal::Settings* normal_xnormal) {
  clear_ntype();
  if (normal_xnormal) {
    set_has_normal_xnormal();
    ntype_.normal_xnormal_ = normal_xnormal;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.ENormal.normal_xnormal)
}

inline bool ENormal::has_ntype() const {
  return ntype_case() != NTYPE_NOT_SET;
}
inline void ENormal::clear_has_ntype() {
  _oneof_case_[0] = NTYPE_NOT_SET;
}
inline ENormal::NtypeCase ENormal::ntype_case() const {
  return ENormal::NtypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Normal3DMax

// -------------------------------------------------------------------

// ResponseEvent

// optional bool error = 1;
inline void ResponseEvent::clear_error() {
  error_ = false;
}
inline bool ResponseEvent::error() const {
  // @@protoc_insertion_point(field_get:y3d.ResponseEvent.error)
  return error_;
}
inline void ResponseEvent::set_error(bool value) {
  
  error_ = value;
  // @@protoc_insertion_point(field_set:y3d.ResponseEvent.error)
}

// optional string msg = 2;
inline void ResponseEvent::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseEvent::msg() const {
  // @@protoc_insertion_point(field_get:y3d.ResponseEvent.msg)
  return msg_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseEvent::set_msg(const ::std::string& value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.ResponseEvent.msg)
}
inline void ResponseEvent::set_msg(const char* value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.ResponseEvent.msg)
}
inline void ResponseEvent::set_msg(const char* value, size_t size) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.ResponseEvent.msg)
}
inline ::std::string* ResponseEvent::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:y3d.ResponseEvent.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseEvent::release_msg() {
  // @@protoc_insertion_point(field_release:y3d.ResponseEvent.msg)
  
  return msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseEvent::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:y3d.ResponseEvent.msg)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace y3d

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::y3d::YResource_ResourceType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::y3d::YResource_ResourceType>() {
  return ::y3d::YResource_ResourceType_descriptor();
}
template <> struct is_proto_enum< ::y3d::YMesh_MeshType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::y3d::YMesh_MeshType>() {
  return ::y3d::YMesh_MeshType_descriptor();
}
template <> struct is_proto_enum< ::y3d::YMesh_XrefStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::y3d::YMesh_XrefStatus>() {
  return ::y3d::YMesh_XrefStatus_descriptor();
}
template <> struct is_proto_enum< ::y3d::LPoly3DMax_OpMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::y3d::LPoly3DMax_OpMode>() {
  return ::y3d::LPoly3DMax_OpMode_descriptor();
}
template <> struct is_proto_enum< ::y3d::LPoly3DMax_NormalMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::y3d::LPoly3DMax_NormalMode>() {
  return ::y3d::LPoly3DMax_NormalMode_descriptor();
}
template <> struct is_proto_enum< ::y3d::ObjectType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::y3d::ObjectType>() {
  return ::y3d::ObjectType_descriptor();
}
template <> struct is_proto_enum< ::y3d::GVerType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::y3d::GVerType>() {
  return ::y3d::GVerType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_y3d_2eproto__INCLUDED
