// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ysetting.proto

#ifndef PROTOBUF_ysetting_2eproto__INCLUDED
#define PROTOBUF_ysetting_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
#include "y3d.pb.h"
// @@protoc_insertion_point(includes)
namespace google {
namespace protobuf {
class Any;
class AnyDefaultTypeInternal;
Y3D_EXPORT_MACRO extern AnyDefaultTypeInternal _Any_default_instance_;
}  // namespace protobuf
}  // namespace google
namespace y3d {
class AttrSet;
class AttrSetDefaultTypeInternal;
Y3D_EXPORT_MACRO extern AttrSetDefaultTypeInternal _AttrSet_default_instance_;
class BatchOptimizeParam;
class BatchOptimizeParamDefaultTypeInternal;
Y3D_EXPORT_MACRO extern BatchOptimizeParamDefaultTypeInternal _BatchOptimizeParam_default_instance_;
class BlenderUnwrap;
class BlenderUnwrapDefaultTypeInternal;
Y3D_EXPORT_MACRO extern BlenderUnwrapDefaultTypeInternal _BlenderUnwrap_default_instance_;
class CustomAttr;
class CustomAttrDefaultTypeInternal;
Y3D_EXPORT_MACRO extern CustomAttrDefaultTypeInternal _CustomAttr_default_instance_;
class EDelete;
class EDeleteDefaultTypeInternal;
Y3D_EXPORT_MACRO extern EDeleteDefaultTypeInternal _EDelete_default_instance_;
class EIsolate;
class EIsolateDefaultTypeInternal;
Y3D_EXPORT_MACRO extern EIsolateDefaultTypeInternal _EIsolate_default_instance_;
class ELowpoly;
class ELowpolyDefaultTypeInternal;
Y3D_EXPORT_MACRO extern ELowpolyDefaultTypeInternal _ELowpoly_default_instance_;
class EMove;
class EMoveDefaultTypeInternal;
Y3D_EXPORT_MACRO extern EMoveDefaultTypeInternal _EMove_default_instance_;
class ENone;
class ENoneDefaultTypeInternal;
Y3D_EXPORT_MACRO extern ENoneDefaultTypeInternal _ENone_default_instance_;
class ENormal;
class ENormalDefaultTypeInternal;
Y3D_EXPORT_MACRO extern ENormalDefaultTypeInternal _ENormal_default_instance_;
class EPacking;
class EPackingDefaultTypeInternal;
Y3D_EXPORT_MACRO extern EPackingDefaultTypeInternal _EPacking_default_instance_;
class ERotate;
class ERotateDefaultTypeInternal;
Y3D_EXPORT_MACRO extern ERotateDefaultTypeInternal _ERotate_default_instance_;
class ESelect;
class ESelectDefaultTypeInternal;
Y3D_EXPORT_MACRO extern ESelectDefaultTypeInternal _ESelect_default_instance_;
class ESelectMany;
class ESelectManyDefaultTypeInternal;
Y3D_EXPORT_MACRO extern ESelectManyDefaultTypeInternal _ESelectMany_default_instance_;
class EUnwrap;
class EUnwrapDefaultTypeInternal;
Y3D_EXPORT_MACRO extern EUnwrapDefaultTypeInternal _EUnwrap_default_instance_;
class EmptyParam;
class EmptyParamDefaultTypeInternal;
Y3D_EXPORT_MACRO extern EmptyParamDefaultTypeInternal _EmptyParam_default_instance_;
class FRangeItem;
class FRangeItemDefaultTypeInternal;
Y3D_EXPORT_MACRO extern FRangeItemDefaultTypeInternal _FRangeItem_default_instance_;
class FilterView;
class FilterViewDefaultTypeInternal;
Y3D_EXPORT_MACRO extern FilterViewDefaultTypeInternal _FilterView_default_instance_;
class LPoly3DMax;
class LPoly3DMaxDefaultTypeInternal;
Y3D_EXPORT_MACRO extern LPoly3DMaxDefaultTypeInternal _LPoly3DMax_default_instance_;
class LPolyBlender;
class LPolyBlenderDefaultTypeInternal;
Y3D_EXPORT_MACRO extern LPolyBlenderDefaultTypeInternal _LPolyBlender_default_instance_;
class LPolyMeshlab;
class LPolyMeshlabDefaultTypeInternal;
Y3D_EXPORT_MACRO extern LPolyMeshlabDefaultTypeInternal _LPolyMeshlab_default_instance_;
class Make4TestParam;
class Make4TestParamDefaultTypeInternal;
Y3D_EXPORT_MACRO extern Make4TestParamDefaultTypeInternal _Make4TestParam_default_instance_;
class MaxUnwrap;
class MaxUnwrapDefaultTypeInternal;
Y3D_EXPORT_MACRO extern MaxUnwrapDefaultTypeInternal _MaxUnwrap_default_instance_;
class NewProjectParam;
class NewProjectParamDefaultTypeInternal;
Y3D_EXPORT_MACRO extern NewProjectParamDefaultTypeInternal _NewProjectParam_default_instance_;
class Normal3DMax;
class Normal3DMaxDefaultTypeInternal;
Y3D_EXPORT_MACRO extern Normal3DMaxDefaultTypeInternal _Normal3DMax_default_instance_;
class OptimizeOptions;
class OptimizeOptionsDefaultTypeInternal;
Y3D_EXPORT_MACRO extern OptimizeOptionsDefaultTypeInternal _OptimizeOptions_default_instance_;
class OptimizeParam;
class OptimizeParamDefaultTypeInternal;
Y3D_EXPORT_MACRO extern OptimizeParamDefaultTypeInternal _OptimizeParam_default_instance_;
class PSetting;
class PSettingDefaultTypeInternal;
Y3D_EXPORT_MACRO extern PSettingDefaultTypeInternal _PSetting_default_instance_;
class Pack3DMax;
class Pack3DMaxDefaultTypeInternal;
Y3D_EXPORT_MACRO extern Pack3DMaxDefaultTypeInternal _Pack3DMax_default_instance_;
class PackRect;
class PackRectDefaultTypeInternal;
Y3D_EXPORT_MACRO extern PackRectDefaultTypeInternal _PackRect_default_instance_;
class ProjectInfo;
class ProjectInfoDefaultTypeInternal;
Y3D_EXPORT_MACRO extern ProjectInfoDefaultTypeInternal _ProjectInfo_default_instance_;
class RenameParam;
class RenameParamDefaultTypeInternal;
Y3D_EXPORT_MACRO extern RenameParamDefaultTypeInternal _RenameParam_default_instance_;
class ResponseEvent;
class ResponseEventDefaultTypeInternal;
Y3D_EXPORT_MACRO extern ResponseEventDefaultTypeInternal _ResponseEvent_default_instance_;
class ResponseNProject;
class ResponseNProjectDefaultTypeInternal;
Y3D_EXPORT_MACRO extern ResponseNProjectDefaultTypeInternal _ResponseNProject_default_instance_;
class ResultReply;
class ResultReplyDefaultTypeInternal;
Y3D_EXPORT_MACRO extern ResultReplyDefaultTypeInternal _ResultReply_default_instance_;
class SettingData;
class SettingDataDefaultTypeInternal;
Y3D_EXPORT_MACRO extern SettingDataDefaultTypeInternal _SettingData_default_instance_;
class StringParam;
class StringParamDefaultTypeInternal;
Y3D_EXPORT_MACRO extern StringParamDefaultTypeInternal _StringParam_default_instance_;
class TColor;
class TColorDefaultTypeInternal;
Y3D_EXPORT_MACRO extern TColorDefaultTypeInternal _TColor_default_instance_;
class TInt;
class TIntDefaultTypeInternal;
Y3D_EXPORT_MACRO extern TIntDefaultTypeInternal _TInt_default_instance_;
class TOptionFloat;
class TOptionFloatDefaultTypeInternal;
Y3D_EXPORT_MACRO extern TOptionFloatDefaultTypeInternal _TOptionFloat_default_instance_;
class TOptionInt;
class TOptionIntDefaultTypeInternal;
Y3D_EXPORT_MACRO extern TOptionIntDefaultTypeInternal _TOptionInt_default_instance_;
class TOptionString;
class TOptionStringDefaultTypeInternal;
Y3D_EXPORT_MACRO extern TOptionStringDefaultTypeInternal _TOptionString_default_instance_;
class TString;
class TStringDefaultTypeInternal;
Y3D_EXPORT_MACRO extern TStringDefaultTypeInternal _TString_default_instance_;
class TestOParam;
class TestOParamDefaultTypeInternal;
Y3D_EXPORT_MACRO extern TestOParamDefaultTypeInternal _TestOParam_default_instance_;
class TestObject;
class TestObjectDefaultTypeInternal;
Y3D_EXPORT_MACRO extern TestObjectDefaultTypeInternal _TestObject_default_instance_;
class TestParam;
class TestParamDefaultTypeInternal;
Y3D_EXPORT_MACRO extern TestParamDefaultTypeInternal _TestParam_default_instance_;
class WorkerApp;
class WorkerAppDefaultTypeInternal;
Y3D_EXPORT_MACRO extern WorkerAppDefaultTypeInternal _WorkerApp_default_instance_;
class YArea;
class YAreaDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YAreaDefaultTypeInternal _YArea_default_instance_;
class YAreaList;
class YAreaListDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YAreaListDefaultTypeInternal _YAreaList_default_instance_;
class YBox3;
class YBox3DefaultTypeInternal;
Y3D_EXPORT_MACRO extern YBox3DefaultTypeInternal _YBox3_default_instance_;
class YCamera;
class YCameraDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YCameraDefaultTypeInternal _YCamera_default_instance_;
class YEvent;
class YEventDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YEventDefaultTypeInternal _YEvent_default_instance_;
class YGroup;
class YGroupDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YGroupDefaultTypeInternal _YGroup_default_instance_;
class YGroupVer;
class YGroupVerDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YGroupVerDefaultTypeInternal _YGroupVer_default_instance_;
class YItemMesh;
class YItemMeshDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YItemMeshDefaultTypeInternal _YItemMesh_default_instance_;
class YJob;
class YJobDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YJobDefaultTypeInternal _YJob_default_instance_;
class YJobAction;
class YJobActionDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YJobActionDefaultTypeInternal _YJobAction_default_instance_;
class YLayer;
class YLayerDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YLayerDefaultTypeInternal _YLayer_default_instance_;
class YLight;
class YLightDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YLightDefaultTypeInternal _YLight_default_instance_;
class YMasterServer;
class YMasterServerDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YMasterServerDefaultTypeInternal _YMasterServer_default_instance_;
class YMesh;
class YMeshDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YMeshDefaultTypeInternal _YMesh_default_instance_;
class YObject;
class YObjectDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YObjectDefaultTypeInternal _YObject_default_instance_;
class YPoint3;
class YPoint3DefaultTypeInternal;
Y3D_EXPORT_MACRO extern YPoint3DefaultTypeInternal _YPoint3_default_instance_;
class YResource;
class YResourceDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YResourceDefaultTypeInternal _YResource_default_instance_;
class YSystem;
class YSystemDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YSystemDefaultTypeInternal _YSystem_default_instance_;
class YWorker;
class YWorkerDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YWorkerDefaultTypeInternal _YWorker_default_instance_;
class YWorkerList;
class YWorkerListDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YWorkerListDefaultTypeInternal _YWorkerList_default_instance_;
class YWorkerRequest;
class YWorkerRequestDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YWorkerRequestDefaultTypeInternal _YWorkerRequest_default_instance_;
class YWorkerResponse;
class YWorkerResponseDefaultTypeInternal;
Y3D_EXPORT_MACRO extern YWorkerResponseDefaultTypeInternal _YWorkerResponse_default_instance_;
}  // namespace y3d

namespace y3d {

namespace protobuf_ysetting_2eproto {
// Internal implementation detail -- do not call these.
struct Y3D_EXPORT_MACRO TableStruct {
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void Y3D_EXPORT_MACRO AddDescriptors();
void Y3D_EXPORT_MACRO InitDefaults();
}  // namespace protobuf_ysetting_2eproto

enum TColor_ColorType {
  TColor_ColorType_RGB = 0,
  TColor_ColorType_RGBA = 1,
  TColor_ColorType_HEX = 2,
  TColor_ColorType_CMYK = 3,
  TColor_ColorType_INT = 4,
  TColor_ColorType_TColor_ColorType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TColor_ColorType_TColor_ColorType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
Y3D_EXPORT_MACRO bool TColor_ColorType_IsValid(int value);
const TColor_ColorType TColor_ColorType_ColorType_MIN = TColor_ColorType_RGB;
const TColor_ColorType TColor_ColorType_ColorType_MAX = TColor_ColorType_INT;
const int TColor_ColorType_ColorType_ARRAYSIZE = TColor_ColorType_ColorType_MAX + 1;

Y3D_EXPORT_MACRO const ::google::protobuf::EnumDescriptor* TColor_ColorType_descriptor();
inline const ::std::string& TColor_ColorType_Name(TColor_ColorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TColor_ColorType_descriptor(), value);
}
inline bool TColor_ColorType_Parse(
    const ::std::string& name, TColor_ColorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TColor_ColorType>(
    TColor_ColorType_descriptor(), name, value);
}
enum ComType {
  TEXT = 0,
  RADIO = 1,
  COMBOBOX = 2,
  MUTILSELECT = 3,
  CHECKBOX = 4,
  ON_OFF = 5,
  FILE = 6,
  COLOR = 7,
  TAG = 8,
  REF = 9,
  IMAGE = 10,
  LINK = 11,
  ComType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ComType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
Y3D_EXPORT_MACRO bool ComType_IsValid(int value);
const ComType ComType_MIN = TEXT;
const ComType ComType_MAX = LINK;
const int ComType_ARRAYSIZE = ComType_MAX + 1;

Y3D_EXPORT_MACRO const ::google::protobuf::EnumDescriptor* ComType_descriptor();
inline const ::std::string& ComType_Name(ComType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ComType_descriptor(), value);
}
inline bool ComType_Parse(
    const ::std::string& name, ComType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ComType>(
    ComType_descriptor(), name, value);
}
// ===================================================================

class Y3D_EXPORT_MACRO CustomAttr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.CustomAttr) */ {
 public:
  CustomAttr();
  virtual ~CustomAttr();

  CustomAttr(const CustomAttr& from);

  inline CustomAttr& operator=(const CustomAttr& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CustomAttr& default_instance();

  enum DataTypeCase {
    kStr = 3,
    kOptionString = 4,
    kOptionInt = 5,
    kOptionFloat = 6,
    kColor = 7,
    DATATYPE_NOT_SET = 0,
  };

  static inline const CustomAttr* internal_default_instance() {
    return reinterpret_cast<const CustomAttr*>(
               &_CustomAttr_default_instance_);
  }

  void Swap(CustomAttr* other);

  // implements Message ----------------------------------------------

  inline CustomAttr* New() const PROTOBUF_FINAL { return New(NULL); }

  CustomAttr* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CustomAttr& from);
  void MergeFrom(const CustomAttr& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CustomAttr* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .y3d.TString str = 3;
  bool has_str() const;
  void clear_str();
  static const int kStrFieldNumber = 3;
  const ::y3d::TString& str() const;
  ::y3d::TString* mutable_str();
  ::y3d::TString* release_str();
  void set_allocated_str(::y3d::TString* str);

  // .y3d.TOptionString optionString = 4;
  bool has_optionstring() const;
  void clear_optionstring();
  static const int kOptionStringFieldNumber = 4;
  const ::y3d::TOptionString& optionstring() const;
  ::y3d::TOptionString* mutable_optionstring();
  ::y3d::TOptionString* release_optionstring();
  void set_allocated_optionstring(::y3d::TOptionString* optionstring);

  // .y3d.TOptionInt optionInt = 5;
  bool has_optionint() const;
  void clear_optionint();
  static const int kOptionIntFieldNumber = 5;
  const ::y3d::TOptionInt& optionint() const;
  ::y3d::TOptionInt* mutable_optionint();
  ::y3d::TOptionInt* release_optionint();
  void set_allocated_optionint(::y3d::TOptionInt* optionint);

  // .y3d.TOptionFloat optionFloat = 6;
  bool has_optionfloat() const;
  void clear_optionfloat();
  static const int kOptionFloatFieldNumber = 6;
  const ::y3d::TOptionFloat& optionfloat() const;
  ::y3d::TOptionFloat* mutable_optionfloat();
  ::y3d::TOptionFloat* release_optionfloat();
  void set_allocated_optionfloat(::y3d::TOptionFloat* optionfloat);

  // .y3d.TColor color = 7;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 7;
  const ::y3d::TColor& color() const;
  ::y3d::TColor* mutable_color();
  ::y3d::TColor* release_color();
  void set_allocated_color(::y3d::TColor* color);

  DataTypeCase dataType_case() const;
  // @@protoc_insertion_point(class_scope:y3d.CustomAttr)
 private:
  void set_has_str();
  void set_has_optionstring();
  void set_has_optionint();
  void set_has_optionfloat();
  void set_has_color();

  inline bool has_dataType() const;
  void clear_dataType();
  inline void clear_has_dataType();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  union DataTypeUnion {
    DataTypeUnion() {}
    ::y3d::TString* str_;
    ::y3d::TOptionString* optionstring_;
    ::y3d::TOptionInt* optionint_;
    ::y3d::TOptionFloat* optionfloat_;
    ::y3d::TColor* color_;
  } dataType_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct Y3D_EXPORT_MACRO protobuf_ysetting_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO TString : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.TString) */ {
 public:
  TString();
  virtual ~TString();

  TString(const TString& from);

  inline TString& operator=(const TString& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TString& default_instance();

  static inline const TString* internal_default_instance() {
    return reinterpret_cast<const TString*>(
               &_TString_default_instance_);
  }

  void Swap(TString* other);

  // implements Message ----------------------------------------------

  inline TString* New() const PROTOBUF_FINAL { return New(NULL); }

  TString* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TString& from);
  void MergeFrom(const TString& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TString* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string RegEx = 2;
  void clear_regex();
  static const int kRegExFieldNumber = 2;
  const ::std::string& regex() const;
  void set_regex(const ::std::string& value);
  #if LANG_CXX11
  void set_regex(::std::string&& value);
  #endif
  void set_regex(const char* value);
  void set_regex(const char* value, size_t size);
  ::std::string* mutable_regex();
  ::std::string* release_regex();
  void set_allocated_regex(::std::string* regex);

  // string Mask = 3;
  void clear_mask();
  static const int kMaskFieldNumber = 3;
  const ::std::string& mask() const;
  void set_mask(const ::std::string& value);
  #if LANG_CXX11
  void set_mask(::std::string&& value);
  #endif
  void set_mask(const char* value);
  void set_mask(const char* value, size_t size);
  ::std::string* mutable_mask();
  ::std::string* release_mask();
  void set_allocated_mask(::std::string* mask);

  // .y3d.ComType com = 1;
  void clear_com();
  static const int kComFieldNumber = 1;
  ::y3d::ComType com() const;
  void set_com(::y3d::ComType value);

  // @@protoc_insertion_point(class_scope:y3d.TString)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr regex_;
  ::google::protobuf::internal::ArenaStringPtr mask_;
  int com_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_ysetting_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO TInt : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.TInt) */ {
 public:
  TInt();
  virtual ~TInt();

  TInt(const TInt& from);

  inline TInt& operator=(const TInt& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TInt& default_instance();

  static inline const TInt* internal_default_instance() {
    return reinterpret_cast<const TInt*>(
               &_TInt_default_instance_);
  }

  void Swap(TInt* other);

  // implements Message ----------------------------------------------

  inline TInt* New() const PROTOBUF_FINAL { return New(NULL); }

  TInt* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TInt& from);
  void MergeFrom(const TInt& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TInt* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .y3d.ComType com = 1;
  void clear_com();
  static const int kComFieldNumber = 1;
  ::y3d::ComType com() const;
  void set_com(::y3d::ComType value);

  // int32 minValue = 2;
  void clear_minvalue();
  static const int kMinValueFieldNumber = 2;
  ::google::protobuf::int32 minvalue() const;
  void set_minvalue(::google::protobuf::int32 value);

  // int32 maxValue = 3;
  void clear_maxvalue();
  static const int kMaxValueFieldNumber = 3;
  ::google::protobuf::int32 maxvalue() const;
  void set_maxvalue(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:y3d.TInt)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int com_;
  ::google::protobuf::int32 minvalue_;
  ::google::protobuf::int32 maxvalue_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_ysetting_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO TOptionString : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.TOptionString) */ {
 public:
  TOptionString();
  virtual ~TOptionString();

  TOptionString(const TOptionString& from);

  inline TOptionString& operator=(const TOptionString& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TOptionString& default_instance();

  static inline const TOptionString* internal_default_instance() {
    return reinterpret_cast<const TOptionString*>(
               &_TOptionString_default_instance_);
  }

  void Swap(TOptionString* other);

  // implements Message ----------------------------------------------

  inline TOptionString* New() const PROTOBUF_FINAL { return New(NULL); }

  TOptionString* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TOptionString& from);
  void MergeFrom(const TOptionString& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TOptionString* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string options = 2;
  int options_size() const;
  void clear_options();
  static const int kOptionsFieldNumber = 2;
  const ::std::string& options(int index) const;
  ::std::string* mutable_options(int index);
  void set_options(int index, const ::std::string& value);
  void set_options(int index, const char* value);
  void set_options(int index, const char* value, size_t size);
  ::std::string* add_options();
  void add_options(const ::std::string& value);
  void add_options(const char* value);
  void add_options(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& options() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_options();

  // .y3d.ComType com = 1;
  void clear_com();
  static const int kComFieldNumber = 1;
  ::y3d::ComType com() const;
  void set_com(::y3d::ComType value);

  // @@protoc_insertion_point(class_scope:y3d.TOptionString)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> options_;
  int com_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_ysetting_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO TOptionInt : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.TOptionInt) */ {
 public:
  TOptionInt();
  virtual ~TOptionInt();

  TOptionInt(const TOptionInt& from);

  inline TOptionInt& operator=(const TOptionInt& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TOptionInt& default_instance();

  static inline const TOptionInt* internal_default_instance() {
    return reinterpret_cast<const TOptionInt*>(
               &_TOptionInt_default_instance_);
  }

  void Swap(TOptionInt* other);

  // implements Message ----------------------------------------------

  inline TOptionInt* New() const PROTOBUF_FINAL { return New(NULL); }

  TOptionInt* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TOptionInt& from);
  void MergeFrom(const TOptionInt& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TOptionInt* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 options = 2;
  int options_size() const;
  void clear_options();
  static const int kOptionsFieldNumber = 2;
  ::google::protobuf::int32 options(int index) const;
  void set_options(int index, ::google::protobuf::int32 value);
  void add_options(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      options() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_options();

  // .y3d.ComType com = 1;
  void clear_com();
  static const int kComFieldNumber = 1;
  ::y3d::ComType com() const;
  void set_com(::y3d::ComType value);

  // @@protoc_insertion_point(class_scope:y3d.TOptionInt)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > options_;
  mutable int _options_cached_byte_size_;
  int com_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_ysetting_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO TOptionFloat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.TOptionFloat) */ {
 public:
  TOptionFloat();
  virtual ~TOptionFloat();

  TOptionFloat(const TOptionFloat& from);

  inline TOptionFloat& operator=(const TOptionFloat& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TOptionFloat& default_instance();

  static inline const TOptionFloat* internal_default_instance() {
    return reinterpret_cast<const TOptionFloat*>(
               &_TOptionFloat_default_instance_);
  }

  void Swap(TOptionFloat* other);

  // implements Message ----------------------------------------------

  inline TOptionFloat* New() const PROTOBUF_FINAL { return New(NULL); }

  TOptionFloat* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TOptionFloat& from);
  void MergeFrom(const TOptionFloat& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TOptionFloat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float options = 2;
  int options_size() const;
  void clear_options();
  static const int kOptionsFieldNumber = 2;
  float options(int index) const;
  void set_options(int index, float value);
  void add_options(float value);
  const ::google::protobuf::RepeatedField< float >&
      options() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_options();

  // .y3d.ComType com = 1;
  void clear_com();
  static const int kComFieldNumber = 1;
  ::y3d::ComType com() const;
  void set_com(::y3d::ComType value);

  // @@protoc_insertion_point(class_scope:y3d.TOptionFloat)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > options_;
  mutable int _options_cached_byte_size_;
  int com_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_ysetting_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO TColor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.TColor) */ {
 public:
  TColor();
  virtual ~TColor();

  TColor(const TColor& from);

  inline TColor& operator=(const TColor& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TColor& default_instance();

  static inline const TColor* internal_default_instance() {
    return reinterpret_cast<const TColor*>(
               &_TColor_default_instance_);
  }

  void Swap(TColor* other);

  // implements Message ----------------------------------------------

  inline TColor* New() const PROTOBUF_FINAL { return New(NULL); }

  TColor* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TColor& from);
  void MergeFrom(const TColor& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TColor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef TColor_ColorType ColorType;
  static const ColorType RGB =
    TColor_ColorType_RGB;
  static const ColorType RGBA =
    TColor_ColorType_RGBA;
  static const ColorType HEX =
    TColor_ColorType_HEX;
  static const ColorType CMYK =
    TColor_ColorType_CMYK;
  static const ColorType INT =
    TColor_ColorType_INT;
  static inline bool ColorType_IsValid(int value) {
    return TColor_ColorType_IsValid(value);
  }
  static const ColorType ColorType_MIN =
    TColor_ColorType_ColorType_MIN;
  static const ColorType ColorType_MAX =
    TColor_ColorType_ColorType_MAX;
  static const int ColorType_ARRAYSIZE =
    TColor_ColorType_ColorType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ColorType_descriptor() {
    return TColor_ColorType_descriptor();
  }
  static inline const ::std::string& ColorType_Name(ColorType value) {
    return TColor_ColorType_Name(value);
  }
  static inline bool ColorType_Parse(const ::std::string& name,
      ColorType* value) {
    return TColor_ColorType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .y3d.ComType com = 1;
  void clear_com();
  static const int kComFieldNumber = 1;
  ::y3d::ComType com() const;
  void set_com(::y3d::ComType value);

  // .y3d.TColor.ColorType ctype = 2;
  void clear_ctype();
  static const int kCtypeFieldNumber = 2;
  ::y3d::TColor_ColorType ctype() const;
  void set_ctype(::y3d::TColor_ColorType value);

  // @@protoc_insertion_point(class_scope:y3d.TColor)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int com_;
  int ctype_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_ysetting_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Y3D_EXPORT_MACRO AttrSet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:y3d.AttrSet) */ {
 public:
  AttrSet();
  virtual ~AttrSet();

  AttrSet(const AttrSet& from);

  inline AttrSet& operator=(const AttrSet& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AttrSet& default_instance();

  static inline const AttrSet* internal_default_instance() {
    return reinterpret_cast<const AttrSet*>(
               &_AttrSet_default_instance_);
  }

  void Swap(AttrSet* other);

  // implements Message ----------------------------------------------

  inline AttrSet* New() const PROTOBUF_FINAL { return New(NULL); }

  AttrSet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AttrSet& from);
  void MergeFrom(const AttrSet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AttrSet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .y3d.CustomAttr attrs = 2;
  int attrs_size() const;
  void clear_attrs();
  static const int kAttrsFieldNumber = 2;
  const ::y3d::CustomAttr& attrs(int index) const;
  ::y3d::CustomAttr* mutable_attrs(int index);
  ::y3d::CustomAttr* add_attrs();
  ::google::protobuf::RepeatedPtrField< ::y3d::CustomAttr >*
      mutable_attrs();
  const ::google::protobuf::RepeatedPtrField< ::y3d::CustomAttr >&
      attrs() const;

  // string sname = 1;
  void clear_sname();
  static const int kSnameFieldNumber = 1;
  const ::std::string& sname() const;
  void set_sname(const ::std::string& value);
  #if LANG_CXX11
  void set_sname(::std::string&& value);
  #endif
  void set_sname(const char* value);
  void set_sname(const char* value, size_t size);
  ::std::string* mutable_sname();
  ::std::string* release_sname();
  void set_allocated_sname(::std::string* sname);

  // @@protoc_insertion_point(class_scope:y3d.AttrSet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::y3d::CustomAttr > attrs_;
  ::google::protobuf::internal::ArenaStringPtr sname_;
  mutable int _cached_size_;
  friend struct Y3D_EXPORT_MACRO protobuf_ysetting_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// CustomAttr

// string name = 1;
inline void CustomAttr::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CustomAttr::name() const {
  // @@protoc_insertion_point(field_get:y3d.CustomAttr.name)
  return name_.GetNoArena();
}
inline void CustomAttr::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.CustomAttr.name)
}
#if LANG_CXX11
inline void CustomAttr::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.CustomAttr.name)
}
#endif
inline void CustomAttr::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.CustomAttr.name)
}
inline void CustomAttr::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.CustomAttr.name)
}
inline ::std::string* CustomAttr::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:y3d.CustomAttr.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CustomAttr::release_name() {
  // @@protoc_insertion_point(field_release:y3d.CustomAttr.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CustomAttr::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:y3d.CustomAttr.name)
}

// .y3d.TString str = 3;
inline bool CustomAttr::has_str() const {
  return dataType_case() == kStr;
}
inline void CustomAttr::set_has_str() {
  _oneof_case_[0] = kStr;
}
inline void CustomAttr::clear_str() {
  if (has_str()) {
    delete dataType_.str_;
    clear_has_dataType();
  }
}
inline  const ::y3d::TString& CustomAttr::str() const {
  // @@protoc_insertion_point(field_get:y3d.CustomAttr.str)
  return has_str()
      ? *dataType_.str_
      : ::y3d::TString::default_instance();
}
inline ::y3d::TString* CustomAttr::mutable_str() {
  if (!has_str()) {
    clear_dataType();
    set_has_str();
    dataType_.str_ = new ::y3d::TString;
  }
  // @@protoc_insertion_point(field_mutable:y3d.CustomAttr.str)
  return dataType_.str_;
}
inline ::y3d::TString* CustomAttr::release_str() {
  // @@protoc_insertion_point(field_release:y3d.CustomAttr.str)
  if (has_str()) {
    clear_has_dataType();
    ::y3d::TString* temp = dataType_.str_;
    dataType_.str_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void CustomAttr::set_allocated_str(::y3d::TString* str) {
  clear_dataType();
  if (str) {
    set_has_str();
    dataType_.str_ = str;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.CustomAttr.str)
}

// .y3d.TOptionString optionString = 4;
inline bool CustomAttr::has_optionstring() const {
  return dataType_case() == kOptionString;
}
inline void CustomAttr::set_has_optionstring() {
  _oneof_case_[0] = kOptionString;
}
inline void CustomAttr::clear_optionstring() {
  if (has_optionstring()) {
    delete dataType_.optionstring_;
    clear_has_dataType();
  }
}
inline  const ::y3d::TOptionString& CustomAttr::optionstring() const {
  // @@protoc_insertion_point(field_get:y3d.CustomAttr.optionString)
  return has_optionstring()
      ? *dataType_.optionstring_
      : ::y3d::TOptionString::default_instance();
}
inline ::y3d::TOptionString* CustomAttr::mutable_optionstring() {
  if (!has_optionstring()) {
    clear_dataType();
    set_has_optionstring();
    dataType_.optionstring_ = new ::y3d::TOptionString;
  }
  // @@protoc_insertion_point(field_mutable:y3d.CustomAttr.optionString)
  return dataType_.optionstring_;
}
inline ::y3d::TOptionString* CustomAttr::release_optionstring() {
  // @@protoc_insertion_point(field_release:y3d.CustomAttr.optionString)
  if (has_optionstring()) {
    clear_has_dataType();
    ::y3d::TOptionString* temp = dataType_.optionstring_;
    dataType_.optionstring_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void CustomAttr::set_allocated_optionstring(::y3d::TOptionString* optionstring) {
  clear_dataType();
  if (optionstring) {
    set_has_optionstring();
    dataType_.optionstring_ = optionstring;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.CustomAttr.optionString)
}

// .y3d.TOptionInt optionInt = 5;
inline bool CustomAttr::has_optionint() const {
  return dataType_case() == kOptionInt;
}
inline void CustomAttr::set_has_optionint() {
  _oneof_case_[0] = kOptionInt;
}
inline void CustomAttr::clear_optionint() {
  if (has_optionint()) {
    delete dataType_.optionint_;
    clear_has_dataType();
  }
}
inline  const ::y3d::TOptionInt& CustomAttr::optionint() const {
  // @@protoc_insertion_point(field_get:y3d.CustomAttr.optionInt)
  return has_optionint()
      ? *dataType_.optionint_
      : ::y3d::TOptionInt::default_instance();
}
inline ::y3d::TOptionInt* CustomAttr::mutable_optionint() {
  if (!has_optionint()) {
    clear_dataType();
    set_has_optionint();
    dataType_.optionint_ = new ::y3d::TOptionInt;
  }
  // @@protoc_insertion_point(field_mutable:y3d.CustomAttr.optionInt)
  return dataType_.optionint_;
}
inline ::y3d::TOptionInt* CustomAttr::release_optionint() {
  // @@protoc_insertion_point(field_release:y3d.CustomAttr.optionInt)
  if (has_optionint()) {
    clear_has_dataType();
    ::y3d::TOptionInt* temp = dataType_.optionint_;
    dataType_.optionint_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void CustomAttr::set_allocated_optionint(::y3d::TOptionInt* optionint) {
  clear_dataType();
  if (optionint) {
    set_has_optionint();
    dataType_.optionint_ = optionint;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.CustomAttr.optionInt)
}

// .y3d.TOptionFloat optionFloat = 6;
inline bool CustomAttr::has_optionfloat() const {
  return dataType_case() == kOptionFloat;
}
inline void CustomAttr::set_has_optionfloat() {
  _oneof_case_[0] = kOptionFloat;
}
inline void CustomAttr::clear_optionfloat() {
  if (has_optionfloat()) {
    delete dataType_.optionfloat_;
    clear_has_dataType();
  }
}
inline  const ::y3d::TOptionFloat& CustomAttr::optionfloat() const {
  // @@protoc_insertion_point(field_get:y3d.CustomAttr.optionFloat)
  return has_optionfloat()
      ? *dataType_.optionfloat_
      : ::y3d::TOptionFloat::default_instance();
}
inline ::y3d::TOptionFloat* CustomAttr::mutable_optionfloat() {
  if (!has_optionfloat()) {
    clear_dataType();
    set_has_optionfloat();
    dataType_.optionfloat_ = new ::y3d::TOptionFloat;
  }
  // @@protoc_insertion_point(field_mutable:y3d.CustomAttr.optionFloat)
  return dataType_.optionfloat_;
}
inline ::y3d::TOptionFloat* CustomAttr::release_optionfloat() {
  // @@protoc_insertion_point(field_release:y3d.CustomAttr.optionFloat)
  if (has_optionfloat()) {
    clear_has_dataType();
    ::y3d::TOptionFloat* temp = dataType_.optionfloat_;
    dataType_.optionfloat_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void CustomAttr::set_allocated_optionfloat(::y3d::TOptionFloat* optionfloat) {
  clear_dataType();
  if (optionfloat) {
    set_has_optionfloat();
    dataType_.optionfloat_ = optionfloat;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.CustomAttr.optionFloat)
}

// .y3d.TColor color = 7;
inline bool CustomAttr::has_color() const {
  return dataType_case() == kColor;
}
inline void CustomAttr::set_has_color() {
  _oneof_case_[0] = kColor;
}
inline void CustomAttr::clear_color() {
  if (has_color()) {
    delete dataType_.color_;
    clear_has_dataType();
  }
}
inline  const ::y3d::TColor& CustomAttr::color() const {
  // @@protoc_insertion_point(field_get:y3d.CustomAttr.color)
  return has_color()
      ? *dataType_.color_
      : ::y3d::TColor::default_instance();
}
inline ::y3d::TColor* CustomAttr::mutable_color() {
  if (!has_color()) {
    clear_dataType();
    set_has_color();
    dataType_.color_ = new ::y3d::TColor;
  }
  // @@protoc_insertion_point(field_mutable:y3d.CustomAttr.color)
  return dataType_.color_;
}
inline ::y3d::TColor* CustomAttr::release_color() {
  // @@protoc_insertion_point(field_release:y3d.CustomAttr.color)
  if (has_color()) {
    clear_has_dataType();
    ::y3d::TColor* temp = dataType_.color_;
    dataType_.color_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void CustomAttr::set_allocated_color(::y3d::TColor* color) {
  clear_dataType();
  if (color) {
    set_has_color();
    dataType_.color_ = color;
  }
  // @@protoc_insertion_point(field_set_allocated:y3d.CustomAttr.color)
}

inline bool CustomAttr::has_dataType() const {
  return dataType_case() != DATATYPE_NOT_SET;
}
inline void CustomAttr::clear_has_dataType() {
  _oneof_case_[0] = DATATYPE_NOT_SET;
}
inline CustomAttr::DataTypeCase CustomAttr::dataType_case() const {
  return CustomAttr::DataTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TString

// .y3d.ComType com = 1;
inline void TString::clear_com() {
  com_ = 0;
}
inline ::y3d::ComType TString::com() const {
  // @@protoc_insertion_point(field_get:y3d.TString.com)
  return static_cast< ::y3d::ComType >(com_);
}
inline void TString::set_com(::y3d::ComType value) {
  
  com_ = value;
  // @@protoc_insertion_point(field_set:y3d.TString.com)
}

// string RegEx = 2;
inline void TString::clear_regex() {
  regex_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TString::regex() const {
  // @@protoc_insertion_point(field_get:y3d.TString.RegEx)
  return regex_.GetNoArena();
}
inline void TString::set_regex(const ::std::string& value) {
  
  regex_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.TString.RegEx)
}
#if LANG_CXX11
inline void TString::set_regex(::std::string&& value) {
  
  regex_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.TString.RegEx)
}
#endif
inline void TString::set_regex(const char* value) {
  
  regex_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.TString.RegEx)
}
inline void TString::set_regex(const char* value, size_t size) {
  
  regex_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.TString.RegEx)
}
inline ::std::string* TString::mutable_regex() {
  
  // @@protoc_insertion_point(field_mutable:y3d.TString.RegEx)
  return regex_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TString::release_regex() {
  // @@protoc_insertion_point(field_release:y3d.TString.RegEx)
  
  return regex_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TString::set_allocated_regex(::std::string* regex) {
  if (regex != NULL) {
    
  } else {
    
  }
  regex_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), regex);
  // @@protoc_insertion_point(field_set_allocated:y3d.TString.RegEx)
}

// string Mask = 3;
inline void TString::clear_mask() {
  mask_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TString::mask() const {
  // @@protoc_insertion_point(field_get:y3d.TString.Mask)
  return mask_.GetNoArena();
}
inline void TString::set_mask(const ::std::string& value) {
  
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.TString.Mask)
}
#if LANG_CXX11
inline void TString::set_mask(::std::string&& value) {
  
  mask_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.TString.Mask)
}
#endif
inline void TString::set_mask(const char* value) {
  
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.TString.Mask)
}
inline void TString::set_mask(const char* value, size_t size) {
  
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.TString.Mask)
}
inline ::std::string* TString::mutable_mask() {
  
  // @@protoc_insertion_point(field_mutable:y3d.TString.Mask)
  return mask_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TString::release_mask() {
  // @@protoc_insertion_point(field_release:y3d.TString.Mask)
  
  return mask_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TString::set_allocated_mask(::std::string* mask) {
  if (mask != NULL) {
    
  } else {
    
  }
  mask_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mask);
  // @@protoc_insertion_point(field_set_allocated:y3d.TString.Mask)
}

// -------------------------------------------------------------------

// TInt

// .y3d.ComType com = 1;
inline void TInt::clear_com() {
  com_ = 0;
}
inline ::y3d::ComType TInt::com() const {
  // @@protoc_insertion_point(field_get:y3d.TInt.com)
  return static_cast< ::y3d::ComType >(com_);
}
inline void TInt::set_com(::y3d::ComType value) {
  
  com_ = value;
  // @@protoc_insertion_point(field_set:y3d.TInt.com)
}

// int32 minValue = 2;
inline void TInt::clear_minvalue() {
  minvalue_ = 0;
}
inline ::google::protobuf::int32 TInt::minvalue() const {
  // @@protoc_insertion_point(field_get:y3d.TInt.minValue)
  return minvalue_;
}
inline void TInt::set_minvalue(::google::protobuf::int32 value) {
  
  minvalue_ = value;
  // @@protoc_insertion_point(field_set:y3d.TInt.minValue)
}

// int32 maxValue = 3;
inline void TInt::clear_maxvalue() {
  maxvalue_ = 0;
}
inline ::google::protobuf::int32 TInt::maxvalue() const {
  // @@protoc_insertion_point(field_get:y3d.TInt.maxValue)
  return maxvalue_;
}
inline void TInt::set_maxvalue(::google::protobuf::int32 value) {
  
  maxvalue_ = value;
  // @@protoc_insertion_point(field_set:y3d.TInt.maxValue)
}

// -------------------------------------------------------------------

// TOptionString

// .y3d.ComType com = 1;
inline void TOptionString::clear_com() {
  com_ = 0;
}
inline ::y3d::ComType TOptionString::com() const {
  // @@protoc_insertion_point(field_get:y3d.TOptionString.com)
  return static_cast< ::y3d::ComType >(com_);
}
inline void TOptionString::set_com(::y3d::ComType value) {
  
  com_ = value;
  // @@protoc_insertion_point(field_set:y3d.TOptionString.com)
}

// repeated string options = 2;
inline int TOptionString::options_size() const {
  return options_.size();
}
inline void TOptionString::clear_options() {
  options_.Clear();
}
inline const ::std::string& TOptionString::options(int index) const {
  // @@protoc_insertion_point(field_get:y3d.TOptionString.options)
  return options_.Get(index);
}
inline ::std::string* TOptionString::mutable_options(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.TOptionString.options)
  return options_.Mutable(index);
}
inline void TOptionString::set_options(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:y3d.TOptionString.options)
  options_.Mutable(index)->assign(value);
}
inline void TOptionString::set_options(int index, const char* value) {
  options_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:y3d.TOptionString.options)
}
inline void TOptionString::set_options(int index, const char* value, size_t size) {
  options_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:y3d.TOptionString.options)
}
inline ::std::string* TOptionString::add_options() {
  // @@protoc_insertion_point(field_add_mutable:y3d.TOptionString.options)
  return options_.Add();
}
inline void TOptionString::add_options(const ::std::string& value) {
  options_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:y3d.TOptionString.options)
}
inline void TOptionString::add_options(const char* value) {
  options_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:y3d.TOptionString.options)
}
inline void TOptionString::add_options(const char* value, size_t size) {
  options_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:y3d.TOptionString.options)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TOptionString::options() const {
  // @@protoc_insertion_point(field_list:y3d.TOptionString.options)
  return options_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TOptionString::mutable_options() {
  // @@protoc_insertion_point(field_mutable_list:y3d.TOptionString.options)
  return &options_;
}

// -------------------------------------------------------------------

// TOptionInt

// .y3d.ComType com = 1;
inline void TOptionInt::clear_com() {
  com_ = 0;
}
inline ::y3d::ComType TOptionInt::com() const {
  // @@protoc_insertion_point(field_get:y3d.TOptionInt.com)
  return static_cast< ::y3d::ComType >(com_);
}
inline void TOptionInt::set_com(::y3d::ComType value) {
  
  com_ = value;
  // @@protoc_insertion_point(field_set:y3d.TOptionInt.com)
}

// repeated int32 options = 2;
inline int TOptionInt::options_size() const {
  return options_.size();
}
inline void TOptionInt::clear_options() {
  options_.Clear();
}
inline ::google::protobuf::int32 TOptionInt::options(int index) const {
  // @@protoc_insertion_point(field_get:y3d.TOptionInt.options)
  return options_.Get(index);
}
inline void TOptionInt::set_options(int index, ::google::protobuf::int32 value) {
  options_.Set(index, value);
  // @@protoc_insertion_point(field_set:y3d.TOptionInt.options)
}
inline void TOptionInt::add_options(::google::protobuf::int32 value) {
  options_.Add(value);
  // @@protoc_insertion_point(field_add:y3d.TOptionInt.options)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
TOptionInt::options() const {
  // @@protoc_insertion_point(field_list:y3d.TOptionInt.options)
  return options_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
TOptionInt::mutable_options() {
  // @@protoc_insertion_point(field_mutable_list:y3d.TOptionInt.options)
  return &options_;
}

// -------------------------------------------------------------------

// TOptionFloat

// .y3d.ComType com = 1;
inline void TOptionFloat::clear_com() {
  com_ = 0;
}
inline ::y3d::ComType TOptionFloat::com() const {
  // @@protoc_insertion_point(field_get:y3d.TOptionFloat.com)
  return static_cast< ::y3d::ComType >(com_);
}
inline void TOptionFloat::set_com(::y3d::ComType value) {
  
  com_ = value;
  // @@protoc_insertion_point(field_set:y3d.TOptionFloat.com)
}

// repeated float options = 2;
inline int TOptionFloat::options_size() const {
  return options_.size();
}
inline void TOptionFloat::clear_options() {
  options_.Clear();
}
inline float TOptionFloat::options(int index) const {
  // @@protoc_insertion_point(field_get:y3d.TOptionFloat.options)
  return options_.Get(index);
}
inline void TOptionFloat::set_options(int index, float value) {
  options_.Set(index, value);
  // @@protoc_insertion_point(field_set:y3d.TOptionFloat.options)
}
inline void TOptionFloat::add_options(float value) {
  options_.Add(value);
  // @@protoc_insertion_point(field_add:y3d.TOptionFloat.options)
}
inline const ::google::protobuf::RepeatedField< float >&
TOptionFloat::options() const {
  // @@protoc_insertion_point(field_list:y3d.TOptionFloat.options)
  return options_;
}
inline ::google::protobuf::RepeatedField< float >*
TOptionFloat::mutable_options() {
  // @@protoc_insertion_point(field_mutable_list:y3d.TOptionFloat.options)
  return &options_;
}

// -------------------------------------------------------------------

// TColor

// .y3d.ComType com = 1;
inline void TColor::clear_com() {
  com_ = 0;
}
inline ::y3d::ComType TColor::com() const {
  // @@protoc_insertion_point(field_get:y3d.TColor.com)
  return static_cast< ::y3d::ComType >(com_);
}
inline void TColor::set_com(::y3d::ComType value) {
  
  com_ = value;
  // @@protoc_insertion_point(field_set:y3d.TColor.com)
}

// .y3d.TColor.ColorType ctype = 2;
inline void TColor::clear_ctype() {
  ctype_ = 0;
}
inline ::y3d::TColor_ColorType TColor::ctype() const {
  // @@protoc_insertion_point(field_get:y3d.TColor.ctype)
  return static_cast< ::y3d::TColor_ColorType >(ctype_);
}
inline void TColor::set_ctype(::y3d::TColor_ColorType value) {
  
  ctype_ = value;
  // @@protoc_insertion_point(field_set:y3d.TColor.ctype)
}

// -------------------------------------------------------------------

// AttrSet

// string sname = 1;
inline void AttrSet::clear_sname() {
  sname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AttrSet::sname() const {
  // @@protoc_insertion_point(field_get:y3d.AttrSet.sname)
  return sname_.GetNoArena();
}
inline void AttrSet::set_sname(const ::std::string& value) {
  
  sname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:y3d.AttrSet.sname)
}
#if LANG_CXX11
inline void AttrSet::set_sname(::std::string&& value) {
  
  sname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:y3d.AttrSet.sname)
}
#endif
inline void AttrSet::set_sname(const char* value) {
  
  sname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:y3d.AttrSet.sname)
}
inline void AttrSet::set_sname(const char* value, size_t size) {
  
  sname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:y3d.AttrSet.sname)
}
inline ::std::string* AttrSet::mutable_sname() {
  
  // @@protoc_insertion_point(field_mutable:y3d.AttrSet.sname)
  return sname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AttrSet::release_sname() {
  // @@protoc_insertion_point(field_release:y3d.AttrSet.sname)
  
  return sname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AttrSet::set_allocated_sname(::std::string* sname) {
  if (sname != NULL) {
    
  } else {
    
  }
  sname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sname);
  // @@protoc_insertion_point(field_set_allocated:y3d.AttrSet.sname)
}

// repeated .y3d.CustomAttr attrs = 2;
inline int AttrSet::attrs_size() const {
  return attrs_.size();
}
inline void AttrSet::clear_attrs() {
  attrs_.Clear();
}
inline const ::y3d::CustomAttr& AttrSet::attrs(int index) const {
  // @@protoc_insertion_point(field_get:y3d.AttrSet.attrs)
  return attrs_.Get(index);
}
inline ::y3d::CustomAttr* AttrSet::mutable_attrs(int index) {
  // @@protoc_insertion_point(field_mutable:y3d.AttrSet.attrs)
  return attrs_.Mutable(index);
}
inline ::y3d::CustomAttr* AttrSet::add_attrs() {
  // @@protoc_insertion_point(field_add:y3d.AttrSet.attrs)
  return attrs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::y3d::CustomAttr >*
AttrSet::mutable_attrs() {
  // @@protoc_insertion_point(field_mutable_list:y3d.AttrSet.attrs)
  return &attrs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::y3d::CustomAttr >&
AttrSet::attrs() const {
  // @@protoc_insertion_point(field_list:y3d.AttrSet.attrs)
  return attrs_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace y3d

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::y3d::TColor_ColorType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::y3d::TColor_ColorType>() {
  return ::y3d::TColor_ColorType_descriptor();
}
template <> struct is_proto_enum< ::y3d::ComType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::y3d::ComType>() {
  return ::y3d::ComType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ysetting_2eproto__INCLUDED
